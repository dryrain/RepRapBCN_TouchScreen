file C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS

file C:\Program Files\4D Labs\4D Workshop 4 IDE\include\uLCD-32PTU.fnc

000001  000001  #platform "uLCD-32PTU"
000002  000001  #platform "uLCD-32PTU"
000003  000008  */
000004  000009      #constant ULCD_32PT_GFX
000005  000009      #constant ULCD_32PT_GFX
000006  000010        
000007  000011      #IFNOT EXISTS PICASO_FUNCTIONS
file C:\Program Files\4D Labs\4D Workshop 4 IDE\include\PicasoFunctions.fnc

000008  000012          #inherit "PicasoFunctions.fnc"          // inherit the generic functions
000009  000012          #inherit "PicasoFunctions.fnc"          // inherit the generic functions
000010  000001        
000011  000002  // Common inheritance for PicasoGFX2 platforms
000012  000003        
000013  000004  #constant PICASO_FUNCTIONS
000014  000004  #constant PICASO_FUNCTIONS
000015  000005        
000016  000006        
000017  000007  #CONST
000018  000017  #END
000019  000018        
000020  000019  #CONST
000021  000025  #END
000022  000026        
000023  000027        
000024  000028  #CONST
000025  000040  #END
000026  000041        
000027  000042        
000028  000043  #CONST
000029  000208  #END
000030  000209        
000031  000210        
000032  000211  // baud divisor rates for setbaud(n);
000033  000212  #CONST
000034  000234  #END
000035  000235        
000036  000236        
000037  000237        
000038  000238        
000039  000243  */
000040  000244        
000041  000245        
000042  000246  //==============================================//
000043  000247  // EVE bios functions                           //
000044  000248  //==============================================//
000045  000249                                                  //
000046  000250  func serin(), 1;                // read a byte from COM0
000047  000251  // Syntax: serin();
000048  000252  // Usage : char := serin();
000049  000253  // Notes : Receives a character from the Serial Port COM0. The transmission format is:
000050  000254  //     : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
000051  000255  //     : The default Baud Rate is 115,200 bits per second or 115,200 baud. The baud rate can be
000052  000256  //     : changed under program control by using the setbaud(...) or the com_SetBaud(...) function.
000053  000257  //     : Returns: -1 if no character is available
000054  000258  //     : Returns: -2 if a framing error or over-run has occurred (auto cleared)
000055  000259  //     : Returns: positive value 0 to 255 for a valid character received
000056  000260        
000057  000261  func putch("char"), 0;                // write single char to current output device
000058  000262  // Syntax: putch("char");
000059  000263  // Usage : putch("A");
000060  000264  // Notes : Transmits a single byte from the Serial Port COM0. The transmission format is:
000061  000265  //     : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
000062  000266  //     : The default Baud Rate is 115,200 bits per second or 115,200 baud. The baud rate can be
000063  000267  //     : changed under program control by using the setbaud(...) or the com_SetBaud(...) function.
000064  000268  //     : The arguments can be a variable, array element, expression or constant
000065  000269        
000066  000270  func serout("char"), 0;                // write a byte to COM0
000067  000271  // Syntax: serout1("char");
000068  000272  // Usage : serout1(ch);
000069  000273  // Notes : send character to COM1
000070  000274        
000071  000275  func setbaud("baudnum"), 0;            // set baud rate of COM0
000072  000276  // Syntax: setbaud(baud_number);
000073  000277  // Usage : setbaud(BAUD_128000);        //Set baud rate to 128000bps
000074  000278  // *Notes : argument specifies the baud rate using pre-defined constant.
000075  000279  //       : The pre-defined constant is a value of 0-19 , and internally
000076  000280  //       : this is used as a table pointer to get the baud rate divisor
000077  000281  //       : value for one of the 20 selected baud rates, control is then
000078  000282  //       : passed to com_SetBaud(COM0, baudlookup[baud_number]);
000079  000283  //       : The pre-defined constants equate to a value of 0-19.
000080  000284  //       : If a value other than 0-19 is used, a run time error (eror 25)
000081  000285  //       : will occur.
000082  000286        
000083  000287  func to("device"), 1;                // output device redirection
000084  000288  // Syntax: to(outstream);
000085  000289  // Usage : to(APPEND); putstr("TWO ");
000086  000290  // Notes : outstream: A variable or constant specifying destination for putch, putstr, putnum and print functions.
000087  000291  //     :
000088  000292  //     : to() sends the printed output to destinations other than the screen. Normally, print just
000089  000293  //     : sends its output to the display in TEXT mode which is the default, however, the output from
000090  000294  //     : print can be sent to COM0, and MDA (media) 'streams'. The to(...) function can also stream
000091  000295  //     : to a memory array . Note that once the to(...) function has taken effect, the stream reverts
000092  000296  //     : back to the default stream which is TEXT as soon as putch, putstr, putnum or print has
000093  000297  //     : completed its action. The APPEND argument is used to send the printed output to the same
000094  000298  //     : place as the previous redirection. This is most useful for building string arrays, or adding
000095  000299  //     : sequential data to a media stream.
000096  000300  //     :
000097  000301  //     : Predefined Name Constant    putch(), putstr(), putnum(), print() redirection
000098  000302  //     : APPEND         0x0000      Output is directed to the same stream that was previously assigned. Output is
000099  000303  //     :                            appended to user memory if previous redirection was to an array.
000100  000304  //     : COM0           0xFF04      Output is redirected to the COM (serial) port.
000101  000305  //     : TEXT           0xFF08      Output is directed to the screen (default).
000102  000306  //     : MDA            0xFF10      Output is directed to the SD or FLASH media.
000103  000307  //     : I2C            0xF820      Output is directed to the I2C port.
000104  000308  //     : memory pointer             Output is redirect to the memory pointer argument, eg to(myarray); print("HELLO");
000105  000309        
000106  000310        
000107  000311  func pause("milliseconds"), 0;            // blocking delay
000108  000312  // Syntax: pause(milliseconds);
000109  000313  // Usage : pause(1000);                //pause for 1 second
000110  000314  // Notes : Pause for a number of milli second.Maximum delay could be 65535 milli seconds
000111  000315        
000112  000316  func putnum("arg1","arg2"), 1;            // print number to current output device
000113  000317  // Syntax: putnum(format, value);
000114  000318  // Usage : var := putnum(HEX, val);
000115  000319  // Notes : prints a 16bit number in various formats to the current output stream, usually the display.
000116  000320  //     : Format: A constant that specifies the number format
000117  000321  //     : Value : The number to be printed
000118  000322  //     : (      DECIMAL   )    (   UNSIGNED DECIMAL )    (    HEX         )     (    BINARY          )
000119  000323  //     : DEC     DECZ     DECZB     UDEC     UDECZ     UDECZB     HEX     HEXZ     HEXZB     BIN     BINZ     BINZB
000120  000324  //     : DEC1 DEC1Z     DEC1ZB     UDEC1     UDEC1Z     UDEC1ZB HEX1     HEX1Z     HEX1ZB     BIN1     BIN1Z     BIN1ZB
000121  000325  //     : DEC2 DEC2Z     DEC2ZB     UDEC2     UDEC2Z     UDEC2ZB HEX2     HEX2Z     HEX1ZB     BIN2     BIN2Z     BIN2ZB
000122  000326  //     : DEC3 DEC3Z     DEC3ZB     UDEC3     UDEC3Z     UDEC3ZB HEX3     HEX3Z     HEX1ZB     BIN3     BIN3Z     BIN3ZB
000123  000327  //     : DEC4 DEC4Z     DEC4ZB     UDEC4     UDEC4Z     UDEC4ZB HEX4     HEX4Z     HEX1ZB     BIN4     BIN4Z     BIN4ZB
000124  000328  //     : DEC5 DEC5Z     DEC5ZB     UDEC5     UDEC5Z     UDEC5ZB             BIN5     BIN5Z     BIN5ZB
000125  000329  //     :                                     BIN6     BIN6Z     BIN6ZB
000126  000330  //     :                                     BIN7     BIN7Z     BIN7ZB
000127  000331  //     :                                     BIN8     BIN8Z     BIN8ZB
000128  000332  //     :                                     BIN9     BIN9Z     BIN9ZB
000129  000333  //     :                                     BIN10     BIN10Z     BIN10ZB
000130  000334  //     :                                     BIN11     BIN11Z     BIN11ZB
000131  000335  //     :                                     BIN12     BIN12Z     BIN12ZB
000132  000336  //     :                                     BIN13     BIN13Z     BIN13ZB
000133  000337  //     :                                     BIN14     BIN14Z     BIN14ZB
000134  000338  //     :                                     BIN15     BIN15Z     BIN15ZB
000135  000339  //     :                                     BIN16     BIN16Z     BIN16ZB
000136  000340  //     : field: Returns the the default width of the numeric field (digit count), usually ignored.
000137  000341  //     : bit 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
000138  000342  //     : | | | | \___ ___/ \__ __/ \_____ _____/
000139  000343  //     : | | | | V V V
000140  000344  //     : | | | | | | |
000141  000345  //     : | | | | | |
000142  000346  //     : | | | | (nb 0 = 16) | |____BASE (usually 2,10 or 16)
000143  000347  //     : | | | | digit count |
000144  000348  //     : | | | | |___reserved (not used on GOLDELOX)
000145  000349  //     : | | | |
000146  000350  //     : | | | |
000147  000351  //     : | | | |
000148  000352  //     : | | | |
000149  000353  //     : | | | |
000150  000354  //     : | | | |______ 1 = leading zeros included
000151  000355  //     : | | | 0 = leading zeros suppressed
000152  000356  //     : | | |
000153  000357  //     : | | |
000154  000358  //     : | | |_______ 1 = leading zero blanking
000155  000359  //     : | |
000156  000360  //     : | |_____ sign bit (0 = signed, 1 = unsigned)
000157  000361  //     : |
000158  000362  //     : |______ 1 = space before unsigned number
000159  000363        
000160  000364        
000161  000365  func translate("arg1","arg2","arg3","arg4"), 1; // list translator (internal use only, not usable)
000162  000366        
000163  000367  func putstr("string"), 1;                       // print string to current output device
000164  000368  // Syntax: putstr(pointer);
000165  000369  // Usage : putstr("HELLO\n");
000166  000370  // Notes : putstr prints a string to the current output stream, usually the display. The argument can be
000167  000371  //       : a string constant, a word aligned pointer to a string, a pointer to an array, or a pointer to
000168  000372  //       : a data statement. Note that string constants and data statement pointers are byte aligned.
000169  000373  //       : The output of putstr can be redirected to the communications port, the media, or memory
000170  000374  //       : using the to(...); function.
000171  000375  //       : A string constant is automatically terminated with a zero.
000172  000376  //       : A string in a data statement is not automatically terminated with a zero.
000173  000377  //       : All variables in 4DGL are 16bit, if an array is used for holding 8 bit characters, each array
000174  000378  //       : element packs 1 or 2 characters.
000175  000379        
000176  000380        
000177  000381  func strlen("varAddress"), 1;                   // return length of a var packed string in character units
000178  000382  // Syntax: strlen("varAddress);
000179  000383  // Usage : strlen("HELLO\n");
000180  000384  // Notes : gives the length of a string that is packed into regular var array
000181  000385  //       : Use str_Length(ptr)  for string pointer mode
000182  000386        
000183  000387        
000184  000388  //==============================================//
000185  000389  // Memory Access Function Prototypes            //
000186  000390  //==============================================//
000187  000391                                                  //
000188  000392  func peekW("address"), 1;                       // read a word from system memory
000189  000393  func pokeW("address", "wordvalue"), 0;          // write a word to system memory
000190  000394  // refer to address map of internal variables   //
000191  000395  //==============================================//
000192  000396  // Math Functions                               //
000193  000397  //==============================================//
000194  000398                                                  //
000195  000399  func ABS("value"), 1;                           // return a positive number
000196  000400  // Syntax: ABS(value);
000197  000401  // Usage : var := ABS(arg);
000198  000402  // Notes : Returns the absolute value of an argument
000199  000403        
000200  000404  func MIN("value1", "value2"), 1;                // return the smaller of 2 numbers
000201  000405  // Syntax: MIN(value1, value2);
000202  000406  // Usage : var := MIN(arg1, arg2);
000203  000407  // Notes : Returns the minimum of 2 arguments
000204  000408        
000205  000409  func MAX("value1", "value2"), 1;                // return the larger of 2 numbers
000206  000410  // Syntax: MAX(value1, value2);
000207  000411  // Usage : var := MAX(arg1, arg2);
000208  000412  // Notes : Returns the maximum of 2 arguments
000209  000413        
000210  000414  func SWAP("&var", "&var"), 0;                   // swap 2 variables, arguments must point to variables
000211  000415  // Syntax: SWAP(&var1, &var2);
000212  000416  // Usage : SWAP(&var1, &var2);
000213  000417  // Notes : Swaps the contents of 2 variables or memory locations
000214  000418        
000215  000419  func SIN("angle"), 1;                           // return SIN of angle
000216  000420  // Syntax: SIN(angle);
000217  000421  // Usage : var := SIN(arg);
000218  000422  // Notes : Returns the sine in radians of an argument in degrees
000219  000423  //       : the returned value range is from 127 to -127. The real
000220  000424  //       : cosine values vary from 1.0 to -1.0 so appropriate
000221  000425  //       : scaling must be done in user code.
000222  000426        
000223  000427  func COS("angle"), 1;                           // return COS of angle
000224  000428  // Syntax: COS(angle);
000225  000429  // Usage : var := COS(arg);
000226  000430  // Notes : Returns the cosine in radians of an argument in degrees
000227  000431  //       : the returned value range is from 127 to -127. The real
000228  000432  //       : cosine values vary from 1.0 to -1.0 so appropriate
000229  000433  //       : scaling must be done in user code.
000230  000434        
000231  000435  func RAND(), 1;                                 // return a pseudo random number
000232  000436  // Syntax: RAND();
000233  000437  // Usage : var := RAND();
000234  000438  // Notes : Returns a random number between 0 and 0xFFFF.
000235  000439  //       : The random number generator must first be seeded
000236  000440  //       : by using the SEED(number) function.
000237  000441        
000238  000442  func SEED("number"), 0;                         // re-seed the pseudo random number generator
000239  000443  // Syntax: SEED(number);
000240  000444  // Usage : SEED(arg);
000241  000445  // Notes : Seeds the random number generator.
000242  000446        
000243  000447  func OVF(), 1;                                  // returns upper 16bits of 32bit results
000244  000448  // Syntax: OVF();
000245  000449  // Usage : loWord := 0x2710 * 0x2710;           // (10000 * 10000 in hex format)
000246  000450  //       : hiWord := OVF();
000247  000451  // Notes : This function returns the high order 16 bits from certain math and shift functions..
000248  000452        
000249  000453  func SQRT("number"), 1;                         // return square root of a number
000250  000454  // Syntax: SQRT(number);
000251  000455  // Usage : SQRT(arg);
000252  000456  // Notes : Returns the integer square root of a number.
000253  000457  //------------------------------------------------------------------//
000254  000458  //          Text Related Function Prototypes
000255  000459  //------------------------------------------------------------------//
000256  000460        
000257  000461  func txt_MoveCursor("line", "column"), 0;
000258  000462  // Syntax: txt_SetCursor(line, column);
000259  000463  // Usage : txt_SetCursor(arg1, arg2);
000260  000464  // Notes : Moves the text Cursor to a new screen position set by
000261  000465  //       : line,column parameters.
000262  000466        
000263  000467  func txt_Set("mode", "value"), 0;
000264  000468  // Syntax: txt_Set(mode, value);
000265  000469  // Usage : txt_Set(arg1, arg2);
000266  000470  // Returns : Original value before the change
000267  000471  // Notes : Sets various text related parameters used by other functions
000268  000472  //       : This allows the features to be set programatically with a
000269  000473  //       : single function call.It is strongly recommended to use the
000270  000474  //       : pre-defined constants rather than the mode numbers.
000271  000475  //       : NB:- Although it is often required to be able to set text
000272  000476  //       : functions with a single function call for graphics engine
000273  000477  //       : related functions, there is a complete set of single parameter
000274  000478  //       : shortcut functions that have exactly the same function as
000275  000479  //       : each of the txt_Set modes and saves 1 parameter / uses less memory
000276  000480  //       :
000277  000481  //       : mode = TEXT_COLOUR (mode 0)
000278  000482  //       : txt_Set(TEXT_COLOUR, value);
000279  000483  //       : value = 0 to 0xFFFF, Black to White
000280  000484  //       : Sets the Text colour for the display
000281  000485  //       : Default = LIME.
000282  000486  //       :
000283  000487  //       : mode = TEXT_HIGHLIGHT (mode 1)
000284  000488  //       : txt_Set(TEXT_HIGHLIGHT, value);
000285  000489  //       : value = 0 to 0xFFFF, Black to White
000286  000490  //       : Sets the Text background colour for the display. Effective
000287  000491  //       : when text mode is Opaque.
000288  000492  //       : Default = BLACK.
000289  000493  //       :
000290  000494  //       : mode = FONT_ID (mode 2)
000291  000495  //       : txt_Set(FONT_ID, value);
000292  000496  //       : value = FONT1, FONT2 or FONT3 for internal fonts
000293  000497  //       : else this value is the name of a font included
000294  000498  //       : in a users program in a data statement.
000295  000499  //       : Default = FONT SIZE 3.
000296  000500  //       :
000297  000501  //       : mode = TEXT_WIDTH  (mode 3)
000298  000502  //       : txt_Set(TEXT_WIDTH, value);
000299  000503  //       : value = 1 to 16
000300  000504  //       : Sets the Text Width multiplier
000301  000505  //       : text will be printed magnified horizontally
000302  000506  //       : by this factor, Default = 1.
000303  000507  //       :
000304  000508  //       : mode = TEXT_HEIGHT  (mode 4)
000305  000509  //       : txt_Set(TEXT_HEIGHT, value);
000306  000510  //       : value = 1 to 16
000307  000511  //       : Sets the Text Height multiplier
000308  000512  //       : text will be printed magnified vertically
000309  000513  //       : by this factor, Default = 1.
000310  000514  //       :
000311  000515  //       : mode = TEXT_XGAP  (mode 5)
000312  000516  //       : txt_Set(TEXT_XGAP, value);
000313  000517  //       : value = 1 to 32
000314  000518  //       : Sets the horizontal gap between characters
000315  000519  //       : The gap is in pixel units, Default = 0
000316  000520  //       :
000317  000521  //       : mode = TEXT_YGAP  (mode 6)
000318  000522  //       : txt_Set(TEXT_YGAP, value);
000319  000523  //       : value = 1 to 32
000320  000524  //       : Sets the vertical gap below characters
000321  000525  //       : The gap is in pixel units, Default = 0
000322  000526  //       :
000323  000527  //       : mode = TEXT_PRINTDELAY  (mode 7) DEPRECATED
000324  000528  //       : txt_Set(TEXT_PRINTDELAY, value);
000325  000529  //       : value = 0 to 255
000326  000530  //       : Sets the delay time (in ms) during character
000327  000531  //       : printing to give a 'teletype' like effect.
000328  000532  //       : Often used to attract attention to a string
000329  000533  //       : being printed which can often be missed if
000330  000534  //       : just suddenly appearing or changing.
000331  000535  //       : Default = 0 ms.
000332  000536  //       :
000333  000537  //       : mode = TEXT_OPACITY (mode 8)
000334  000538  //       : txt_Set(TEXT_OPACITY, value);
000335  000539  //       : value = TRANSPARENT (0) = Text Trasparent
000336  000540  //       : value = OPAQUE (1) = Text Opaque
000337  000541  //       : Sets the Opacity/Transparency of the text
000338  000542  //       : Default = 0 or TRANSPARENT
000339  000543  //       :
000340  000544  //       : mode = TEXT_BOLD (mode 9)
000341  000545  //       : txt_Set(TEXT_BOLD, value);
000342  000546  //       : value = dont care
000343  000547  //       : Sets Bold Text mode for the next string or char
000344  000548  //       : The feature automatically resets after printing
000345  000549  //       : using putstr or print has completed
000346  000550  //       :
000347  000551  //       : mode = TEXT_ITALIC (mode 10)
000348  000552  //       : txt_Set(TEXT_ITALIC, value);
000349  000553  //       : value = dont care
000350  000554  //       : Sets Italic Text mode for the next string or char
000351  000555  //       : The feature automatically resets after printing
000352  000556  //       : using putstr or print has completed
000353  000557        
000354  000558  //       : mode = TEXT_INVERSE (mode 11)
000355  000559  //       : txt_Set(TEXT_INVERSE, value);
000356  000560  //       : value = dont care
000357  000561  //       : Sets Inverse Text mode for the next string or char
000358  000562  //       : The feature automatically resets after printing
000359  000563  //       : using putstr or print has completed
000360  000564  //       :
000361  000565  //       : mode = TEXT_UNDERLINED (mode 12)
000362  000566  //       : txt_Set(TEXT_UNDERLINED, value);
000363  000567  //       : value = dont care
000364  000568  //       : Sets Underlined Text mode for the next string or char
000365  000569  //       : The feature automatically resets after printing
000366  000570  //       : using putstr or print has completed
000367  000571  //       :
000368  000572  //       : mode = TEXT_ATTRIBUTES (mode 13)
000369  000573  //       : txt_Set(TEXT_ATTRIBUTES, value);
000370  000574  //       : value = bits are defined as:
000371  000575  //       :  BOLD        16          // TEXT_ATTRIBUTES bold text (auto reset)
000372  000576  //       :  ITALIC      32          // TEXT_ATTRIBUTES italic text (auto reset)
000373  000577  //       :  INVERSE     64          // TEXT_ATTRIBUTES inverse text (auto reset)
000374  000578  //       :  UNDERLINED  128         // TEXT_ATTRIBUTES underlined text (auto reset)
000375  000579  //       : Allows a combination of text attributes to be defined together
000376  000580  //       : by 'or'ing the bits together.
000377  000581  //       : Example: txt_Set(TEXT_ATTRIBUTES, BOLD | INVERSE); // bold + inverse
000378  000582  //       : The feature automatically resets after printing
000379  000583  //       : using putstr or print has completed.
000380  000584  //       : Bits 0-3 and 8-15 are reserved for future attributes.
000381  000585  //       :
000382  000586  //       : mode = TEXT_WRAP (mode 14)
000383  000587  //       : txt_Set(TEXT_WRAP , value);
000384  000588  //       : Sets the position where text wrap will occur
000385  000589  //       : The feature automatically resets when screen
000386  000590  //       : mode is changed. If the value is set to 0,
000387  000591  //       : text wrap is turned off.
000388  000592  //       : of the current screen. Default value is 0
000389  000593  // Notes : The value is in pixel units.
000390  000594  //       :
000391  000595        
000392  000596  //       : txt_Set mode 15 reserved for future use
000393  000597  //       :
000394  000598        
000395  000599        
000396  000600        
000397  000601  //=====================================================//
000398  000602  // Single parameter short-cuts                         //
000399  000603  // for the txt_Set functions                           //
000400  000604  // These functions return the existing value before    //
000401  000605  // the change is made.                                 //
000402  000606  //=====================================================//
000403  000607  func txt_FGcolour("colour"), 1;             // 0  text foreground colour
000404  000608  func txt_BGcolour("colour"), 1;             // 1  text background colour
000405  000609  func txt_FontID("id"), 1;                   // 2  text font ID (0 = system font)
000406  000610  func txt_Width("multiplier"), 1;            // 3  text width multiplier
000407  000611  func txt_Height("multiplier"), 1;           // 4  text height multiplier
000408  000612  func txt_Xgap("pixelcount"), 1;             // 5  text gap between characters
000409  000613  func txt_Ygap("pixelcount"), 1;             // 6  text gap between lines
000410  000614  func txt_Delay("millisecs"), 1;             // 7  text printing delay factor
000411  000615  func txt_Opacity("mode"), 1;                // 8  text OPAQUE or TRANSPARENT
000412  000616  func txt_Bold("mode"), 1;                   // 9  text bold ON/OFF
000413  000617  func txt_Italic("mode"), 1;                 // 10 text italic ON/OFF
000414  000618  func txt_Inverse("mode"), 1;                // 11 text inverse ON/OFF
000415  000619  func txt_Underline("mode"), 1;              // 12 text underline ON/OFF
000416  000620  func txt_Attributes("value"), 1;            // 13 text combined bold|italic|inverse|underline
000417  000621  func txt_Wrap("value"), 1;                  // 14 text set text wrap position
000418  000622  func _1F(), 0;                              // 15 text (reserved DO NOT REMOVE)
000419  000623        
000420  000624        
000421  000625  //------------------------------------------------------------------//
000422  000626  //                 Hardware Function Prototypes
000423  000627  //------------------------------------------------------------------//
000424  000628        
000425  000629  // I/O Pin reference:-
000426  000630  //
000427  000631  //    IO1_PIN           is pin 2 of J1
000428  000632  //    IO2_PIN           is pin 1 of J1
000429  000633  //    IO3_PIN           is pin 3 of J1
000430  000634  //    IO4_PIN           is pin 5 of J1 (also used for BUS_RD)
000431  000635  //    IO5_PIN           is pin 9 of J2 (also used for BUS_WR)
000432  000636  //    BUS_RD_PIN        is pin 5 of J1 (alias IO4_PIN)
000433  000637  //    BUS_WR_PIN        is pin 9 of J2 (alias IO5_PIN)
000434  000638  //    BUS_0             is pin 27 of J1
000435  000639  //    BUS_1             is pin 25 of J1
000436  000640  //    BUS_2             is pin 23 of J1
000437  000641  //    BUS_3             is pin 21 of J1
000438  000642  //    BUS_4             is pin 19 of J1
000439  000643  //    BUS_5             is pin 17 of J1
000440  000644  //    BUS_6             is pin 13 of J2
000441  000645  //    BUS_7             is pin 11 of J2
000442  000646  //    BACKLITE          is backlite control pin
000443  000647  //    AUDIO_ENABLE      is amplifier chip control pin
000444  000648        
000445  000649  func pin_Set("mode", "pin"), 1;            // set pin to required mode
000446  000650  // Syntax: pin_Set(mode, pin);
000447  000651  // Usage : pin_Set(arg1, arg2);
000448  000652  // Notes : Sets the appropriate pins to Inputs or Outputs
000449  000653  //       : returns true if the pin number is legal (usually ignored)
000450  000654  //       :
000451  000655  //       : mode = 0 : Set Pin to Output
000452  000656  //       : pin_Set(0, pin);
000453  000657  //       : pin_Set(OUTPUT, pin);
000454  000658  //       : pin = 1  : set IO1_PIN to output (pin 2 J1)
000455  000659  //       : pin = 2  : set IO2_PIN to output (pin 1 J1)
000456  000660  //       : pin = 3  : set IO3_PIN to output (pin 3 J1)
000457  000661  //       : pin = 4  : set IO4_PIN to output (pin 5 J1, also used for BUS_RD)
000458  000662  //       : pin = 5  : set IO5_PIN to output (pin 9 J2, also used for BUS_WR)
000459  000663  //       : (pin 6,7 are BACKLITE and AMP control and are permanemtly outputs which can't be altered)
000460  000664  //       : pin = 8  : set BUS_0   to output (pin 27 of J1)
000461  000665  //       : pin = 9  : set BUS_1   to output (pin 25 of J1)
000462  000666  //       : pin = 10 : set BUS_2   to output (pin 23 of J1)
000463  000667  //       : pin = 11 : set BUS_3   to output (pin 21 of J1)
000464  000668  //       : pin = 12 : set BUS_4   to output (pin 19 of J1)
000465  000669  //       : pin = 13 : set BUS_5   to output (pin 17 of J1)
000466  000670  //       : pin = 14 : set BUS_6   to output (pin 13 of J2)
000467  000671  //       : pin = 15 : set BUS_7   to output (pin 11 of J2)
000468  000672  //       : Sets the desired pin to be used as an Output.
000469  000673  //       :
000470  000674  //       : mode = 1 : Set Pin to Input
000471  000675  //       : pin_Set(1, pin);
000472  000676  //       : pin_Set(INPUT, pin);
000473  000677  //       : pin = 1  : set IO1_PIN to input (pin 2 J1)
000474  000678  //       : pin = 2  : set IO2_PIN to input (pin 1 J1)
000475  000679  //       : pin = 3  : set IO3_PIN to input (pin 3 J1)
000476  000680  //       : pin = 4  : set IO4_PIN to input (pin 5 J1, also used for BUS_RD)
000477  000681  //       : pin = 5  : set IO5_PIN to input (pin 9 J2, also used for BUS_WR)
000478  000682  //       : (pin 6,7 are BACKLITE and AMP control and are permanemtly outputs which can't be altered)
000479  000683  //       : pin = 8  : set BUS_0   to input (pin 27 of J1)
000480  000684  //       : pin = 9  : set BUS_1   to input (pin 25 of J1)
000481  000685  //       : pin = 10 : set BUS_2   to input (pin 23 of J1)
000482  000686  //       : pin = 11 : set BUS_3   to input (pin 21 of J1)
000483  000687  //       : pin = 12 : set BUS_4   to input (pin 19 of J1)
000484  000688  //       : pin = 13 : set BUS_5   to input (pin 17 of J1)
000485  000689  //       : pin = 14 : set BUS_6   to input (pin 13 of J2)
000486  000690  //       : pin = 15 : set BUS_7   to input (pin 11 of J2)
000487  000691  //       : Sets the desired pin to be used as an Input.
000488  000692        
000489  000693  func pin_HI("pin"), 1;                    // set pin to logic '1'
000490  000694  // Syntax: pin_HI(pin);
000491  000695  // Usage : pin_HI(arg);
000492  000696  // Notes : Outputs a logic "High" (3.3V) on the appropriate
000493  000697  //       : pin that was previously selected as an Output.
000494  000698  //       : returns true if the pin number is legal (usually ignored)
000495  000699  //       :
000496  000700  //       : pin = 1  : set IO1_PIN to "High" level (pin 2 of J1)
000497  000701  //       : pin = 2  : set IO2_PIN to "High" level (pin 1 of J1)
000498  000702  //       : pin = 3  : set IO3_PIN to "High" level (pin 3 of J1)
000499  000703  //       : pin = 4  : set IO4_PIN to "High" level (pin 5 of J1, also used for BUS_RD)
000500  000704  //       : pin = 5  : set IO5_PIN to "High" level (pin 9 of J2, also used for BUS_WR)
000501  000705  //       : pin = 6  : set DCENB pin to "High" level (BACKLITE ON)
000502  000706  //       : pin = 7  : set AUDIO_ENABL pin to "High" level (AMP OFF)
000503  000707  //       : pin = 8  : set BUS_0   to "High" level (pin 27 of J1)
000504  000708  //       : pin = 9  : set BUS_1   to "High" level (pin 25 of J1)
000505  000709  //       : pin = 10 : set BUS_2   to "High" level (pin 23 of J1)
000506  000710  //       : pin = 11 : set BUS_3   to "High" level (pin 21 of J1)
000507  000711  //       : pin = 12 : set BUS_4   to "High" level (pin 19 of J1)
000508  000712  //       : pin = 13 : set BUS_5   to "High" level (pin 17 of J1)
000509  000713  //       : pin = 14 : set BUS_6   to "High" level (pin 13 of J2)
000510  000714  //       : pin = 15 : set BUS_7   to "High" level (pin 11 of J2)
000511  000715        
000512  000716  func pin_LO("pin"), 1;                    // set pin to logic '0'
000513  000717  // Syntax: pin_LO(pin);
000514  000718  // Usage : pin_LO(arg);
000515  000719  // Notes : Outputs a logic "Low" (0V) on the appropriate
000516  000720  //       : pin that was previously selected as an Output.
000517  000721  //       : returns true if the pin number is legal (usually ignored)
000518  000722  //       :
000519  000723  //       : pin = 1 : set IO1_PIN to "Low" level (pin 2 of J1)
000520  000724  //       : pin = 2 : set IO2_PIN to "Low" level (pin 1 of J1)
000521  000725  //       : pin = 3 : set IO3_PIN to "Low" level (pin 3 of J1)
000522  000726  //       : pin = 4 : set IO4_PIN to "Low" level (pin 5 of J1, also used for BUS_RD)
000523  000727  //       : pin = 5 : set IO5_PIN to "Low" level (pin 9 of J2, also used for BUS_WR)
000524  000728  //       : pin = 6 : set DCENB pin to "Low" level (BACKLITE)
000525  000729  //       : pin = 7 : set AUDIO_ENABL pin to "Low" level (AMP ON)
000526  000730  //       : pin = 8  : set BUS_0  to "Low" level (pin 27 of J1)
000527  000731  //       : pin = 9  : set BUS_1  to "Low" level (pin 25 of J1)
000528  000732  //       : pin = 10 : set BUS_2  to "Low" level (pin 23 of J1)
000529  000733  //       : pin = 11 : set BUS_3  to "Low" level (pin 21 of J1)
000530  000734  //       : pin = 12 : set BUS_4  to "Low" level (pin 19 of J1)
000531  000735  //       : pin = 13 : set BUS_5  to "Low" level (pin 17 of J1)
000532  000736  //       : pin = 14 : set BUS_6  to "Low" level (pin 13 of J2)
000533  000737  //       : pin = 15 : set BUS_7  to "Low" level (pin 11 of J2)
000534  000738        
000535  000739  func pin_Read("pin"), 1;                // read pin, logic or analogue
000536  000740  // Syntax: pin_Read(pin);
000537  000741  // Usage : arg1 := pin_Read(arg2);
000538  000742  // Notes : Reads the logic state of the appropriate
000539  000743  //       : pin that was previously selected as an Input.
000540  000744  //       :
000541  000745  //       : pin = 1  : Read the state of IO1_PIN (pin 2 of J1)
000542  000746  //       : pin = 2  : Read the state of IO2_PIN (pin 1 of J1)
000543  000747  //       : pin = 3  : Read the state of IO3_PIN (pin 3 of J1)
000544  000748  //       : pin = 4  : Read the state of IO4_PIN (pin 5 of J1, also used for BUS_RD)
000545  000749  //       : pin = 5  : Read the state of IO5_PIN (pin 9 of J2, also used for BUS_WR)
000546  000750  //       : pin = 6  : Read the state of DCENB pin to "Low" level (BACKLITE)
000547  000751  //       : pin = 7  : Read the state of AUDIO_ENABL pin to "Low" level (AMP ON)
000548  000752  //       : pin = 8  : Read the state of BUS_0   (pin 27 of J1)
000549  000753  //       : pin = 9  : Read the state of BUS_1   (pin 25 of J1)
000550  000754  //       : pin = 10 : Read the state of BUS_2   (pin 23 of J1)
000551  000755  //       : pin = 11 : Read the state of BUS_3   (pin 21 of J1)
000552  000756  //       : pin = 12 : Read the state of BUS_4   (pin 19 of J1)
000553  000757  //       : pin = 13 : Read the state of BUS_5   (pin 17 of J1)
000554  000758  //       : pin = 14 : Read the state of BUS_6   (pin 13 of J2)
000555  000759  //       : pin = 15 : Read the state of BUS_7   (pin 11 of J2)
000556  000760  //       : Returns a 0 (logic low) or 1 (logic high).
000557  000761        
000558  000762        
000559  000763  //------------------------------------------------------------------//
000560  000764  //                 P1 module BUS I/O control
000561  000765  //------------------------------------------------------------------//
000562  000766        
000563  000767  func bus_In(), 1;
000564  000768  // Syntax: bus_In();
000565  000769  // Usage : arg1 := bus_In();
000566  000770  // Notes : Read the 8bit wide bus into the lower 8 bits of arg1.
000567  000771  //       : The upper 8 bits of arg1 are set to 0.
000568  000772  //       : the BUS_RD and BUS_WR pins are not affected.
000569  000773  //       :
000570  000774  //       : BUS_0 is pin 27 of J1
000571  000775  //       : BUS_1 is pin 25 of J1
000572  000776  //       : BUS_2 is pin 23 of J1
000573  000777  //       : BUS_3 is pin 21 of J1
000574  000778  //       : BUS_4 is pin 19 of J1
000575  000779  //       : BUS_5 is pin 17 of J1
000576  000780  //       : BUS_6 is pin 13 of J2
000577  000781  //       : BUS_7 is pin 11 of J2
000578  000782        
000579  000783  func bus_Out("var"), 0;
000580  000784  // Syntax: bus_Out(var);
000581  000785  // Usage : bus_Out(arg1);
000582  000786  // Notes : The lower 8 bits of arg1 are placed on the 8bit wide bus.
000583  000787  //       : The upper 8 bits of arg1 are ignored.
000584  000788  //       : the BUS_RD and BUS_WR pins are not affected.
000585  000789  //       : NB:- any BUS pins that are set to inputs are not affected.
000586  000790  //       :
000587  000791  //       : BUS_0 is pin 27 of J1
000588  000792  //       : BUS_1 is pin 25 of J1
000589  000793  //       : BUS_2 is pin 23 of J1
000590  000794  //       : BUS_3 is pin 21 of J1
000591  000795  //       : BUS_4 is pin 19 of J1
000592  000796  //       : BUS_5 is pin 17 of J1
000593  000797  //       : BUS_6 is pin 13 of J2
000594  000798  //       : BUS_7 is pin 11 of J2
000595  000799        
000596  000800  func bus_Set("var"), 0;
000597  000801  // Syntax: bus_Set(var);
000598  000802  // Usage : bus_Set(arg1);
000599  000803  // Notes : The lower 8 bits of arg1 are placed in the BUS direction register.
000600  000804  //       : a '1' sets a pin to be an input, a '0' sets a pin to be output.
000601  000805  //       : The upper 8 bits of arg1 are ignored.
000602  000806  //       : the BUS_RD and BUS_WR pins are not affected.
000603  000807  //       :
000604  000808  //       : BUS_0 is pin 27 of J1
000605  000809  //       : BUS_1 is pin 25 of J1
000606  000810  //       : BUS_2 is pin 23 of J1
000607  000811  //       : BUS_3 is pin 21 of J1
000608  000812  //       : BUS_4 is pin 19 of J1
000609  000813  //       : BUS_5 is pin 17 of J1
000610  000814  //       : BUS_6 is pin 13 of J2
000611  000815  //       : BUS_7 is pin 11 of J2
000612  000816        
000613  000817  func bus_Write("var"), 0;
000614  000818  // Syntax: bus_Write(var);
000615  000819  // Usage : bus_Write(arg1);
000616  000820  // Notes : The lower 8 bits of arg1 are placed on the BUS, then, after
000617  000821  //       : a settling delay of approx 50nsec, the BUS_WR pin is strobed
000618  000822  //       : LO for approx 50nsec then set back HI.
000619  000823  //       : The upper 8 bits of arg1 are ignored.
000620  000824  //       : NB:- the BUS_WR pin is automatically pre-set to an output to
000621  000825  //       : ensure BUS write integrity.
000622  000826  //       :
000623  000827  //       : BUS_0 is pin 27 of J1
000624  000828  //       : BUS_1 is pin 25 of J1
000625  000829  //       : BUS_2 is pin 23 of J1
000626  000830  //       : BUS_3 is pin 21 of J1
000627  000831  //       : BUS_4 is pin 19 of J1
000628  000832  //       : BUS_5 is pin 17 of J1
000629  000833  //       : BUS_6 is pin 13 of J2
000630  000834  //       : BUS_7 is pin 11 of J2
000631  000835        
000632  000836  func bus_Read(), 1;
000633  000837  // Syntax: bus_Read();
000634  000838  // Usage : arg1 := bus_Read();
000635  000839  // Notes : The BUS_RD pin set to LO, then, after a settling delay
000636  000840  //       : of approx 50nsec, the BUS is read into the lower 8 bits of arg
000637  000841  //       : (the upper 8 bits being set to 0)
000638  000842  //       : the BUS_RD pin is then set back to a HI level.
000639  000843  //       : NB:- the BUS_RD pin is automatically pre-set to an output to
000640  000844  //       : ensure BUS write integrity.
000641  000845  //       :
000642  000846  //       : BUS_0 is pin 27 of J1
000643  000847  //       : BUS_1 is pin 25 of J1
000644  000848  //       : BUS_2 is pin 23 of J1
000645  000849  //       : BUS_3 is pin 21 of J1
000646  000850  //       : BUS_4 is pin 19 of J1
000647  000851  //       : BUS_5 is pin 17 of J1
000648  000852  //       : BUS_6 is pin 13 of J2
000649  000853  //       : BUS_7 is pin 11 of J2
000650  000854        
000651  000855        
000652  000856  //------------------------------------------------------------------//
000653  000857  //   Graphics Functions
000654  000858  //------------------------------------------------------------------//
000655  000859  func gfx_Set("mode", "value"), 0;            // set various graphics functions
000656  000860  // Syntax: gfx_Set(mode, value);
000657  000861  // Usage : gfx_Set(arg1, arg2);
000658  000862  // Notes : Sets various graphics parameters used by other functions
000659  000863  //       : This allows the features to be set programatically with a
000660  000864  //       : single function call.It is strongly recommended to use the
000661  000865  //       : pre-defined constants rather than the mode numbers.
000662  000866  //       : NB:- Although it is often required to be able to set graphics
000663  000867  //       : functions with a single function call for graphics engine
000664  000868  //       : related functions, there is a complete set of single parameter
000665  000869  //       : shortcut functions that have exactly the same function as
000666  000870  //       : each of the gfx_Set modes and saves 1 parameter / uses less memory
000667  000871  //       :
000668  000872  //       : mode = PEN_SIZE (mode 16)
000669  000873  //       : gfx_Set(PEN_SIZE, value);
000670  000874  //       : value = SOLID (value 0) rectangle and circle objects are solid
000671  000875  //       : value = OUTLINE (value 1) rectangle and circle objects are outlines
000672  000876  //       : Sets the mode of the Pen used by most graphics objects
000673  000877  //       :
000674  000878  //       : mode = BACKGROUND_COLOUR (mode 17)
000675  000879  //       : gfx_Set(BACKGROUND_COLOUR, value);
000676  000880  //       : value = 0 to 0xFFFF, Black to White
000677  000881  //       : Sets the Background colour of the screen
000678  000882  //       :
000679  000883  //       : mode = OBJECT_COLOUR (mode 18)
000680  000884  //       : gfx_Set(OBJECT_COLOUR, value);
000681  000885  //       : value = 0 to 0xFFFF, Black to White
000682  000886  //       : Sets the Object colour used in various functions
000683  000887  //       : LineTo(,,); LineRel(,,); BoxTo(,,); Dot(); etc.
000684  000888  //       :
000685  000889  //       : mode = CLIPPING (mode 19)
000686  000890  //       : gfx_Set(CLIPPING, value);
000687  000891  //       : value = OFF (value 0) Clipping disabled
000688  000892  //       : value = ON (value 1) Clipping enabled
000689  000893  //       : Enables/Disables the Clipping feature
000690  000894  //       :
000691  000895  //       : mode = TRANSPARENT_COLOUR (mode 20) : Image or Animation Transparency Colour.
000692  000896  //       : gfx_Set(TRANSPARENT_COLOUR, value);
000693  000897  //       : value = 0 to 0xFFFF Black to White
000694  000898  //       : Sets Bitmap, Image or Animation Transparency Colour.
000695  000899  //       : NB not implemented
000696  000900  //       :
000697  000901  //       : mode = TRANSPARENCY (mode 21) : Bitmap/Image/Animation Transparency
000698  000902  //       : gfx_Set(5, value);
000699  000903  //       : value = OFF (value 0) Transparency disabled
000700  000904  //       : value = ON (value 1) Transparency enabled
000701  000905  //       : Enables/Disables the Transparency feature
000702  000906  //       : NB not implemented
000703  000907  //       :
000704  000908  //       : mode = FRAME_DELAY (mode 22) : Inter-Frame Delay
000705  000909  //       : gfx_Set(FRAME_DELAY, value);
000706  000910  //       : value = 0 to 65535 ms
000707  000911  //       : Sets the Video/Animation clip inter-frame delay. This setting will
000708  000912  //       : over-ride the embedded frame delay of the clip. After the event,
000709  000913  //       : the setting will auto disable and if further inter-frame delays need
000710  000914  //       : overriding the setting must be re-issued.
000711  000915  //       :
000712  000916  //       : mode = SCREEN_MODE (mode 23) : Set required screen behaviour
000713  000917  //       : gfx_Set(SCREEN_MODE, value);
000714  000918  //       : value = LANDSCAPE   (value 0)
000715  000919  //       : value = LANDSCAPE_R (value 1)
000716  000920  //       : value = PORTRAIT    (value 2)
000717  000921  //       : value = PORTRAIT_R  (value 3)
000718  000922  //       :
000719  000923  //       : mode = OUTLINE_COLOUR (mode 24) : Outline Colour
000720  000924  //       : gfx_Set(OUTLINE_COLOUR, value);
000721  000925  //       : value = 1 to 0xFFFF, if 0, featre is OFF
000722  000926  //       : Sets the filled Rectangle or Circle objects outline colour
000723  000927  //       : If outline colour, is 0, OUTLINE_COLOUR feature is disabled
000724  000928  //       : gfx_Set(OUTLINE_COLOUR, OFF); may be used for this
000725  000929  //       :
000726  000930  //       : Only supports variable contrast for uOLED Modules
000727  000931  //       : mode = CONTRAST (mode 25) : Contrast
000728  000932  //       : gfx_Set(CONTRAST, value);
000729  000933  //       : value = 0 to 9, 0=off, 1=lowest, 8=highest contrast
000730  000934  //       : when contrast=0, display is placed in low power mode.
000731  000935  //       : This function should be called with contrast=0 when
000732  000936  //       : powering down the module.
000733  000937  //       :
000734  000938  //       : mode = LINE_PATTERN (mode 26) : Line Pattern
000735  000939  //       : gfx_Set(LINE_PATTERN, value);
000736  000940  //       : gfx_Set(LINE_PATTERN, 0b1111000011110000); // draw dotted line
000737  000941  //       : gfx_Set(LINE_PATTERN, OFF); // line patterning OFF
000738  000942  //       : a value of 0 turns the feature off
000739  000943  //       :
000740  000944  //       : mode = COLOUR_MODE (mode 27) : 8/16 bit colour mode
000741  000945  //       : gfx_Set(COLOUR_MODE , COLOUR16);   // set 16bit colour mode
000742  000946  //       : gfx_Set(COLOUR_MODE , COLOUR8);   // set 8bit colour mode
000743  000947  //       : NB not implemented, default is COLOUR16
000744  000948  //       :
000745  000949  //       : mode = BEVEL_WIDTH (mode 28) : set button and slider bevel width
000746  000950  //       : gfx_Set(BEVEL_WIDTH , 5);   // set bevel lines to 5 pixels wide
000747  000951  //       : sets the button and slider objects bevel width
000748  000952  //       :
000749  000953  //       : mode = BEVEL_SHADOW (mode 29) : set bevel shadowing depth for buttons and sliders
000750  000954  //       : gfx_Set(BEVEL_SHADOW , 5);
000751  000955  //       : sets the button and slider objects darken and lighten depth for the bevel colour
000752  000956  //       :
000753  000957  //       : mode = X_ORIGIN (mode 29) : set x offset for screen
000754  000958  //       : gfx_Set(X_ORIGIN , 25);  // object are offset 25 pixels from LHS
000755  000959  //       : sets the origin of drawn objects to a position other than 0,0
000756  000960  //       :
000757  000961  //       : mode = Y_ORIGIN (mode 29) : set y offset for screen
000758  000962  //       : gfx_Set(Y_ORIGIN , 30);  // object are offset 30 pixels from TOP
000759  000963  //       : sets the origin of drawn objects to a position other than 0,0
000760  000964        
000761  000965        
000762  000966  func gfx_Cls(), 0;                    // clear the screen
000763  000967  // Syntax: gfx_Cls();
000764  000968  // Usage : gfx_Cls();
000765  000969  // Notes : Clears the screen with current background colour
000766  000970        
000767  000971  func gfx_MoveTo("x", "y"), 0;                // set glb_X1 and glb_Y1 to required co-ordinate
000768  000972  // Syntax: gfx_MoveTo(x, y);
000769  000973  // Usage : gfx_MoveTo(arg1, arg2);
000770  000974  // Notes : Moves the origin to a new x,y position
000771  000975        
000772  000976  func gfx_MoveRel("x", "y"), 0;                // set glb_X1 and glb_Y1 to new relative offset
000773  000977  // Syntax: gfx_MoveRel(x, y);
000774  000978  // Usage : gfx_MoveRel(arg1, arg2);
000775  000979  // Notes : Moves the origin to a new x,y position
000776  000980  //       : relative to the current origing
000777  000981        
000778  000982  func gfx_LineTo("x1", "y1"), 0;                     // draw line from current origin to new point
000779  000983  // Syntax: gfx_LineTo(x1, y1);
000780  000984  // Usage : gfx_LineTo(arg1, arg2);
000781  000985  // Notes : Draws a Line from the origin x,y to x1,y1.
000782  000986  //       : The new origin is then set to x1, y1. Line colour needs
000783  000987  //       : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
000784  000988        
000785  000989  func gfx_LineRel("x1", "y1"), 0;                    // draw line from current origin to new relative offset
000786  000990  // Syntax: gfx_LineRel(x1, y1);
000787  000991  // Usage : gfx_LineRel(arg1, arg2);
000788  000992  // Notes : Draws a Line from the origin x,y to x1,y1.
000789  000993  //       : Unlike gfx_MoveTo() the origin is not updated with x1, y1. Line colour needs
000790  000994  //       : to be preset with "Set Object colour" using gfx_Set(OBJECT_COLOUR, colour);
000791  000995        
000792  000996  func gfx_Line("x1", "y1", "x2", "y2", "colr"), 0;   // draw line, can be patterned
000793  000997  // Syntax: gfx_Line(x1, x2, y2, colr);
000794  000998  // Usage : gfx_Line(arg1, arg2, arg3, arg4, arg5);
000795  000999  // Notes : Plots a coloured Line from x1,y1 to x2,y2 on the screen
000796  001000        
000797  001001  func gfx_Hline("y", "x1", "x2", "colr"), 1;         // draw Hline, can be patterned
000798  001002  // Syntax: gfx_Line(x1, x2, y, colr);
000799  001003  // Usage : gfx_Line(arg1, arg2, arg3, arg4);
000800  001004  // Notes : Plots a coloured Horizontal line from x1,y to x2,y on the screen
000801  001005        
000802  001006  func gfx_Vline("x", "y1", "y2", "colr"), 1;         // draw Vline, can be patterned
000803  001007  // Syntax: gfx_Line(y1, y2, x, colr);
000804  001008  // Usage : gfx_Line(arg1, arg2, arg3, arg4);
000805  001009  // Notes : Plots a coloured Vertical line from x,y1 to x,y2 on the screen
000806  001010        
000807  001011  func gfx_Rectangle("x1" ,"y1", "x2", "y2", "colr"), 0;    // draw open rectangle,line can be patterned
000808  001012  // Syntax: gfx_Rectangle(x1, y1, x2, y2, colr);
000809  001013  // Usage : gfx_Rectangle(arg1, arg2, arg3, arg4, arg5);
000810  001014  // Notes : Plots a coloured Outline Rectangle from top corner (x1,y1) to
000811  001015  //       : bottom corner (x2,y2) on the screen.
000812  001016        
000813  001017  func gfx_RectangleFilled("x1","y1","x2","y2","colr"), 0;    // draw filled rectangle
000814  001018  // Syntax: gfx_Rectangle(x1, y1, x2, y2, colour);
000815  001019  // Usage : gfx_Rectangle(arg1, arg2, arg3, arg4, arg5);
000816  001020  // Notes : Plots a coloured Solid Rectangle from top corner (x1,y1) to
000817  001021  //       : bottom corner (x2,y2) on the screen.
000818  001022        
000819  001023  func gfx_Circle("x", "y", "rad", "colr"), 0;        // draw open circle
000820  001024  // Syntax: gfx_Circle(x, y, rad, colr);
000821  001025  // Usage : gfx_Circle(arg1, arg2, arg3, arg4);
000822  001026  // Notes : Plots a coloured outline Circle on the screen at centre x,y with radius = rad
000823  001027        
000824  001028  func gfx_CircleFilled("x", "y", "rad", "colr"), 0;    // draw filled circle
000825  001029  // Syntax: gfx_Circle(x, y, rad, colr);
000826  001030  // Usage : gfx_Circle(arg1, arg2, arg3, arg4);
000827  001031  // Notes : Plots a coloured Solid Circle on the screen at centre x,y with radius = rad
000828  001032        
000829  001033  func gfx_PutPixel("x", "y", "colr"), 0;            // set point at x y
000830  001034  // Syntax: gfx_PutPixel(x, y, colr);
000831  001035  // Usage : gfx_PutPixel(arg1, arg2, arg3);
000832  001036  // Notes : Plots a coloured pixel on the screen at x,y location
000833  001037        
000834  001038  func gfx_GetPixel("x", "y"), 1;                // read colour at point x y
000835  001039  // Syntax: gfx_GetPixel(x, y);
000836  001040  // Usage : var := gfx_GetPixel(arg1, arg2);
000837  001041  // Notes : Reads and returns the colour value of a pixel at location x,y
000838  001042        
000839  001043  func gfx_Triangle("x1","y1","x2","y2","x3","y3","colr"), 0; // draw an open triangle
000840  001044  // Syntax: gfx_Triangle(x1, y1, x2, y2, x3, y3, colr);
000841  001045  // Usage : gfx_Triangle(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
000842  001046  // Notes : Plots a coloured outline Triangle from between 3 vertices: x1,y1 x2,y2 x3,y3
000843  001047  //       : Vertices must be specified in an anti-clockwise fashion
000844  001048        
000845  001049  func gfx_OrbitInit("&x_orb", "&y_orb"), 0;        // set result holders for orbit command
000846  001050  // Syntax: gfx_OrbitInit(&x_orb, &y_orb);
000847  001051  // Usage : gfx_OrbitInit(&arg1, &arg2);
000848  001052  // Notes : Sets up the Orbit function parameters.
000849  001053  //       : &x_orb, &y_orb: calcualted Orbit coordiantes. These are pointers to local
000850  001054  //       : variables that get updated after calling gfx_Orbit(,,) function.
000851  001055  //       : The coordiantaes are calculated relative to the origin
000852  001056  //       : obtained by using the gfx_MoveTo(x, y) function.
000853  001057        
000854  001058  func gfx_Orbit("angle", "distance"), 0;            // calculate point at angle, distance
000855  001059  // Syntax: gfx_Orbit(angle, distance);
000856  001060  // Usage : gfx_Orbit(arg1, arg2);
000857  001061  // Notes : The Orbit function calcualtes the x, y coordinates of a distant point whose
000858  001062  //       : only known parameters are the angle and the distance from the current origin.
000859  001063        
000860  001064  func gfx_Polyline("n", "&vx", "&vy", "colr"), 0;    // draw a polyline from a table of vertices
000861  001065  // Syntax: gfx_Polyline(numbVertices, &vertices_x, &vertices_y, colour);
000862  001066  // Usage : gfx_Polyline(arg1, x[array], y[array], arg2);
000863  001067  // Notes : This function is very similar to the Ploygon function
000864  001068  //       : with the exception of the 1st and the last vertices not joined.
000865  001069        
000866  001070  func gfx_Polygon("n", "&vx", "&vy", "colr"), 0;        // draw a polygon from a table of vertices
000867  001071  // Syntax: gfx_Polygon(numbVertices, &vx, &y, colour);
000868  001072  // Usage : gfx_Polygon(arg1, x[array], y[array], arg2);
000869  001073  // Notes : Plots a coloured outline Polygon between specified vertices: x1,y1 x2,y2 .. xn,yn
000870  001074  //       : Vertices must be minimum of 3 and can be specified in any fashion
000871  001075        
000872  001076  func gfx_Dot(), 0;                    // set point at glb_X glb_Y, default colour
000873  001077  // Syntax: gfx_Dot();
000874  001078  // Usage : gfx_Dot();
000875  001079  // Notes : Places a coloured dot at the origin
000876  001080        
000877  001081        
000878  001082  func gfx_Bullet("r"), 0;                // draw circle at glb_X glb_Y, default colour
000879  001083  // Syntax: gfx_Bullet();
000880  001084  // Usage : gfx_Bullet();
000881  001085  // Notes : Places a coloured circle at the origin
000882  001086  //       : filled or unfilled state is controlled by PenSize
000883  001087        
000884  001088  func gfx_IncX(), 1;                    // increment global origin glb_X, returning new value
000885  001089  // Syntax: gfx_IncX();
000886  001090  // Usage : var := gfx_IncX();
000887  001091  // Notes : Increments the x coordinate of the origin
000888  001092        
000889  001093  func gfx_IncY(), 1;                    // increment global origin glb_Y, returning new value
000890  001094  // Syntax: gfx_IncY();
000891  001095  // Usage : var := gfx_IncY();
000892  001096  // Notes : Increments the y coordinate of the origin
000893  001097        
000894  001098  func gfx_BoxTo("x1", "y1"), 0;                // draw rectangle from current origin to x1 y1
000895  001099  // Syntax: gfx_BoxTo(x1, y1);
000896  001100  // Usage : gfx_BoxTo(arg1, arg2);
000897  001101  // Notes : Draws a Rectangle from the origin x,y to x1,y1.
000898  001102  //       : The new origin is then set to x1,y1. Rectangle colour needs
000899  001103  //       : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
000900  001104  //       : and the PenSize setting determines if Box is solid or outline.
000901  001105        
000902  001106  func gfx_ClipWindow("x1" ,"y1", "x2", "y2"), 0;         // set the cipping area
000903  001107  // Syntax: gfx_ClipWindow(x1, y1, x2, y2);
000904  001108  // Usage : gfx_ClipWindow(arg1, arg2, arg3, arg4);
000905  001109  // Notes : Specifies a clipping window region on the screen such that any objects
000906  001110  //       : and text placed onto the screen will be clipped and displayed only
000907  001111  //       : within that region. For the clipping window to take effect, "Clipping"
000908  001112  //       : must be enabled seperately using the gfx_Set(CLIPPING, ON) command.
000909  001113        
000910  001114        
000911  001115  func gfx_ChangeColour("oldcolr", "newcolr"), 0;         // change pixel colour in clipping area
000912  001116  // Syntax: gfx_ChangeColour(oldcolr, newcolr);
000913  001117  // Usage : gfx_ChangeColour(0xFF00, 0XFFFF);
000914  001118  // *Notes:
000915  001119        
000916  001120  func gfx_SetClipRegion(), 0;                            // set clipping area to the most recent extents
000917  001121  // Syntax: gfx_SetClipRegion();
000918  001122  // Usage : var := gfx_SetClipRegion();
000919  001123  // *Notes:
000920  001124        
000921  001125  func gfx_Ellipse("x", "y", "xrad", "yrad", "colour"), 0;
000922  001126  // Syntax: gfx_Ellipse(x, y, xrad, yrad, colour);
000923  001127  // Usage : gfx_Ellipse(arg1, arg2, arg3, arg4, arg5);
000924  001128  // Notes : Plots a coloured Ellipse on the screen at centre x,y
000925  001129  //       : with xradius = xrad and yradius = yrad.
000926  001130  //       : if PenSize = 0 Ellipse is Solid
000927  001131  //       : if PenSize = 1 Ellipse is Outline
000928  001132        
000929  001133        
000930  001134  func gfx_EllipseFilled("x", "y", "xrad", "yrad", "colour"), 0;
000931  001135  // Syntax: gfx_EllipseFilled(x, y, xrad, yrad, colour);
000932  001136  // Usage : gfx_EllipseFilled(arg1, arg2, arg3, arg4, arg5);
000933  001137  // Notes : Plots a coloured Ellipse on the screen at centre x,y
000934  001138  //       : with xradius = xrad and yradius = yrad.
000935  001139        
000936  001140  func gfx_Button("state", "x", "y", "buttonColour", "textColour", "font", "textWidth", "textHeight", "text"), 0;
000937  001141  // Syntax: gfx_Button(mode, x, y, buttonColour, textColour, font, textWidth, textHeight, text);
000938  001142  // Usage : gfx_Button(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
000939  001143  // Notes : Draws a 3 dimensional Text Button at screen location defined by
000940  001144  //       : x,y arguments (top left corner). The size of the button depends on
000941  001145  //       : the font, width, height and length of the text.
000942  001146  //       : The button appearance will depend on the state parameter setting:
000943  001147  //       :         state = 0 : Button Pressed
000944  001148  //       :         state = 1 : Button Raised
000945  001149        
000946  001150  func gfx_Panel("state", "x", "y", "width", "height", "colour"), 0;
000947  001151  // Syntax: gfx_Panel("style", "x", "y", "width", "height", "colour"), 0;
000948  001152  // Usage : gfx_Panel(PANEL_RAISED, x, y, w, h, GRAY);
000949  001153  // Notes : Draws a panel (groupbox) at screen location defined by
000950  001154  //       : x, y, width and height with colour "colour".
000951  001155  //       :         state = 0 : recessed
000952  001156  //       :         state = 1 : raised
000953  001157        
000954  001158  func gfx_Slider("mode", "x1", "y1", "x2", "y2", "colour", "scale", "value"), 1;
000955  001159  // Syntax: gfx_Slider(mode, x1, y1, x2, y2, colour, scale, value);
000956  001160  // Usage : gfx_Slider(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
000957  001161  // Notes : Draws a 3 dimensional Slider Bar on the screen.
000958  001162  //       : Slider parameters are as follows:
000959  001163  //       :         mode = 0 : Slider recessed
000960  001164  //       :         mode = 1 : Slider raised
000961  001165  //       :         x1, y1 = top left corner
000962  001166  //       :         x2, y2 = bottom right corner
000963  001167  //       :         scale = n : sets the full scale range from 0 to n
000964  001168  //       :         value = m : sets the relative position of the thumb 0 <= m <= n
000965  001169  //       : returns:-
000966  001170        
000967  001171        
000968  001172  func gfx_ScreenCopyPaste("xs", "ys", "xd", "yd", "width", "height"), 0;
000969  001173  // Syntax: gfx_ScreenCopyPaste(xs, ys, xd, yd, width, height);
000970  001174  // Usage : gfx_ScreenCopyPaste(arg1, arg2, arg3, arg4, arg5, arg6);
000971  001175  // Notes : Copies an area of a screen from xs,ys of size given by width and height
000972  001176  //       : and pastes it to another location determined by xd, yd.
000973  001177        
000974  001178  func gfx_RGBto565("RED", "GREEN", "BLUE"), 1;
000975  001179  // Syntax: gfx_RGBto565(red, green, blue);
000976  001180  // Usage : gfx_RGBto565(arg1, arg2, arg3);
000977  001181  // Notes : Returns the 16bit (565 format) colour value of a 24bit (R,G,B format) colour
000978  001182        
000979  001183  func gfx_332to565("COLOUR8BIT"), 1;
000980  001184  // Syntax: gfx_332to565(colour);
000981  001185  // Usage : gfx_332to565(arg);
000982  001186  // Notes : Returns the 16bit (565 format) colour value of an 8 bit (332 format) colour
000983  001187        
000984  001188  func gfx_Selection("index", "backcolor", "textcolor"), 0;
000985  001189  // Syntax: gfx_Selection("index", "backcolor", "textcolor"), 0;
000986  001190  // Usage : gfx_Selection(1, RED, YELLOW);
000987  001191  // Notes : Called prior to drawing a button, this function
000988  001192  //       : hilites the required text line on a multiline button.
000989  001193        
000990  001194  func gfx_TriangleFilled("x1","y1","x2","y2","x3","y3","colr"), 0; // draw a filled triangle
000991  001195  // Syntax: gfx_TriangleFilled(x1, y1, x2, y2, x3, y3, colr);
000992  001196  // Usage : gfx_TriangleFilled(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
000993  001197  // Notes : Plots a coloured Solid Triangle from between 3 vertices: x1,y1 x2,y2 x3,y3
000994  001198  //       : Vertices must be specified in an anti-clockwise fashion
000995  001199        
000996  001200        
000997  001201  func gfx_PolygonFilled("n", "&vx", "&vy", "colr"), 0;        // draw a filled polygon from a table of vertices
000998  001202  // Syntax: gfx_PolygonFilled(numbVertices, &vx, &y, colour);
000999  001203  // Usage : gfx_PolygonFilled(arg1, x[array], y[array], arg2);
001000  001204  // Notes : Plots a solid Polygon between specified vertices: x1,y1 x2,y2 .. xn,yn
001001  001205  //       : Vertices must be minimum of 3 and can be specified in any fashion
001002  001206        
001003  001207        
001004  001208  func gfx_Origin("x", "y"), 0;            // set relative screen offset for graphics objects
001005  001209  // Syntax: gfx_Offset(x, y);
001006  001210  // Usage : gfx_Offset(arg1, arg2);
001007  001211  // Notes : Set the screen offset
001008  001212        
001009  001213        
001010  001214        
001011  001215  func gfx_Get("mode"), 1;
001012  001216  // Syntax: gfx_Get(mode);
001013  001217  // Usage : arg1 := gfx_Get(arg);
001014  001218  // Notes : Returns various parameters to caller
001015  001219  //       :
001016  001220  //       : mode = X_MAX (mode 0) : current orientations maximum X value
001017  001221  //       : var := gfx_Get(X_MAX);
001018  001222  //       : Returns the maximum horizontal value of the display
001019  001223  //       :
001020  001224  //       : mode = Y_MAX (mode 1) : Vcurrent orientations maximum Y value
001021  001225  //       : var := gfx_Get(Y_MAX);
001022  001226  //       : Returns the maximum vertical value of the display
001023  001227  //       :
001024  001228  //       : mode = LEFT_POS (mode 2) : Left location of last Object
001025  001229  //       : var := gfx_Get(LEFT_POS);
001026  001230  //       : Returns the left location of the last drawn object
001027  001231  //       : such as a slider or button or an image/video
001028  001232  //       :
001029  001233  //       : mode = TOP_POS (mode 3) : Top location of Object
001030  001234  //       : var := gfx_Get(TOP_POS);
001031  001235  //       : Returns the top location of the last drawn object
001032  001236  //       : such as a slider or button or an image/video
001033  001237  //       :
001034  001238  //       : mode = RIGHT_POS (mode 4) : Right location of last Object
001035  001239  //       : var := gfx_Get(RIGHT_POS);
001036  001240  //       : Returns the right location of the last drawn object
001037  001241  //       : such as a slider or button or an image/video
001038  001242  //       :
001039  001243  //       : mode = BOTTOM_POS  (mode 5) : Bottom location of Object
001040  001244  //       : var := gfx_Get(BOTTOM_POS );
001041  001245  //       : Returns the bottom location of the last drawn object
001042  001246  //       : such as a slider or button or an image/video
001043  001247  //       :
001044  001248        
001045  001249        
001046  001250  //==================================================//
001047  001251  // Single parameter short-cuts                      //
001048  001252  // for the gfx_Set functions                        //
001049  001253  // These functions return the existing value before //
001050  001254  // the change is made.                              //
001051  001255  //==================================================//
001052  001256  func gfx_PenSize("mode"), 1;                        // 0  graphics pen size, SOLD or OUTLINE
001053  001257  func gfx_BGcolour("colour"), 1;                     // 1  graphics background colour
001054  001258  func gfx_ObjectColour("colour"), 1;                 // 2  graphics object colour
001055  001259  func gfx_Clipping("mode"), 0;                       // 3  graphics clipping ON/OFF
001056  001260  func gfx_TransparentColour("colour"), 1;            // 4  graphics image transparent mask colour
001057  001261  func gfx_Transparency("mode"), 1;                   // 5  graphics image transparent mode ON/OFF
001058  001262  func gfx_FrameDelay("milliseconds"), 1;             // 6  graphics animation frame delay
001059  001263  func gfx_ScreenMode("mode"), 1;                     // 7  graphics orientation LANDSCAPE, LANDSCAPE_R, PORTRAIT, PORTRAIT_R
001060  001264  func gfx_OutlineColour("colour"), 1;                // 8  graphics rectangle/circle outline colour
001061  001265  func gfx_Contrast("value"), 1;                      // 9  graphics hardware value 0 to 9, 0=off, 1=lowest, 8=highest (only for AMOLED devices)
001062  001266  func gfx_LinePattern("value"), 1;                   // 10 graphics line draw tesselation pattern (16 linear bits, 1=pixel off)
001063  001267  func gfx_ColourMode("mode"), 1;                     // 11 graphics colour mode COLOUR8 or COLOUR16 (default colour 16)
001064  001268  func gfx_BevelWidth("mode"), 1;                     // 12 graphics button bevel width
001065  001269  func gfx_BevelShadow("value"), 1;                   // 13 graphics button bevel shadow depth
001066  001270  func gfx_Xorigin("offset"), 1;                      // 14 graphics  X origin
001067  001271  func gfx_Yorigin("offset"), 1;                      // 15 graphics  Y origin
001068  001272        
001069  001273        
001070  001274  //==================================================//
001071  001275  // uSD/FLASH Function Prototypes                    //
001072  001276  //==================================================//
001073  001277  func media_Video("x", "y"), 0;                      // display movie at position x y
001074  001278  // Syntax: media_Video(x, y);
001075  001279  // Usage : media_Video(arg1, arg2);
001076  001280  // Notes : Play a Video/Animation clip from the uSD card at screen location
001077  001281  //       : specified by x,y (top left corner). The location of the clip in the
001078  001282  //       : uSD card must be specified by media_setSector(Video_Sector_Add) function.
001079  001283        
001080  001284  func media_VideoFrame("x", "y","framenumber"), 0;   // display required frame from a movie at x y
001081  001285  // Syntax: media_VideoFrame(Frame_number);
001082  001286  // Usage : arg1 := media_VideoFrame();
001083  001287  // Notes : After a pointer to a valid video has been set with media_SetSector,
001084  001288  //       : calling this function shows each fram sequentially, returning
001085  001289  //       : the number of frames remaining. The position of the image is
001086  001290  //     : at the current origin as set with gfx_MoveTo(...);
001087  001291        
001088  001292  func media_SetAdd("HiWord", "LoWord"), 0;           // set stream byte address
001089  001293  // Syntax: media_SetAdd(AddHiWord, AddLoWord);
001090  001294  // Usage : media_SetAdd(arg1, arg2);
001091  001295  // Notes : Set uSD internal Address pointer for bytewise access
001092  001296        
001093  001297  func media_SetSector("HiWord", "LoWord"), 0;        // set stream sector address
001094  001298  // Syntax: media_SetSector(SectHiWord, SectLoWord);
001095  001299  // Usage : media_SetSector(arg1, arg2);
001096  001300  // Notes : Set uSD internal Sector pointer for sector block access
001097  001301        
001098  001302  func media_RdSector("*destination"), 1;
001099  001303  // Syntax: media_RdSector(*destination);
001100  001304  // Usage : media_RdSector(rdblock);
001101  001305  // Notes : Reads and Returns 512 bytes (256 words) into a destination
001102  001306  //       : block (eg rdblock[256]) pointed to by the internal Sector pointer.
001103  001307  //       : After the read the Sector pointer is automatically incremented by 1.
001104  001308  //       : Returns TRUE if uSD response was TRUE
001105  001309        
001106  001310  func media_WrSector("*source"), 1;
001107  001311  // Syntax: media_WrSector(*source);
001108  001312  // Usage : media_WrSector(wrblock);
001109  001313  // Notes : Writes 512 bytes (256 words) from a source memory block
001110  001314  //       : (eg wrblock[256]) into the uSD card. After the write the Sector
001111  001315  //       : pointer is automatically incremented by 1.
001112  001316  //       : Returns TRUE if uSD response was TRUE
001113  001317        
001114  001318  func media_ReadByte(), 1;                // read a byte at the current stream position
001115  001319  // Syntax: media_RdByte();
001116  001320  // Usage : var := media_RdByte();
001117  001321  // Notes : Reads and Returns a single byte of data from the
001118  001322  //       : uSD card pointed to by the internal Address pointer.
001119  001323  //       : After the read the Address pointer is automatically
001120  001324  //       : incremented by 1.
001121  001325        
001122  001326  func media_ReadWord(), 1;                // read a word at the current stream position
001123  001327  // Syntax: media_ReadWord();
001124  001328  // Usage : var := media_ReadWord();
001125  001329  // *Notes : Reads and Returns a single word of data from the
001126  001330  //       : uSD card pointed to by the internal Address pointer.
001127  001331  //       : After the read the Address pointer is automatically
001128  001332  //       : incremented by 2.
001129  001333        
001130  001334  func media_WriteByte("byte"), 1;              // write a byte to the current stream position
001131  001335  // Syntax: media_WriteByte(arg1);
001132  001336  // Usage : var := media_WriteByte(arg1);
001133  001337  // *Notes : Writes and Returns xxxxx
001134  001338  //       : After the write the Address pointer is automatically
001135  001339  //       : incremented by 1.
001136  001340        
001137  001341  func media_WriteWord("word"), 1;            // write a word to the current stream position
001138  001342  // Syntax: media_WriteWord(arg1);
001139  001343  // Usage : var := media_WriteWord(arg1);
001140  001344  // *Notes : Writes and Returns xxxxx
001141  001345  //       : After the write the Address pointer is automatically
001142  001346  //       : incremented by 2.
001143  001347        
001144  001348  func media_Image("x", "y"), 0;            // display image at position x y
001145  001349  // Syntax: media_Image(x, y);
001146  001350  // Usage : media_Image(arg1, arg2);
001147  001351  // Notes : Display an image from the uSD card at screen location
001148  001352  //       : specified by x,y (top left corner). The location of the
001149  001353  //       : Image in the uSD card must be specified by
001150  001354  //       : media_setSector(Image_Sector_Add) function.
001151  001355        
001152  001356  func media_Flush(), 1;                    // after writing to media, flush the sector and write
001153  001357  // Syntax: media_Flush();
001154  001358  // Usage : var := media_Flush();
001155  001359  // *Notes : After writing any data to a sector, media_Flush() should be called to ensure that the current sector that
001156  001360  //       : is being written is correctly stored back to the media else write operations may be unpredictable.
001157  001361        
001158  001362  func media_Init(), 1;                    // initialize uSD card
001159  001363  // Usage : media_Init();
001160  001364  // Notes : Initialise uSD CARD
001161  001365  //       : Response: 0 = No Card
001162  001366  //       :           1 = Card Initialised
001163  001367        
001164  001368        
001165  001369  //==============================================//
001166  001370  // Communications Function Prototypes           //
001167  001371  //==============================================//
001168  001372  func com_Init("buf","bufsize","qualifier"), 0;  // set up a interrupt driven ring buffer for comms
001169  001373  // Syntax: com_Init(buffer, bufsize, qualifier);
001170  001374  // Usage1: com_Init(mybuf, 20, 0);
001171  001375  // Usage2: com_Init(mybuf, 20, ':');
001172  001376  // Notes : initialize a serial capture buffer for the comms input
001173  001377  //       : The program must declare a var array as a circular buffer.
001174  001378  //       : Usage1 declares a circular buffer which will continually
001175  001379  //       : buffer characters.
001176  001380  //       : Usage2 must receive ':' before any characters will
001177  001381  //       : accumulate in the buffer.
001178  001382        
001179  001383  func com_Reset(), 0;                 // reset the comms receiver
001180  001384  // Syntax: com_Reset();
001181  001385  // Usage : com_Reset();
001182  001386  // Notes : reset comms to default polled mode
001183  001387        
001184  001388  func com_Count(), 1;                // return count of characters in receive buffer
001185  001389  // Syntax: com_Count();
001186  001390  // Usage : arg := com_Count();
001187  001391  // Notes : return count of buffered characters in buffer attachment
001188  001392        
001189  001393  func com_Full(), 1;                // return TRUE if receiver buffer filled to capcity
001190  001394  // Syntax: com_Full();
001191  001395  // Usage : if (com_Full() ,,,, go read buffer;
001192  001396  // Notes : return true if buffer full (not necessarily an error if
001193  001397  //       : buffer is sized to a packet size)
001194  001398        
001195  001399  func com_Error(), 1;                // return comms errors comms error occurred
001196  001400  // Syntax: com_Error();
001197  001401  // Usage : if (com_Error() ) ...... take recovery action;
001198  001402  // Notes : return non zero if any errors low level comms errors occured
001199  001403  // returns :
001200  001404  // bit0 = Receiver Overflow Error
001201  001405  // bit1 = Receiver Framing Error
001202  001406  // bit2 = Transmit Buffer Overflow
001203  001407        
001204  001408  func com_Sync(), 1;                // returns TRUE if qualifier has been received
001205  001409  // Syntax: com_Sync();
001206  001410  // Usage : com_Sync();
001207  001411  // return true if sync character has been received in com_Init("...") mode
001208  001412        
001209  001413        
001210  001414  func com_TXbuffer("buf", "bufsize", "pin"), 0;    // sets the buffer location for buffered transmission
001211  001415  // Syntax: com_TXbuffer("buf", "bufsize", "pin");
001212  001416  // Usage : com_TXbuffer(mybuf, 1024, IO1_PIN);    // set the TX buffer, usin IO1_PIN for turnaround
001213  001417  // Usage : com_TXbuffer(0, 0, 0);              // revert to non buffered service
001214  001418  // Notes : initialize a serial buffer for the COM0 output.
001215  001419  //       : The program must declare a var array as a circular buffer.
001216  001420  //       : When a TX buffer is declared for comms, the transmission
001217  001421  //       : of characters becomes non blocking. The only time
001218  001422  //       : blocking will occur is if the buffer has insufficient space
001219  001423  //       : to accept the next character, in which case the function
001220  001424  //       : will wait for buffer space to become available. If the
001221  001425  //       : TX buffer is no longer required, just set the buffer pointer
001222  001426  //       : to zero, the size in this case doesnt matter and is ignored.
001223  001427  //       : The function can resize or reallocated to another buffer at
001224  001428  //       : any time. The buffer is flushed before any changes are made.
001225  001429  //       : "pin" designates an IO pin to control a bi-directional 
001226  001430  //       : control device for half duplex mode. "pin" will go HI at the
001227  001431  //       : start of a transmission, and will return low after the final
001228  001432  //       : byte is transmitted. If not required, just set "pin" to zero.
001229  001433        
001230  001434        
001231  001435  func com_TXcount(), 1;                // return count of characters in COM0 TX buffer
001232  001436  // Syntax: com_TXcount();
001233  001437  // Usage : arg := com_Count();
001234  001438  // Notes : return count of characters remaining in COM0 transmit buffer
001235  001439  //       : that was previously allocated with com_TXbuffer(...);
001236  001440        
001237  001441        
001238  001442  func com_TXemptyEvent("function"), 1;  // sets a function to be called when COM0 TX buffer empty
001239  001443  // Syntax: com_TXemptyEvent(function);
001240  001444  // Usage : arg := com_TXemptyEvent();
001241  001445  // Notes : If a comms TX buffer that was previously allocated with
001242  001446  //       : com_TXbuffer(...);, this function can be used to set up
001243  001447  //       : a function to be called when the COM0 TX buffer is empty.
001244  001448  //       : This is useful for either reloading the TX buffer, setting
001245  001449  //       : or clearing a pin to change the direction of eg a RS485
001246  001450  //       : line driver, or any other form of traffic control.
001247  001451  //       : The event function must not have any parameters.
001248  001452  //       : To disable the event, simply call com_TXemptyEvent(0).
001249  001453  //       : com_TXbuffer(...); also resets any active event.
001250  001454  //       : com_TXemptyEvent returns any previous event function
001251  001455  //       : address, or zero if there was no previous function.
001252  001456        
001253  001457        
001254  001458  func com_TXbufferHold("state"), 1; // hold or release a com_TXbuffer
001255  001459  // Usage : arg := com_TXbufferHold(ON);  // hold the buffer while we fill it
001256  001460  // Usage : arg := com_TXbufferHold(OFF);  // start sending the buffer
001257  001461  // Notes : Expecting that a comms TX buffer that was previously allocated with
001258  001462  //       : com_TXbuffer(...);, com_TXbufferHold(ON) can be used to stop
001259  001463  //       : the buffer being sent wile it is being loaded. Mormally, when
001260  001464  //       : using buffered comms, the transmit process will begin
001261  001465  //       : immediately. This is often undesirable for 2 reasons,
001262  001466  //       : 1] you may wish to build a packet then send it later
001263  001467  //       : 2] when using com_TXemptyEvent erroneous empty events will occur
001264  001468  //       : as the FIFO buffer is constantly trying to empty while
001265  001469  //       : you are busy tring to fill it.
001266  001470  // return -1 if function is called illegally when TX comms is not buffered.
001267  001471  // return buffer count when called with argument of 1, eg com_TXbufferHold(ON)
001268  001472  // return 0 when argument is zero, eg com_TXbufferHold(OFF)
001269  001473        
001270  001474        
001271  001475  //=============================================================//
001272  001476  // Auxilliary Communications Function Prototypes
001273  001477  //=============================================================//
001274  001478  func com1_Init("buffer", "bufsize", "qualifier"), 0;
001275  001479  // Syntax: com_Init(buffer, bufsize, qualifier);
001276  001480  // Usage1: com_Init(mybuf, 20, 0);
001277  001481  // Usage2: com_Init(mybuf, 20, ':');
001278  001482  // Notes : initialize a serial capture buffer for the comms input
001279  001483  //       : The program must declare a var array as a circular buffer.
001280  001484  //       : Usage1 declares a circular buffer which will continually
001281  001485  //       : buffer characters.
001282  001486  //       : Usage2 must receive ':' before any characters will
001283  001487  //       : accumulate in the buffer.
001284  001488        
001285  001489  func com1_Reset(), 0;
001286  001490  // Syntax: com_Reset();
001287  001491  // Usage : com_Reset();
001288  001492  // Notes : reset comms receiver to default polled mode
001289  001493        
001290  001494  func com1_Count(), 1;
001291  001495  // Syntax: com_Count();
001292  001496  // Usage : arg := com_Count();
001293  001497  // Notes : return count of characters in receive buffer
001294  001498        
001295  001499  func com1_Full(), 1;
001296  001500  // Syntax: com_Full();
001297  001501  // Usage : if (com_Full() ,,,, go read buffer;
001298  001502  // Notes : return true if receive buffer full
001299  001503        
001300  001504  func com1_Error(), 1;
001301  001505  // Syntax: com_Error();
001302  001506  // Usage : if (com_Error() ) ...... take recovery action;
001303  001507  // Notes : return non zero if any level comms errors occured
001304  001508  // returns :
001305  001509  // bit0 = Receiver Overflow Error
001306  001510  // bit1 = Receiver Framing Error
001307  001511  // bit2 = Transmit Buffer Overflow
001308  001512        
001309  001513  func com1_Sync(), 1;
001310  001514  // Syntax: com_Sync();
001311  001515  // Usage : com_Sync();
001312  001516  // Notes : return true if sync character has been received in com_Init("...") mode
001313  001517        
001314  001518        
001315  001519  func com1_TXbuffer("buf", "bufsize", "pin"), 0;    // sets the buffer location for buffered transmission
001316  001520  // Syntax: com1_TXbuffer("buf", "bufsize", "pin");
001317  001521  // Usage : com1_TXbuffer(mybuf, 1024, IO1_PIN);    // set the TX buffer, usin IO1_PIN for turnaround
001318  001522  // Usage : com1_TXbuffer(0, 0, 0);              // revert to non buffered service
001319  001523  // Notes : initialize a serial buffer for the COM1 output.
001320  001524  //       : The program must declare a var array as a circular buffer.
001321  001525  //       : When a TX buffer is declared for comms, the transmission
001322  001526  //       : of characters becomes non blocking. The only time
001323  001527  //       : blocking will occur is if the buffer has insufficient space
001324  001528  //       : to accept the next character, in which case the function
001325  001529  //       : will wait for buffer space to become available. If the
001326  001530  //       : TX buffer is no longer required, just set the buffer pointer
001327  001531  //       : to zero, the size in this case doesnt matter and is ignored.
001328  001532  //       : The function can resize or reallocated to another buffer at
001329  001533  //       : any time. The buffer is flushed before any changes are made.
001330  001534  //       : "pin" designates an IO pin to control a bi-directional 
001331  001535  //       : control device for half duplex mode. "pin" will go HI at the
001332  001536  //       : start of a transmission, and will return low after the final
001333  001537  //       : byte is transmitted. If not required, just set "pin" to zero.
001334  001538        
001335  001539        
001336  001540  func com1_TXcount(), 1;                // return count of characters in COM1 TX buffer
001337  001541  // Syntax: com1_TXcount();
001338  001542  // Usage : arg := com1_Count();
001339  001543  // Notes : return count of characters remaining in COM1 transmit buffer
001340  001544  //       : that was previously allocated with com1_TXbuffer(...);
001341  001545        
001342  001546        
001343  001547  func com1_TXemptyEvent("function"), 1;  // sets a function to be called when COM1 TX buffer empty
001344  001548  // Syntax: com1_TXemptyEvent(function);
001345  001549  // Usage : arg := com1_TXemptyEvent();
001346  001550  // Notes : If a comms TX buffer that was previously allocated with
001347  001551  //       : com1_TXbuffer(...);, this function can be used to set up
001348  001552  //       : a function to be called when the COM1 TX buffer is empty.
001349  001553  //       : This is useful for either reloading the TX buffer, setting
001350  001554  //       : or clearing a pin to change the direction of eg a RS485
001351  001555  //       : line driver, or any other form of traffic control.
001352  001556  //       : The event function must not have any parameters.
001353  001557  //       : To disable the event, simply call com1_TXemptyEvent(0).
001354  001558  //       : com1_TXbuffer(...); also resets any active event.
001355  001559  //       : com1_TXemptyEvent returns any previous event function
001356  001560  //       : address, or zero if there was no previous function.
001357  001561        
001358  001562        
001359  001563  func com1_TXbufferHold("state"), 1; // hold or release a com1_TXbuffer
001360  001564  // Usage : arg := com1_TXbufferHold(ON);  // hold the buffer while we fill it
001361  001565  // Usage : arg := com1_TXbufferHold(OFF);  // start sending the buffer
001362  001566  // Notes : Expecting that a comms TX buffer that was previously allocated with
001363  001567  //       : com1_TXbuffer(...);, com1_TXbufferHold(ON) can be used to stop
001364  001568  //       : the buffer being sent wile it is being loaded. Mormally, when
001365  001569  //       : using buffered comms, the transmit process will begin
001366  001570  //       : immediately. This is often undesirable for 2 reasons,
001367  001571  //       : 1] you may wish to build a packet then send it later
001368  001572  //       : 2] when using com_TXemptyEvent erroneous empty events will occur
001369  001573  //       : as the FIFO buffer is constantly trying to empty while
001370  001574  //       : you are busy tring to fill it.
001371  001575  // return -1 if function is called illegally when TX comms is not buffered.
001372  001576  // return buffer count when called with argument of 1, eg com1_TXbufferHold(ON)
001373  001577  // return 0 when argument is zero, eg com1_TXbufferHold(OFF)
001374  001578        
001375  001579  func serin1(), 1;
001376  001580  // Syntax: serin1();
001377  001581  // Usage : char := serin1();
001378  001582  // Notes : return the next available character from COM1
001379  001583        
001380  001584  func serout1("char"), 0;
001381  001585  // Syntax: serout1("char");
001382  001586  // Usage : serout1(ch);
001383  001587  // Notes : send character to COM1
001384  001588        
001385  001589  func com_SetBaud("comport","baudrate/10"), 1;
001386  001590  // Syntax: com_SetBaud("comport","baudrate/10");
001387  001591  // Usage : com_SetBaud(COM1, 960);   // set COM1 to 9600 baud
001388  001592  // Notes : sets to any viable baud rate from 160 to 655350
001389  001593  // return true if baud rate was acceptable
001390  001594        
001391  001595        
001392  001596        
001393  001597  //==============================================//
001394  001598  // Display Access                               //
001395  001599  //==============================================//
001396  001600  func disp_Init(), 0;                            // initialize display with required tables
001397  001601  // Syntax: disp_Init();
001398  001602  // Usage : disp_Init();
001399  001603  // Notes : Initialises or reinitialises the display.
001400  001604  //       : Normally used after restoration of peripheral power
001401  001605  //       : and after DeepSleep.
001402  001606        
001403  001607  func disp_SetReg("register", "data"), 0;
001404  001608  // Syntax: display_SetReg(register, data);
001405  001609  // Usage : display_SetReg(arg1, arg2);
001406  001610  // Notes : Sets uLCD specific display driver registers. Refer
001407  001611  //       : to appropriate display driver data sheet.
001408  001612        
001409  001613  func disp_setGRAM("x1","y1","x2","y2"), 0;    // set GRAM window
001410  001614  // Syntax: disp_setGRAM(x1, y1, x2, y2);
001411  001615  // Usage : disp_setGRAM(arg1, arg2, arg3, arg4);
001412  001616  // Notes : Prepares the GRAM area for user access.
001413  001617  //       : Data can now be written with disp_GRAM.
001414  001618  //       : GRAM will be set accordingly for the correct screen mode.
001415  001619  //       : the LO word of the 32 bit pixel count is returned. This is
001416  001620  //       : usually all that is needed unlse GRAM area exceeds 256^2
001417  001621  //       : A copy of the 32bit value can be found in
001418  001622  //       : GRAM_PIXEL_COUNT_LO and GRAM_PIXEL_COUNT_HI
001419  001623        
001420  001624  func disp_WrGRAM("colour"), 0;
001421  001625  // Syntax: display_WrGRAM(colour);
001422  001626  // Usage : display_WrGRAM(arg);
001423  001627  // Notes : Data can be written to the GRAM consecutively using
001424  001628  //       : this function once the GRAM access window has been setup.
001425  001629        
001426  001630  func disp_WriteControl("value"), 0;             // write a control byte to the display
001427  001631  func disp_WriteWord("value"), 0;                // write a word to the display
001428  001632        
001429  001633        
001430  001634  func disp_ReadWord(), 1;                        // read a word from the display
001431  001635  // Syntax: disp_ReadWord();
001432  001636  // Usage : x:=disp_ReadWord();
001433  001637  // Notes : Read a word from the controller
001434  001638  // Eg:   : disp_WriteControl(0);         // select Ilitek ID register
001435  001639  //       : print(disp_ReadWord());        // print ID
001436  001640  //       : (Many displays are write only)
001437  001641        
001438  001642                                                  //
001439  001643  //==============================================//
001440  001644  // unadorned SPI functions                      //
001441  001645  //==============================================//
001442  001646  func spi_Init("speed","ip_mode","op_mode"), 0;  // set the SPI port, not used if uSD active
001443  001647  func spi_Read(), 1;                             // read a raw byte from SPI (lowers CS)
001444  001648  func spi_Write("byte"), 0;                      // write a raw byte to SPI (lowers CS)
001445  001649  func spi_Disable(), 0;                          // disable SPI reading or writing (raise CS)
001446  001650                                                  //
001447  001651  //==============================================//
001448  001652  // flash device specific functions              //
001449  001653  //==============================================//
001450  001654  func flash_SIG(), 1;                            // read Jedecsignature from SPI Flash device
001451  001655  func flash_ID(), 1;                             // read ID code from FLASH device
001452  001656  func flash_BulkErase(), 0;                      // erase the entire FLASH device
001453  001657  func flash_BlockErase("block"), 1;              // erase the required 64k flash block
001454  001658                                                  //
001455  001659                                                  //
001456  001660  //==============================================//
001457  001661  // string and character size function           //
001458  001662  //==============================================//
001459  001663  func charwidth("char"), 1;                      // return width of a character in pixel units
001460  001664  func charheight("char"), 1;                     // return height of a character in pixel units
001461  001665  func strwidth("pointer"), 1;                    // return width of a string in pixel units
001462  001666  func strheight(), 1;                            // return height of a string in pixel units
001463  001667        
001464  001668        
001465  001669  //------------------------------------------------------------------//
001466  001670  //        I2C Function Prototypes
001467  001671  //------------------------------------------------------------------//
001468  001672  func I2C_Open("speed"), 0;
001469  001673  // Syntax: I2C_Open(speed),
001470  001674  // Usage : I2C_Open(I2C_MED);
001471  001675  // Notes : configures the I2C module
001472  001676  //       : speed can be I2C_SLOW, I2C_MED, I2C_FAST (100khz, 400khz, 1mhz)
001473  001677        
001474  001678  func I2C_Close(), 0;
001475  001679  // Syntax: I2C_Close();
001476  001680  // Usage : I2C_Close();
001477  001681  // Notes : disables the I2C1 module.
001478  001682        
001479  001683  func I2C_Start(), 1;
001480  001684  // Syntax: I2C_Start();
001481  001685  // Usage : I2C_Start();
001482  001686  // Notes : generates a Start condition.
001483  001687  //       : returns true if successful (usually ignored)
001484  001688        
001485  001689  func I2C_Stop(), 1;
001486  001690  // Syntax: I2C_Stop();
001487  001691  // Usage : I2C_Stop();
001488  001692  // Notes : generates a Stop condition.
001489  001693  //       : returns true if successful (usually ignored)
001490  001694        
001491  001695  func I2C_Restart(), 1;
001492  001696  // Syntax: I2C_Restart();
001493  001697  // Usage : I2C_Restart();
001494  001698  // Notes : generates a Restart condition.
001495  001699  //       : returns true if successful (usually ignored)
001496  001700        
001497  001701  func I2C_Read(), 1;
001498  001702  // Syntax: I2C_Read();
001499  001703  // Usage : ch := I2C_Read();
001500  001704  // Notes : reads a single byte from the I2C Bus.
001501  001705        
001502  001706  func I2C_Write("byte"), 1;
001503  001707  // Syntax: I2C_Write(byte);
001504  001708  // Usage : r := I2C_Write(ch);
001505  001709  // Notes : is used to write a byte to the I2C bus.
001506  001710  //       : Returns 0 if failed, 1 if no ack, 2 if ack
001507  001711        
001508  001712  func I2C_Ack(), 0;
001509  001713  // Syntax: I2C_Ack();
001510  001714  // Usage : I2C_Ack();
001511  001715  // Notes : generates the acknowledge condition.
001512  001716        
001513  001717  func I2C_Nack(), 0;
001514  001718  // Syntax: I2C_Nack();
001515  001719  // Usage : I2C_Nack();
001516  001720  // Notes : generates the negative acknowledge condition.
001517  001721        
001518  001722  func I2C_AckStatus(), 0;
001519  001723  // Syntax: I2C_AckStatus();
001520  001724  // Usage : r := I2C_AckStatus();
001521  001725  // Notes : returns the ACK status from the device.
001522  001726        
001523  001727  func I2C_AckPoll("control"), 1;
001524  001728  // Syntax: I2C_AckPoll();
001525  001729  // Usage : r := I2C_AckPoll(0xA0);
001526  001730  // Notes : waits for a device to return from ACK polling.
001527  001731        
001528  001732  func I2C_Idle(), 0;
001529  001733  // Syntax: I2C_Idle();
001530  001734  // Usage : I2C_Idle();
001531  001735  // Notes : waits until the I2C Bus is Inactive.
001532  001736        
001533  001737  func I2C_Gets("buffer", "size"), 1;
001534  001738  // Syntax: I2C_Gets("buffer", "size");
001535  001739  // Usage : r := I2C_Gets(mybuf, 16);
001536  001740  // Notes : only reads up to "size" characters into "buffer"
001537  001741  //       : Reads up to asciiz terminator including terminator
001538  001742        
001539  001743  func I2C_Getn("buffer", "size"), 1;
001540  001744  // Syntax: I2C_Gets("buffer", "size");
001541  001745  // Usage : r := I2C_Gets(mybuf, 16);
001542  001746  // Notes : reads "size" bytes into "buffer"
001543  001747  //       :
001544  001748        
001545  001749  func I2C_Puts("buffer"), 1;
001546  001750  // Syntax: I2C_Puts("buffer");
001547  001751  // Usage : r := I2C_Puts(mybuf);
001548  001752  // Notes : writes an asciiz string to the I2C device
001549  001753  //       : returns count of characters written
001550  001754        
001551  001755  func I2C_Putn("buffer", "count"), 1;
001552  001756  // Syntax: I2C_Putn("buffer","count");
001553  001757  // Usage : r := I2C_Puts(mybuf,10);
001554  001758  // Notes : writes up to "size" bytes to the I2C device
001555  001759  //       : returns number of bytes written
001556  001760        
001557  001761        
001558  001762  //------------------------------------------------------------------//
001559  001763  //        Image Control Function Prototypes
001560  001764  //------------------------------------------------------------------//
001561  001765  func img_SetPosition("handle", "index", "xpos", "ypos"), 1;
001562  001766  // Syntax: img_SetPosition(handle, index, xpos, ypos);
001563  001767  // Usage : r := img_SetPosition(hImageList, imagenum, x, y);
001564  001768  // Notes : set the position where the image will be displayed
001565  001769  //       : returns true if index was ok and function was successful.
001566  001770  //       : you may turn off an image so when img_Refresh is called,
001567  001771  //       : the image will not be shown
001568  001772        
001569  001773  func img_Enable("handle", "index"), 1;
001570  001774  // Syntax: img_Enable(handle, index);
001571  001775  // Usage : r := img_Enable(hImageList, imagenum);
001572  001776  // Notes : enable image in a image list
001573  001777  //       : returns true if index was ok and function was successful.
001574  001778  //       : this is the default state so when img_Refresh is called,
001575  001779  //       : all the images in the list will be shown
001576  001780  //       : if index is set to -1, all of the images are enabled
001577  001781        
001578  001782  func img_Disable("handle", "index"), 1;
001579  001783  // Syntax: img_Disable(handle, index);
001580  001784  // Usage : r := img_Disable(hImageList, imagenum);
001581  001785  // Notes : disable image in a image list
001582  001786  //       : returns true if index was ok and function was successful.
001583  001787  //       : you must turn off an image so when img_Refresh is called,
001584  001788  //       : the image will not be shown.
001585  001789  //       : if index is set to -1, all of the images are disabled
001586  001790        
001587  001791        
001588  001792  func img_Darken("handle", "index"), 1;
001589  001793  // Syntax: img_Darken(handle, index);
001590  001794  // Usage : r := img_Darken(hImageList, imagenum);
001591  001795  // Notes : darken image in a image list
001592  001796  //       : returns true if index was ok and function was successful.
001593  001797  //       : if index is set to -1, all of the images are darkened
001594  001798  //       : NB:- this feature will only work for the next refresh, then
001595  001799  //       : the image reverts back to normal when displayed again.
001596  001800        
001597  001801        
001598  001802  func img_Lighten("handle", "index"), 1;
001599  001803  // Syntax: img_Lighten(handle, index);
001600  001804  // Usage : r := img_Lighten(hImageList, imagenum);
001601  001805  // Notes : lighten image in a image list
001602  001806  //       : returns true if index was ok and function was successful.
001603  001807  //       : if index is set to -1, all of the images are lightened
001604  001808  //       : NB:- this feature will only work for the next refresh, then
001605  001809  //       : the image reverts back to normal when displayed again.
001606  001810        
001607  001811  func img_SetWord("handle", "index", "offset", "word"), 1;
001608  001812  // Syntax: img_SetWord(handle, index, offset, word);
001609  001813  // Usage : img_SetWord(hndl, 5, IMAGE_XPOS, 10);
001610  001814  // Notes : set specified word (0-7) in a image entry
001611  001815  //       : returns TRUE if successful, return value usually ignored.
001612  001816        
001613  001817  func img_GetWord("handle", "index", "offset"), 1;
001614  001818  // Syntax: myvar := img_GetWord("handle", "index", "offset");
001615  001819  // Usage : myvar := img_GetWord(hndl, 5, IMAGE_YPOS);
001616  001820  // Notes : returns specified word (0-14) from an image entry
001617  001821  //       : refer to image control entry offsets.
001618  001822        
001619  001823  func img_Show("handle", "index"), 1;
001620  001824  // Syntax: img_Show(handle, index);
001621  001825  // Usage : display image entry (regardless of enable/disable)
001622  001826  //       : returns TRUE if successful, return value usually ignored.
001623  001827        
001624  001828  func img_SetAttributes("handle", "index","value"), 1;
001625  001829  // Syntax: img_SetAttributes("handle", "index","offset");
001626  001830  // Usage : img_SetAttributes(hndl, 5, I_TOPMOST);
001627  001831  // Notes : This function SETS one or more bits in the IMAGE_FLAGS field
001628  001832  //       : of an image control entry. "value" refers to various bits in
001629  001833  //       : the image control entry (see image attribute flags).
001630  001834  //       : A '1' bit in the "value" field SETS the respective bit
001631  001835  //       : in the IMAGE_FLAGS field of the image control entry.
001632  001836  //       : returns TRUE if successful, return value usually ignored.
001633  001837        
001634  001838  func img_ClearAttributes("handle", "index","value"), 1;
001635  001839  // Syntax: img_ClearAttributes("handle", "index","offset");
001636  001840  // Usage : img_ClearAttributes(hndl, 5, I_TOPMOST);
001637  001841  // Notes : This function CLEARS one or more bits in the IMAGE_FLAGS field
001638  001842  //       : of an image control entry. "value" refers to various bits in
001639  001843  //       : the image control entry (see image attribute flags)
001640  001844  //       : a '1' bit in the "value" field CLEARS the respective bit
001641  001845  //       : in the IMAGE_FLAGS field of the image control entry.
001642  001846  //       : returns TRUE if successful, return value usually ignored.
001643  001847        
001644  001848  func img_Touched("handle", "index"), 1;
001645  001849  // Syntax: r := img_Touched(handle, index);
001646  001850  // Usage : img_Touched(hndl, 17);
001647  001851  //       : returns -1 if image not touched, or returns index
001648  001852  // Notes : if index is passed as -1, function tests all images,
001649  001853  //       : and returns -1 if image not touched, or returns index.
001650  001854        
001651  001855        
001652  001856        
001653  001857        
001654  001858  //------------------------------------------------------------------//
001655  001859  //        Timer Function Prototypes
001656  001860  //------------------------------------------------------------------//
001657  001861  func sys_T(), 1;
001658  001862  // Syntax: sys_T();
001659  001863  // Usage : t := sys_T();
001660  001864  // Notes : return the current value of the rolling system timer (1msec) LO word
001661  001865        
001662  001866  func sys_T_HI(), 1;
001663  001867  // Syntax: sys_T_HI();
001664  001868  // Usage : t := sys_T_HI();
001665  001869  // Notes : return the current value of the rolling system timer (1msec) HI word
001666  001870        
001667  001871  func sys_SetTimer("timernum","value"), 0;
001668  001872  // Syntax: sys_SetTimer("timernum", "value");
001669  001873  // Usage : sys_SetTimer(TIMER5, 10000);
001670  001874  // Notes : set a countdown on the selected timer, or 'top up' if required.
001671  001875  //       : There ar 8 timers TIMER0 to TIMER7 which stop at the count of 0
001672  001876  //       : Maximum timeout period is 65.535 seconds
001673  001877  //       : A timer can be read with the sys_GetTimer("timernum") function
001674  001878        
001675  001879  func sys_GetTimer("timernum"), 1;
001676  001880  // Syntax: t := sys_GetTimer("timernum");
001677  001881  // Usage : t := sys_GetTimer(TIMER3);
001678  001882  // Notes : returns 0 if timer has expired, or the current countdown value.
001679  001883  //       : There ar 8 timers TIMER0 to TIMER7 which stop at the count of 0
001680  001884  //       : Maximum timeout period is 65.535 seconds
001681  001885  //       : A timer must be set with the sys_SetTimer("timernum","value") function
001682  001886        
001683  001887  func sys_SetTimerEvent("timernum","function"), 1;
001684  001888  // Syntax: sys_SetTimerFunction("timernum", "function");
001685  001889  // Usage : sys_SetTimer(TIMER5, myfunc);
001686  001890  // Notes : set a function to be called for selected timer.
001687  001891  //       : When the timer reaches zero, the function is called.
001688  001892  //       : The called function must not have any parameters
001689  001893  //       : sys_SetTimerEvent returns any previous event function
001690  001894  //       : address, or zero if there was no previous function.
001691  001895        
001692  001896  func sys_EventQueue(), 1;
001693  001897  // Syntax: sys_EventQueue();
001694  001898  // Usage : tasks := sys_EventQueue();
001695  001899  // Notes : returns the max number of events that were pending
001696  001900  //       : in the timer queue since the last call to this function.
001697  001901  //       : This can be used to assess timer event overhead burden,
001698  001902  //       : especially after or during a sys_EventsPostpone action.
001699  001903        
001700  001904  func sys_EventsPostpone(), 0;
001701  001905  // Syntax: sys_EventPostpone();
001702  001906  // Usage : sys_EventPostpone();   // postpone the event queue
001703  001907  // Notes : postpone any events until the sys_EventResume function is executed
001704  001908  //       : The timer event queue will continue to queue events, but no action
001705  001909  //       : will take place untill a sys_EventResume function is encountered.
001706  001910  //       : The queue will continue to receive up to 32 events before discarding
001707  001911  //       : any further events. This function is required to allow a sequence of
001708  001912  //       : instructions or functions to occur that would otherwise be corrupted
001709  001913  //       : by an event occuring during the sequence of instructions or functions.
001710  001914  //       : A good example of this is when you set a position to print, if there
001711  001915  //       : was no way of locking the current sequence, an event may occur which
001712  001916  //       : does a similar thing, and a contention would occur - printing to
001713  001917  //       : the wrong position. This function should be used wisely, if any action
001714  001918  //       : that is required would take considerable time, it is better to disable
001715  001919  //       : any conflicting event functions with a bypass flag, then restart the
001716  001920  //       : conflicting event by re-issuing a timer value.
001717  001921        
001718  001922  func sys_EventsResume(), 0;
001719  001923  // Syntax: sys_EventsResume();
001720  001924  // Usage : sys_EventsResume();   // resume the event queue
001721  001925  // Notes : resume any postponed events. The queue will try to execute any timer
001722  001926  //       : events that were incurred during the postponed period.
001723  001927        
001724  001928        
001725  001929  func sys_Sleep("units"), 1;
001726  001930  // Syntax: t := sys_Sleep("units");
001727  001931  // Usage : t := sys_Sleep(10);
001728  001932  // Notes : sets the display into low power mode for a period of time.
001729  001933  //       : Touching the touch screen will also wake from sleep.
001730  001934  //       : Returns remaining sleep units.
001731  001935        
001732  001936  func iterator("offset"), 0;
001733  001937  // Syntax: t :=  iterator("offset");
001734  001938  // Usage : t :=  iterator(10);
001735  001939  // Notes : set the iterator size for ++/--
001736  001940  //       : The next postinc,postdec,preinc of predec will alter
001737  001941  //       : by the specified value.
001738  001942  //       : The offset will return to 1 after the next operation.
001739  001943        
001740  001944        
001741  001945        
001742  001946        
001743  001947  //------------------------------------------------------------------//
001744  001948  //         Touch Screen Function Prototypes
001745  001949  //------------------------------------------------------------------//
001746  001950        
001747  001951  func touch_DetectRegion("x1" ,"y1", "x2", "y2"), 0;
001748  001952  // Syntax: touch_DetectRegion(x1, y1, x2, y2);
001749  001953  // Usage : touch_DetectRegion(arg1, arg2, arg3, arg4);
001750  001954  // Notes : Specifies a new touch detect region on the screen
001751  001955  //       : such that only touch activity in that region will
001752  001956  //       : be reported by the status poll touch_Get(TOUCH_STATUS);
001753  001957        
001754  001958  func touch_Set("mode"), 0;
001755  001959  // Syntax: touch_Set(mode);
001756  001960  // Usage : touch_Set(arg);
001757  001961  // Notes : Sets various Touch Screen related parameters
001758  001962  //       :
001759  001963  //       : mode = TOUCH_ENABLE (mode 0)  Enable Touch Screen
001760  001964  //       : touch_Set(TOUCH_ENABLE);
001761  001965  //       : Enables and initialises Touch Screen hardware
001762  001966  //       :
001763  001967  //       : mode = TOUCH_DISABLE (mode 1)  Disable Touch Screen
001764  001968  //       : touch_Set(TOUCH_DISABLE );
001765  001969  //       : Disables the Touch Screen
001766  001970  //       : Note: Touch Screen runs in the background and disabling
001767  001971  //       : it when not in use will free up extra resources
001768  001972  //       : such as 4DVM CPU cycles.
001769  001973  //       :
001770  001974  //       : mode = TOUCH_REGIONDEFAULT (mode 2)  Default Touch Region
001771  001975  //       : touch_Set(TOUCH_REGIONDEFAULT);
001772  001976  //       : This will reset the current active region to default
001773  001977  //       : to the full screen without the application having to
001774  001978  //       : set a new active region for the full screen.
001775  001979  //       : (NB for 'no touch' devices - like uVGAII or OLED's/LCD's
001776  001980  //       : that requre to be interfaced with an external pointing
001777  001981  //       : device, values that are poked into TOUCH_DRIVE will be
001778  001982  //       : read with the touch_Get() function)
001779  001983        
001780  001984        
001781  001985  func touch_Get("mode"), 1;
001782  001986  // Syntax: touch_Get(mode);
001783  001987  // Usage : arg1 := touch_Get(arg);
001784  001988  // Notes : Returns various Touch Screen parameters to caller
001785  001989  //       :
001786  001990  //       : mode = TOUCH_STATUS  (mode 0)
001787  001991  //       : var := touch_Get(TOUCH_STATUS);
001788  001992  //       : Returns the various states of the touch screen
001789  001993  //       : 0 = NOTOUCH
001790  001994  //       : 1 = TOUCH_PRESSED
001791  001995  //       : 2 = TOUCH_RELEASED
001792  001996  //       : 3 = TOUCH_MOVING
001793  001997  //       :
001794  001998  //       : mode = TOUCH_GETX   (mode 1)
001795  001999  //       : var := touch_Get(TOUCH_GETX);
001796  002000  //       : Returns the X coordinates of the touch
001797  002001  //       :
001798  002002  //       : mode = TOUCH_GETY   (mode 2)
001799  002003  //       : var := touch_Get(TOUCH_GETY);
001800  002004  //       : Returns the Y coordinates of the touch
001801  002005        
001802  002006  //------------------------------------------------------------------//
001803  002007  //        CTYPE Function Prototypes
001804  002008  //------------------------------------------------------------------//
001805  002009        
001806  002010  func isdigit("char"), 1;    //Returns a 1 if the character is an ascii digit else returns a 0
001807  002011  // Syntax: isdigit("char");
001808  002012  // Usage : Var := isdigit(ch);
001809  002013  // Notes : char specifies the ascii character for the test
001810  002014  //     : 0 : char is not an ascii digit.
001811  002015  //     : 1 : char is an ascii digit..
001812  002016  //     : Valid range is "0123456789"
001813  002017        
001814  002018  func isxdigit("char"), 1;    //Returns a 1 if the character is an ascii hexadecimal digit else returns a 0
001815  002019  // Syntax: isxdigit("char");
001816  002020  // Usage : Var := isxdigit(ch);
001817  002021  // Notes : char specifies the ascii character for the test
001818  002022  //     : 0 : char is not an ascii hexadecimal digit.
001819  002023  //     : 1 : char is an ascii hexadecimal digit..
001820  002024  //     : Valid range is "0123456789ABCDEF"
001821  002025        
001822  002026  func isupper("char"), 1;    //Returns a 1 if the character is an ascii upper case letter else returns a 0
001823  002027  // Syntax: isupper("char");
001824  002028  // Usage : Var := isupper(ch);
001825  002029  // Notes : char specifies the ascii character for the test
001826  002030  //     : 0 : char is not an ascii upper-case letter.
001827  002031  //     : 1 : char is an ascii upper-case letter.
001828  002032  //     : Valid range is "ABCD....WXYZ"
001829  002033        
001830  002034  func islower("char"), 1;    //Returns a 1 if the character is an ascii lower case letter else returns a 0
001831  002035  // Syntax: islower("char");
001832  002036  // Usage : Var := islower(ch);
001833  002037  // Notes : char specifies the ascii character for the test
001834  002038  //     : 0 : char is not an ascii lower-case letter.
001835  002039  //     : 1 : char is an ascii lower-case letter.
001836  002040  //     : Valid range is "abcd....wxyz"
001837  002041        
001838  002042  func isalpha("char"), 1;    //Returns a 1 if the character is an ascii lower or upper case letter else returns a 0
001839  002043  // Syntax: isalpha("char");
001840  002044  // Usage : Var := isalpha(ch);
001841  002045  // Notes : char specifies the ascii character for the test
001842  002046  //     : 0 : char is not an ascii lower or upper case letter.
001843  002047  //     : 1 : char is an ascii lower or upper case letter.
001844  002048  //     : Valid range is "ABCD...XYZ", "abcd....wxyz"
001845  002049        
001846  002050  func isalnum("char"), 1;    //Returns a 1 if the character is an ascii alpha numeric else returns a 0
001847  002051  // Syntax: isalnum("char");
001848  002052  // Usage : Var := isalnum(ch);
001849  002053  // Notes : char specifies the ascii character for the test
001850  002054  //     : 0 : char is not an ascii alphanumeric character.
001851  002055  //     : 1 : char is an ascii alphanumeric character.
001852  002056  //     : Valid range is "ABCD...XYZ", "abcd....wxyz", "0123456789"
001853  002057        
001854  002058  func isprint("char"), 1;    //Returns a 1 if the character is a printible ascii char else returns a 0
001855  002059  // Syntax: isprint("char");
001856  002060  // Usage : Var := isprint(ch);
001857  002061  // Notes : char specifies the ascii character for the test
001858  002062  //     : 0 : char is not a printable ascii character.
001859  002063  //     : 1 : char is a printable ascii character.
001860  002064  //     : Valid range is "0x20...0x7F"
001861  002065        
001862  002066  func isspace("char"), 1;    //Returns a 1 if the character is any one of the space type chars else returns a 0
001863  002067  // Syntax: isspace("char");
001864  002068  // Usage : Var := isspace(ch);
001865  002069  // Notes : char specifies the ascii character for the test
001866  002070  //     : 0 : char is not a space type character.
001867  002071  //     : 1 : char is a space type character.
001868  002072  //     : Valid range is space, formfeed, newline, carriage return, tab, vertical tab
001869  002073        
001870  002074  //unformatted
001871  002075  func iswhite("char"), 1;    //
001872  002076  // Syntax: iswhite("char");
001873  002077  // Usage : Var := iswhite(ch);
001874  002078  // Notes : char specifies the ascii character for the test
001875  002079  //     : 0 : char is not a space or tab character.
001876  002080  //     : 1 : char is not a space or tab character.
001877  002081  //     : Valid range is space or tab
001878  002082        
001879  002083  func toupper("char"), 1; //if character is lower case it returns the upper case equivalent else returns the passed char
001880  002084  // Syntax: toupper("char");
001881  002085  // Usage : Var := toupper(ch);
001882  002086  // Notes : char specifies the ascii character for the test
001883  002087  //     : "ABCD....XYZ" : if character is a lower case letter.
001884  002088  //     : char : if character is not a lower case letter.
001885  002089  //     : Valid range is "abcd....wxyz"
001886  002090        
001887  002091  func tolower("char"), 1; //if character is upper case it returns the lower case equivalent else returns the passed char
001888  002092  // Syntax: tolower("char");
001889  002093  // Usage : Var := tolower(ch);
001890  002094  // Notes : char specifies the ascii character for the test
001891  002095  //     : "abcd....xyz" : if character is an upper case letter.
001892  002096  //     : char : if character is not an upper case letter.
001893  002097  //     : Valid range is "ABCD....WXYZ"
001894  002098        
001895  002099  func LObyte("var"), 1;        //Returns the lower byte (lower 8 bits) of a 16 bit variable.
001896  002100  // Syntax: LObyte(var);
001897  002101  // Usage : myVar := LObyte(myvar2);
001898  002102  // Notes : var specifies the user variable
001899  002103  //     : Returns the lower byte (lower 8 bits) of a 16 bit variable
001900  002104        
001901  002105  func HIbyte("var"), 1;        //Returns the High byte (upper 8 bits) of a 16 bit variable.
001902  002106  // Syntax: HIbyte(var);
001903  002107  // Usage : myVar := HIbyte(myvar2);
001904  002108  // Notes : var specifies the user variable
001905  002109  //     : Returns the high byte (upper 8 bits) of a 16 bit variable
001906  002110        
001907  002111        
001908  002112  func ByteSwap("var"), 1;    //Returns the swapped upper and lower bytes of a 16 bit variable.
001909  002113  // Syntax: ByteSwap(var);
001910  002114  // Usage : myVar := ByteSwap(myvar2);
001911  002115  // Notes : var specifies the user variable
001912  002116  //     : Returns the endian swapped value of a 16 bit variable
001913  002117        
001914  002118        
001915  002119  //------------------------------------------------------------------//
001916  002120  //        Memory Allocation Function Prototypes
001917  002121  //------------------------------------------------------------------//
001918  002122        
001919  002123  func mem_Alloc("size"), 1;
001920  002124  // Syntax: mem_Alloc(bytesize);
001921  002125  // Usage : myvar := mem_Alloc(100);
001922  002126  // Notes : Allocate a block of memory to pointer myvar
001923  002127  //       : The allocated memory contains garbage but is a fast allocation.
001924  002128  //       : The block must later be released with mem_Free();
001925  002129  //       : returns 0 if function fails
001926  002130        
001927  002131  func mem_AllocV("size"), 1;
001928  002132  // Syntax: mem_AllocV(bytesize);
001929  002133  // Usage : myvar := mem_AllocV(100);
001930  002134  // Notes : Allocate a block of memory to pointer myvar
001931  002135  //       : The block of memory is filled with signature values
001932  002136  //       : the block starts with A5,5A then fills with incrementing
001933  002137  //       : number eg:- A5,5A,00,01,02,03...FF,00,11....
001934  002138  //       : This can be helpful when debugging
001935  002139  //       : The block must later be released with mem_Free();
001936  002140  //       : returns 0 if function fails
001937  002141        
001938  002142  func mem_AllocZ("size"), 1;
001939  002143  // Syntax: mem_AllocZ(bytesize);
001940  002144  // Usage : myvar := mem_AllocC(100);
001941  002145  // Notes : Allocate a zeroed block of memory to pointer myvar
001942  002146  //       : The block of memory is filled with zeroes
001943  002147  //       : The block must later be released with mem_Free();
001944  002148  //       : returns 0 if function fails
001945  002149        
001946  002150  func mem_Realloc("ptr", "size"), 1;
001947  002151  // Syntax: myvar := mem_Realloc("ptr", "size");
001948  002152  // Usage : myvar := mem_Realloc(ptr, size);
001949  002153  // Notes : The function may move the memory block to a new location,
001950  002154  //       : in which case the new location is returned.
001951  002155  //       : The content of the memory block is preserved up to the lesser
001952  002156  //       : of the new and old sizes, even if the block is moved.
001953  002157  //       : If the new size is larger, the value of the newly allocated
001954  002158  //       : portion is indeterminate. In case that ptr is NULL,
001955  002159  //       : the function behaves exactly as mem_Alloc, assigning a new block
001956  002160  //       : of size bytes and returning a pointer to the beginning of it.
001957  002161  //       : In case that the size is 0, the memory previously allocated in
001958  002162  //       : ptr is deallocated as if a call to mem_Free()was made, and a NULL
001959  002163  //       : pointer is returned.
001960  002164        
001961  002165  func mem_Free("allocation"), 1;
001962  002166  // Syntax: myvar := mem_Free(allocation);
001963  002167  // Usage : myvar := mem_Free(myvar);
001964  002168  // Notes : De-allocate a block of memory previously created with
001965  002169  //       : mem_Alloc(...), mem_AllocV(...); or mem_AllocZ(...);
001966  002170  //       : returns 0 if function fails
001967  002171        
001968  002172  func mem_Heap(), 1;
001969  002173  // Syntax: myvar := mem_Heap();
001970  002174  // Usage : myvar := mem_Heap();
001971  002175  // Notes : returns bytecount available in heap
001972  002176  //       :
001973  002177        
001974  002178  func mem_Set("ptr","char","size"), 1;
001975  002179  // Syntax: mem_Set(ptr,char,bytesize);
001976  002180  // Usage : mem_Set(p, 'A', 100);
001977  002181  // Notes : fill a block of memory with a byte value
001978  002182  //       : returns ptr
001979  002183        
001980  002184  func mem_Copy("src", "dest", "bytecount"), 1;
001981  002185  // Syntax: myvar := mem_Copy(src, dest, bytesize);
001982  002186  // Usage : myvar := mem_Copy(p1, p2, 100);
001983  002187  // Notes : copy a word aligned block of memory from src to dest
001984  002188  //       : Note that count is a byte count, this facilitates
001985  002189  //       : copying word aligned byte arrays when using word
001986  002190  //       : aliggned packed strings.
001987  002191  //       : returns src
001988  002192        
001989  002193  func mem_Compare("ptr1","ptr2","count"), 1;
001990  002194  // Syntax: myvar := mem_Compare(ptr1,ptr2,bytesize);
001991  002195  // Usage : myvar := mem_Compare(p1, p2, 100);
001992  002196  // Notes : compare blocks of memory at src, dest
001993  002197  //       : returns 0 if we have a match
001994  002198        
001995  002199  //------------------------------------------------------------------//
001996  002200  //        FAT16 Function Prototypes
001997  002201  //------------------------------------------------------------------//
001998  002202        
001999  002203  func file_Error(), 1;
002000  002204  // Syntax: myvar := file_Error();
002001  002205  // Usage : e := file_Error();
002002  002206  // Notes : return the most recent file error.
002003  002207  //       :
002004  002208        
002005  002209  func file_Count("filename"), 1;
002006  002210  // Syntax: count := file_Count("filename");
002007  002211  // Usage : count := file_Count("*.4dg");
002008  002212  // Notes : returns number of files found that match the criteria
002009  002213        
002010  002214  func file_Dir("filename"), 1;
002011  002215  // Syntax: count := file_Dir("filename");
002012  002216  // Usage : count := file_Dir("*.4dg");
002013  002217  // Notes : streams a string of filenames that agree with the search key
002014  002218  //       : returns number of files found that match the criteria
002015  002219        
002016  002220  func file_FindFirst("fname"), 1;
002017  002221  // Syntax: res := file_FindFirst("fname");
002018  002222  // Usage : if (file_FindFirst("*.4xe") ....
002019  002223  // Notes : returns true if at least 1 file exists
002020  002224  //       : that satisfies the file argument.
002021  002225  //       : Wildcards are usually used so if
002022  002226  //       : file_FindFirst returns true, further
002023  002227  //       : tests can be made using file_FindNext();
002024  002228  //       : to find all the files that match the
002025  002229  //       : wildcard class. Note that the stream behaviour
002026  002230  //       : is the same as file_Dir.
002027  002231  //       :
002028  002232        
002029  002233  func file_FindNext(), 1;
002030  002234  // Syntax: res := file_FindNext();
002031  002235  // Usage : while ((file_FindNext()) ....
002032  002236  // Notes : returns true if more file exists
002033  002237  //       : that satisfies the file argument
002034  002238  //       : that was given for  file_FindFirst.
002035  002239  //       : Wildcards must be used for
002036  002240  //       : file_FindFirst, else this function will
002037  002241  //       : always return zero as the only occurence
002038  002242  //       : will have already been found.
002039  002243  //       : Note that the stream behaviour
002040  002244  //       : is the same as file_Dir.
002041  002245  //       :
002042  002246        
002043  002247  func file_Exists("fname"), 1;
002044  002248  // Syntax: res := file_Exists("fname"),
002045  002249  // Usage : if(file_Exists("myfile") ....
002046  002250  // Notes : returns true if file exists
002047  002251  //       :
002048  002252        
002049  002253  func file_Open("fname", "mode"), 1;
002050  002254  // Syntax: handle := file_Open("fname","mode"),
002051  002255  // Usage : handle := file_Open("myfile.txt", 'r');
002052  002256  // Notes : returns handle if file exists
002053  002257  //       :
002054  002258        
002055  002259  func file_Close("handle"), 1;
002056  002260  // Syntax: res := file_Close("handle");
002057  002261  // Usage : res := file_Close(hnd1);
002058  002262  // Notes : returns true if file closed ok
002059  002263  //       :
002060  002264        
002061  002265  func file_Read("*dest", "size", "handle"), 1;
002062  002266  // Syntax: res := file_Read("*dest", "size", "handle"),
002063  002267  // Usage : res := file_Read(memblock,20,hnd1);
002064  002268  // Notes : returns number of characters read
002065  002269  //       : if "dest" is zero, data is read direct to GRAM window
002066  002270  //       :
002067  002271        
002068  002272        
002069  002273  func file_Seek("handle", "HiWord", "LoWord"), 1;
002070  002274  // Syntax: res := file_Seek("handle", "HiWord", "LoWord")
002071  002275  // Usage : res := file_Seek(hSource, 0, 0x1234);
002072  002276  // Notes : set file position to 0x00001234 (byte position 4660)
002073  002277  //       : for the file handle so subsequent data may be read
002074  002278  //       : from that position onwards with file_GetC(...),
002075  002279  //       : file_GetW(...) or file_GetS(...), or an image
002076  002280  //       : can be displayed with file_Image(...)
002077  002281  // Notes : returns true if ok, usually ignored
002078  002282        
002079  002283  func file_Index("handle", "HiSize", "LoSize","recordnum"), 1;
002080  002284  // Syntax: file_Index("handle", "HiSize", "LoSize","recordnum"), 1;
002081  002285  // Usage : res := file_Index(hsource, 0, 1000, 123), 1;
002082  002286  // Notes : set file seek position to 123000
002083  002287  //       : for the file handle so subsequent data may be read
002084  002288  //       : from that record position onwards with file_GetC(...),
002085  002289  //       : file_GetW(...) or file_GetS(...), or an image
002086  002290  //       : can be displayed with file_Image(...)
002087  002291  // Notes : returns true if ok, usually ignored
002088  002292        
002089  002293  func file_Tell("handle", "&HiWord", "&LoWord"), 1;
002090  002294  // Syntax: file_Tell("handle", &HiWord, &LoWord);
002091  002295  // Usage : file_Tell(fhndl, &SizeHi, &SizeLo);
002092  002296  // Notes : Reads the 32 bit file pointer and stores it into 2 variables.
002093  002297  //       : returns true if function succeeded
002094  002298        
002095  002299  func file_Write("*source", "size", "handle"), 1;
002096  002300  // Syntax: res := fwrite("*source", "size", "handle"),
002097  002301  // Usage : res := fwrite(memblock, 20, hnd1);
002098  002302  // Notes : returns number of bytes written
002099  002303  //       :
002100  002304        
002101  002305  func file_Size("handle", "&HiWord", "&LoWord"), 1;
002102  002306  // Syntax: file_Size("handle", &HiWord, &LoWord);
002103  002307  // Usage : file_Size(fhndl, &SizeHi, &SizeLo);
002104  002308  // Notes : Reads the 32 bit file size and stores it into 2 variables.
002105  002309  //       : returns true if function succeeded
002106  002310        
002107  002311  func file_Image("x", "y", "handle"), 1;
002108  002312  // Syntax: file_Image(x, y, handle);
002109  002313  // Usage : file_Image(10, 10, hnd1);
002110  002314  // Notes : Display an image from a file at the current file position.
002111  002315  //       : The image is displayed at x,y (with respect to top left corner).
002112  002316  //       : If there is more than 1 image in the file, it can be
002113  002317  //       : accessed with file_Seek(...)
002114  002318        
002115  002319  func file_ScreenCapture("x", "y", "width", "height", "handle"), 1;
002116  002320  // Syntax: file_ScreenCapture(x, y, w, h, handle);
002117  002321  // Usage : file_ScreenCapture(10, 10, 50,50, hnd1);
002118  002322  // Notes : Save a image from screen to file at the current file position.
002119  002323  //       : The image can later be displayed with file_Image(...);
002120  002324  //       : The file may be opened in append mode to accumulate multiple
002121  002325  //       : images. Later, the images can be accessed with file_Seek(...);
002122  002326  //       : Note that the image will be sector aligned.
002123  002327  //       : All image headers must start on a sector boundary.
002124  002328  //       : The image is saved from x, y (with respect to top left corner)
002125  002329  //       : and the capture area is determined by "width" and "height".
002126  002330  //       : returns 0 if function succeeded
002127  002331        
002128  002332  func file_PutC("char","handle"), 1;
002129  002333  // Syntax: file_PutC("char", "handle");
002130  002334  // Usage : file_PutC('x', hndl);
002131  002335  // Notes : returns true if function succeeded
002132  002336        
002133  002337  func file_GetC("handle"), 1;
002134  002338  // Syntax: file_GetC("handle");
002135  002339  // Usage : mychar := fgetC("handle");
002136  002340  // Notes : returns next char from file
002137  002341        
002138  002342  func file_PutW("word","handle"), 1;
002139  002343  // Syntax: file_PutW("word","handle");
002140  002344  // Usage : file_PutW(0x1234, hndl);
002141  002345  // Notes : returns true if function succeeded
002142  002346        
002143  002347  func file_GetW("handle"), 1;
002144  002348  // Syntax: file_GetW("handle");
002145  002349  // Usage : myword := fgetW("handle");
002146  002350  // Notes : returns next word in file
002147  002351        
002148  002352  func file_PutS("*source", "handle"), 1;
002149  002353  // Syntax: res := file_Puts("*source", "handle"),
002150  002354  // Usage : res := file_Puts(mystring, hnd1);
002151  002355  // Notes : returns number of characters written
002152  002356  //       :
002153  002357        
002154  002358  func file_GetS("*string", "size", "handle"), 1;
002155  002359  // Syntax: res := file_Gets("*string", "size", "handle");
002156  002360  // Usage : res := file_Gets(mystr , 81, hnd1); // read up to 80 chars
002157  002361  // Notes : get a string from a file
002158  002362  //       : returns pointer to string or null if failed.
002159  002363  //       : file_GetS(...) automatically appends a null-terminator to the data read.
002160  002364  //       : NB:- only reads up to "size-1" characters into "string"
002161  002365  //       : file_GetS(...) will stop reading when any of the following conditions are true:
002162  002366  //       : A] It has read n-1 bytes (one character is reserved for the null-terminator)
002163  002367  //       : B] It encounters a newline character (a line-feed in the compilers tested here), or
002164  002368  //       : C] It reaches the end of file
002165  002369  //       : D] A read error occurs.
002166  002370        
002167  002371        
002168  002372  func file_Erase("fname"), 1;
002169  002373  // Syntax: res := file_Erase("fname");
002170  002374  // Usage : res := file_Erase("myfile.txt");
002171  002375  // Notes : returns true if successful
002172  002376  //       :
002173  002377        
002174  002378  func file_Rewind("handle"), 1;
002175  002379  // Syntax: res := file_Rewind("handle");
002176  002380  // Usage : res := file_Rewind(hnd1);
002177  002381  // Notes : returns true if file rewound ok (usually ignored)
002178  002382  //       : resets the file pointer the the beginning of the open file.
002179  002383        
002180  002384  func file_LoadFunction("fname.4xe"), 1;
002181  002385  // Syntax: res := file_LoadFunction("fname.4fn");
002182  002386  // Usage : myfunc := file_LoadFunction(myfuncname);
002183  002387  // Notes : Load a function or program from disk and
002184  002388  //       : return a function pointer to the allocation.
002185  002389  //       : The function can then be invoked just like any other
002186  002390  //       : function would be called via a function pointer.
002187  002391  //       : Parameters may be passed to it in a conventional way.
002188  002392  //       : The function may be discarded at any time when no
002189  002393  //       : longer required, thus freeing its memory resources.
002190  002394  //       : The loaded function can be discarded with mem_Free(..)
002191  002395  //       : eg:
002192  002396  //       : popupWindow := file_LoadFunction("popupWindow1.4fn");
002193  002397  //       : if(!popupWindow) goto LoadFunctionFailed; // could not load the function !!!
002194  002398  //       : then elsewhere in your program:-
002195  002399  //       : res := popupWindow(MYMODE,"My Title","My Popup Text");
002196  002400  //       : if(res == QUIT_APPLICATION) goto exitApp;
002197  002401  //       : Later in your program, when popupWindow is no longer
002198  002402  //       : required for the application:-
002199  002403  //       : res := mem_Free(popupWindow);
002200  002404  //       : if(!res) goto FreeFunctionFailed; // should never happen if memory not corrupted
002201  002405  //       : The callers stack is shared by the loaded function,
002202  002406  //       : however any global variables in the loaded function
002203  002407  //       : are private to that function.
002204  002408  //
002205  002409        
002206  002410  func file_Run("fname.4xe", "arglistptr"), 1;
002207  002411  // Syntax: res := file_Run("fname.4xe","arglistptr");
002208  002412  // Usage : res := file_Run(fname, argptr);
002209  002413  // Notes : current program releases any allocated memory but
002210  002414  //       : retains the stack and global memory.
002211  002415  //       : If arglistptr is 0, no arguments are passed, else
002212  002416  //       : arglist points to an array, the first element being
002213  002417  //       : the number of elements in the array.
002214  002418  //       : func 'main' in the called program accepts
002215  002419  //       : the arguments, if any. THe arguments can only
002216  002420  //       : be passed by value, no pointers or references can be
002217  002421  //       : used as all memory is cleared before the file
002218  002422  //       : is loaded. Refer to file_Exec and file_LoadFunction
002219  002423  //       : for functions that can pass by reference.
002220  002424        
002221  002425  func file_Exec("fname.4xe", "arglistptr"), 1;
002222  002426  // Syntax: res := file_Exec("fname.4xe","arglistptr");
002223  002427  // Usage : res := file_Exec("fname.4xe","arglistptr");
002224  002428  // Notes : returns like a function, current program
002225  002429  //       : calling program is kept active and control returns to it.
002226  002430  //       : If arglistptr is 0, no arguments are passed, else
002227  002431  //       : arglist points to an array, the first element being
002228  002432  //       : the number of elements in the array.
002229  002433  //       : func 'main' in the called program accepts the arguments.
002230  002434  //       : This function is similar to file_LoadFunction(...), however,
002231  002435  //       : the function argument list is passed by pointer, and
002232  002436  //       : the memory consumed by the function is released as
002233  002437  //       : soon as the function completes.
002234  002438        
002235  002439  func file_LoadImageControl("fname1", "fname2", "mode"), 1;
002236  002440  // Syntax: hImagelist := file_LoadImageControl ("controlfile", "imagefile", "mode"),
002237  002441  // Usage : hImagelist := file_LoadImageControl ("resource.dat", "resource.gci", 0);
002238  002442  // Notes : Reads a control file to create an image list.
002239  002443  //       : Returns NULL if function fails.
002240  002444  //       : Returns a handle (pointer to the memory allocation) to the
002241  002445  //       : image control list that has been created.
002242  002446  //       : "fname1" is the control list filename "*.dat"
002243  002447  //       : "fname2" is the image filename "*.gci"
002244  002448        
002245  002449  // Notes : This function Calculates the size of a chunk of memory required for
002246  002450  //       : a image list and populates it from the image control file ("*.dat")
002247  002451  //       : therefore, when imagelist is no longer required, you must de-allocate
002248  002452  //       : the image list memory by using eg:- mem_Free(hImagelist);
002249  002453  //       : to restore the heap.
002250  002454  //       :
002251  002455  //       : mode 0:- it is assumed that there is a graphics file with the
002252  002456  //       : file extension "fname2.gci". In this case, the images have been stored
002253  002457  //       : in a FAT16 file concurrently, and the offsets that ar derived from the
002254  002458  //       : "fname1.dat" file are saved in the image control so that the image control
002255  002459  //       : can open the file (*.gci) and us file_Seek to get to the position of the
002256  002460  //       : image which can then automatically be displayed using file_Image(xpos, ypos, hSource);
002257  002461  //       : mode 0 builds the image control quickly as it only scans the *.dat file
002258  002462  //       : for the file offsets and save them in the relevant entries in the image control.
002259  002463  //       : The penalty is that images take longer to find when displayed due to file_Seek
002260  002464  //       : overheads.
002261  002465  //
002262  002466  //       : mode 1:- it is assumed that there is a graphics file with the
002263  002467  //       : file extension "fname2.gci". In this case, the images have been stored
002264  002468  //       : in a FAT16 file concurrently, and the offset of the images are saved
002265  002469  //       : in the image control so that image file (*.gci) can be mapped to directly.
002266  002470  //       : The absolute cluster/sector is mapped so file seek does not need to be called
002267  002471  //       : internally. This means that there is no seek time penalty, however, the
002268  002472  //       : image list takes a lot longer to build, as all the seeking is done at control
002269  002473  //       : build time.
002270  002474        
002271  002475  //       : mode 2:- the graphics file with the is placed in a partitioned area
002272  002476  //       : In this case, the images have been stored in a in a known raw area of the FAT16
002273  002477  //       : disk, and the absolute address of the images are saved in the DAT file
002274  002478  //       : This is the fastest operation of the image control as there is no seeking
002275  002479  //       : or other disk activity taking place.
002276  002480        
002277  002481  func file_Mount(), 1;
002278  002482  // Syntax: r := file_Mount();
002279  002483  // Usage : r := file_Mount();
002280  002484  // Notes : Create a control block for FAT16 and mount the File System
002281  002485        
002282  002486  func file_Unmount(), 0;
002283  002487  // Syntax: file_Unmount();
002284  002488  // Usage : file_Unmount();
002285  002489  // Notes : release any control block and buffers for FAT16
002286  002490  //       : and unmount the File System
002287  002491        
002288  002492  func file_PlayWAV("fname1"), 1;
002289  002493  // Syntax: file_PlayWAV("fname1");
002290  002494  // Usage : file_PlayWAV("ding.wav");
002291  002495  // Notes : Play a wave file with filename "fname1"
002292  002496  //       : This function automatically grabs a chunk
002293  002497  //       : of memory for a file buffer, and a wave
002294  002498  //       : buffer. The minimum memory requirement is
002295  002499  //       : about 580 bytes for the disk io service and
002296  002500  //       : a minimum wave buffer size of 1024. The siz
002297  002501  //       : of the wave buffer allocation
002298  002502  //       : can be increased by the snd_BufSize function.
002299  002503  //       : The default size 1024 bytes.
002300  002504  //       : NB the memory is only required during the
002301  002505  //       : duration of play, and is automatically
002302  002506  //       : released while not in use.
002303  002507  //       : See the Sound Class services for other associated controls.
002304  002508  //       : If there are no errors, returns number of blocks to play (1 to 32767)
002305  002509  //       : If errors occured, the folling is returned
002306  002510  //       : -7  : Insufficient memory available for WAV buffer and file
002307  002511  //       : -6  : cant play this rate
002308  002512  //       : -5  : no data chunk found in first rsector
002309  002513  //       : -4  : no format data
002310  002514  //       : -3  : no wave chunk signature
002311  002515  //       : -2  : bad wave file format
002312  002516  //       : -1  : file not found
002313  002517        
002314  002518        
002315  002519        
002316  002520  //------------------------------------------------------------------//
002317  002521  //        Sound Class Services
002318  002522  //------------------------------------------------------------------//
002319  002523        
002320  002524  func snd_Volume("var"), 0;
002321  002525  // Syntax: snd_Volume("var");
002322  002526  // Usage : snd_Volume(30);
002323  002527  // Notes : set sound playback volume.  Var must
002324  002528  //       : be in the range from 8 (min volume)
002325  002529  //       : to 127 (max volume). If var is less
002326  002530  //       : than 8 volume is set to 8, and if
002327  002531  //       : var > 127 it is set to 127.
002328  002532        
002329  002533  func snd_Pitch("pitch"), 1;
002330  002534  // func snd_Pitch("freq"), 1;
002331  002535  // func snd_Pitch(7000), 1; // play the wave file with a sample frequency of 7khz
002332  002536  // Notes : sets the samples playback rate to a different frequency
002333  002537  //       : The minimum value is 4khz
002334  002538  //       : Setting the pitch to zero restores the original sample rate
002335  002539  //       : Return value is the samples original sample rate.
002336  002540        
002337  002541  func snd_BufSize("var"), 0;
002338  002542  // Syntax: snd_BufSize("var");
002339  002543  // Usage : snd_BufSize(2);
002340  002544  // Notes : specify the a memory chunk size for the wavefile buffer.
002341  002545  //       : default size 1024 bytes.
002342  002546  //       : 0 = 1024 bytes (default)
002343  002547  //       : 1 = 2048 bytes
002344  002548  //       : 2 = 4096 bytes
002345  002549  //       : 3 = 8192 bytes
002346  002550        
002347  002551  func snd_Stop(), 0;
002348  002552  // Syntax: snd_Stop();
002349  002553  // Usage : snd_Stop();
002350  002554  // Notes : stop any sound that is playing, releasing
002351  002555  //       : buffers and closes any open wav file.
002352  002556        
002353  002557  func snd_Pause(), 0;
002354  002558  // Syntax: snd_Pause();
002355  002559  // Usage : snd_Pause();
002356  002560  // Notes : pauses any sound that is playing, does nothing
002357  002561  //       : until sound is resumed with snd_Continue().
002358  002562  //       : The sample cam be terminated with snd_Stop.
002359  002563  //       : buffers and closes any open wav file.
002360  002564        
002361  002565  func snd_Continue(), 0;
002362  002566  // Syntax: snd_Continue();
002363  002567  // Usage : snd_Continue();
002364  002568  // Notes : resume any sound that is paused by snd_Pause.
002365  002569        
002366  002570  func snd_Playing(), 1;
002367  002571  // Syntax: snd_Playing();
002368  002572  // Usage : r := snd_Playing();
002369  002573  // Notes : returns 0 if sound has finished playing,
002370  002574  //       : else return number of 512 byte blocks to go.
002371  002575        
002372  002576        
002373  002577        
002374  002578  //------------------------------------------------------------------//
002375  002579  //        String Class Services
002376  002580  //------------------------------------------------------------------//
002377  002581        
002378  002582  func str_Ptr("&var"), 1;
002379  002583  // Syntax: str_Ptr(&var);
002380  002584  // Usage : p := str_Ptr(&var);
002381  002585  // Notes : return a byte pointer to a word region
002382  002586        
002383  002587  func str_GetD("&ptr", "&var"), 1;
002384  002588  // Syntax: str_GetD(&ptr, &var);
002385  002589  // Usage : ok := str_GetD(&ptr, &var);
002386  002590  // Notes : convert number in a string to DWORD ( myvar[2] )
002387  002591  //       : returns true if function succeeds, advancing ptr
002388  002592        
002389  002593  func str_GetW("&ptr", "&var"), 1;
002390  002594  // Syntax: str_GetW(&ptr, &var);
002391  002595  // Usage : ok := str_GetW(&ptr, &var);
002392  002596  // Notes : convert number in a string to WORD ( myvar )
002393  002597  //       : returns true if function succeeds, advancing ptr
002394  002598        
002395  002599  func str_GetHexW("&ptr", "&var"), 1;
002396  002600  // Syntax: str_GetHexW(&ptr, &var);
002397  002601  // Usage : ok := str_GetHexW(&ptr, &var);
002398  002602  // Notes : convert HEX number in a string to WORD ( myvar )
002399  002603  //       : returns true if function succeeds, advancing ptr
002400  002604        
002401  002605  func str_GetC("&ptr", "&var"), 1;
002402  002606  // Syntax: str_GetC(&ptr, &var);
002403  002607  // Usage : ok := str_GetC(&ptr, &var);
002404  002608  // Notes : get a valid ascii char in a string to WORD ( myvar )
002405  002609  //       : returns true if function succeeds, advancing ptr
002406  002610        
002407  002611  func str_GetByte("ptr"), 1;
002408  002612  // Syntax: str_GetByte(ptr);
002409  002613  // Usage : myvar := str_GetByte(ptr);
002410  002614  // Notes : get a byte to myvar
002411  002615  //       : returns value
002412  002616        
002413  002617  func str_GetWord("ptr"), 1;
002414  002618  // Syntax: GetWord(ptr);
002415  002619  // Usage : GetWord(ptr);
002416  002620  // Notes : get a word to myvar
002417  002621  //       : returns value
002418  002622        
002419  002623  func str_PutByte("ptr","val"), 0;
002420  002624  // Syntax: str_PutByte(ptr);
002421  002625  // Usage : myvar := str_PutByte(ptr);
002422  002626  // Notes : put a byte at ptr
002423  002627  //       : returns value
002424  002628        
002425  002629  func str_PutWord("ptr","val"), 0;
002426  002630  // Syntax: str_PutWord("ptr","val");
002427  002631  // Usage : str_PutWord(p,100);
002428  002632  // Notes : put word 100 at current pointer location
002429  002633  //       : returns value
002430  002634        
002431  002635  func str_Match("&ptr", "*str"), 1;
002432  002636  // Syntax: str_Match(&ptr, *str);
002433  002637  // Usage : r := str_Match(&p, "hello");
002434  002638  // Notes : Case sensitive match
002435  002639  //       : returns true if function succeded, andvancing pointer to position past
002436  002640  //       : the matched item. Note that any whitespace characters are skipped
002437  002641  //       : in the source string prior to the test.
002438  002642        
002439  002643  func str_MatchI("&ptr", "*str"), 1;
002440  002644  // Syntax: str_MatchI(&ptr, *str);
002441  002645  // Usage : r := str_MatchI(&p, "hello");
002442  002646  // Notes : Case insensitive match
002443  002647  //       : returns true if function succeded, andvancing pointer to position past
002444  002648  //       : the matched item. Note that any whitespace characters are skipped
002445  002649  //       : in the source string prior to the test.
002446  002650        
002447  002651  func str_Find("&ptr", "*str"), 1;
002448  002652  // Syntax: str_Find(&ptr, *str);
002449  002653  // Usage : n := str_Find(&p, "hello");
002450  002654  // Notes : given the address of a pointer to a source string as the
002451  002655  //       : first argument, and a pointer to a test string as the second
002452  002656  //       : argument, attempt to find the position of the matching string
002453  002657  //       : in the source string. The test is performed with case sensitivity.
002454  002658  //       : return 0 if not found, else returns the address of the first
002455  002659  //       : character of the match. NB:- The source pointer is not altered.
002456  002660        
002457  002661  func str_FindI("&ptr", "*str"), 1;
002458  002662  // Syntax: str_Find(&ptr, *str);
002459  002663  // Usage : n := str_Find(&p, "hello");
002460  002664  // Notes : given the address of a pointer to a source string as the
002461  002665  //       : first argument, and a pointer to a test string as the second
002462  002666  //       : argument, attempt to find the position of the matching string
002463  002667  //       : in the source string. The test is performed with no case
002464  002668  //       : sensitivity, eg upper and lower case chars are accepted.
002465  002669  //       : return 0 if not found, else returns the address of the first
002466  002670  //       : character of the match. NB:- The source pointer is not altered.
002467  002671        
002468  002672  func str_Length("ptr"), 1;
002469  002673  // Syntax: str_Length(ptr);
002470  002674  // Usage : len := str_Ptr(mystring);
002471  002675  // Notes : return the length of a byte aligned string excluding terminator
002472  002676        
002473  002677  func str_Printf("&ptr", "*format"), 1;
002474  002678  // Syntax: str_Printf("&ptr", "*format");
002475  002679  // Usage : r := str_Printf(&p, "hello");
002476  002680  // Notes : refer to documentation
002477  002681  //       :
002478  002682        
002479  002683  func str_Cat("dest","src"), 1;
002480  002684  // Syntax: str_Append("&dest","&src");
002481  002685  // Usage : str_Append(&buf,"Hello");
002482  002686  // Notes : Appends a copy of the source string to the destination string.
002483  002687  //       : The terminating null character in destination is overwritten by
002484  002688  //       : the first character of source, and a new null-character is appended
002485  002689  //       : at the end of the new string formed by the concatenation of both in destination.
002486  002690  //       : returns destination.
002487  002691        
002488  002692  func str_CatN("dest","src","count"), 1;
002489  002693  // Syntax: str_Append("&dest","&src","count");
002490  002694  // Usage : str_Append(&buf,"Monday",3);
002491  002695  // Notes : Appends a copy of the source string to the destination string.
002492  002696  //       : The number of characters copied is limited by "count".
002493  002697  //       : The terminating null character in destination is overwritten by
002494  002698  //       : the first character of source, and a new null-character is appended
002495  002699  //       : at the end of the new string formed by the concatenation of both in destination.
002496  002700  //       : returns destination.
002497  002701        
002498  002702        
002499  002703  func sys_StoreTouchCalibration(), 1;
002500  002704  // Syntax: sys_StoreTouchCalibration();
002501  002705  // Usage : r := sys_StoreTouchCalibration();
002502  002706  // Notes : Store the touch calibration values in non-volatile memory.
002503  002707  //       : Returns true if the values have been accepted and stored,
002504  002708  //       : else returns false if write could not be performed, or
002505  002709  //       : touch calibration values are improbable.
002506  002710  //       : The values that are stored are obtained from:-
002507  002711  //     : TOUCH_XMINCAL             78  // touch calibration value
002508  002712  //     : TOUCH_YMINCAL             79  // touch calibration value
002509  002713  //       : TOUCH_XMAXCAL             80  // touch calibration value
002510  002714  //       : TOUCH_YMAXCAL             81  // touch calibration value
002511  002715  //       : refer to the 4DGL example touchCalibrate.4DG for further information.
002512  002716  //       : This function is not supported on uVGA, Capicitive touch
002513  002717  //       : and 4.3" resistive touch modules.
002514  002718        
002515  002719        
002516  002720  func unicode_page("charbeg","charend","charoffset"), 1;
002517  002721  // Syntax: unicode_page("charbeg","charend","charoffset");
002518  002722  // Usage : eg:  F_Traditional_0x20_0xFF
002519  002723  // Notes : After selecting a unicode image control with txt_FontID,
002520  002724  //       : this function is called to set the required font within the
002521  002725  //       : unicode set. The file "Unicode.inc" contains wrappers for
002522  002726  //       : this function, and it is not normally called directly.
002523  002727  //       : Returns count of characters in the set.
002524  002728  //       : Refer to "Unicode.inc" for further information.
002525  002729        
002526  002730        
002527  002731  func EVE_SP(), 1;
002528  002732  // Syntax: EVE_SP();
002529  002733  // Usage : eg:  print(EVE_SP());
002530  002734  // Notes : Used for debugging to assess the current stack level,
002531  002735  //       : mainly for checking stack leaks
002532  002736        
002533  002737  func EVE_SSIZE(), 1;
002534  002738  // Syntax: EVE_SSIZE();
002535  002739  // Usage : eg:  print(EVE_SSIZE());
002536  002740  // Notes : Used to get the stack size,
002537  002741  //       : mainly for debugging purposes
002538  002742        
002539  002743        
002540  002744  // uVGAII extended functions
002541  002745  func disp_Sync("line"), 0;                      //  (uVGA only)  wait till scanline reaches "line"
002542  002746  // Syntax: disp_Sync(line);
002543  002747  // Usage : disp_Sync(480);
002544  002748  // Notes : Waits till the hardware gets to a certain line.
002545  002749  //       : Allows the program to synchronise writing to the hardware for flicker free operation.
002546  002750  //       : Some experimentation may be needed to find an optimum line for disp_Sync
002547  002751  //       : depending on the graphics operation. The higher the value, the slower
002548  002752  //       : the throughput. A cetain point will be reached (number of scanlines + blanking lines
002549  002753  //       : within the vertical retrace period) where it will just 'hang up' stopping the
002550  002754  //       : entire process. Eg, in 640x480 mode, if the 'lines' value is 507, operation will
002551  002755  //       : be slowest (as its actually right at the end of the blanking period) and 508
002552  002756  //       : will cause a hangup situation as it is above the highes scanline value.
002553  002757  //       : Currently, this function is only supported on displays with SSD1963 driver.
002554  002758        
002555  002759        
002556  002760  // New functions added to PmmC v2.8
002557  002761  //================================================================
002558  002762  func CY(), 1;
002559  002763  // Syntax: CY();
002560  002764  // Usage : myvar := 0xFFF8 + 9;                 // result = 1
002561  002765  //       : print(myvar," "CY(),"\n");           // carry = 1
002562  002766  // Notes : This function returns the carry status of an
002563  002767  // unsigned overflow from any 16 or 32bit additions or sutractions.
002564  002768  //================================================================
002565  002769        
002566  002770        
002567  002771  //================================================================
002568  002772  func str_ByteMove("src", "dest", "count"), 1;
002569  002773  // func str_ByteMove("src", "dest", "count"), 1;
002570  002774  // Syntax   : str_ByteMove(src, dest, bytecount);
002571  002775  // Input    : STR *source points to byte aligned source.
002572  002776  //          : STR *dest   points to byte aligned destination.
002573  002777  //          : VAR count   number of bytes to transfer.
002574  002778  // Usage    : nextpos := str_ByteMove(s, d, 100);
002575  002779  // Notes    : copy bytes from "src" to "dest", stopping only
002576  002780  //          : when "count" is exhausted.
002577  002781  //          : No terminator is appended, it is purely a
002578  002782  //          : byte copy, and any zeroes encountered will
002579  002783  //          : also be copied.
002580  002784  // Returns  : returns a pointer to the end of the destination
002581  002785  //          : (which is "dest" + "count")
002582  002786  //================================================================
002583  002787        
002584  002788        
002585  002789  //================================================================
002586  002790  func str_Copy("dest", "src"), 1;
002587  002791  // Syntax   : str_Copy(dest, src);
002588  002792  // Input    : STR *dest   points to byte aligned destination.
002589  002793  //          : STR *source points to byte aligned source.
002590  002794  // Usage    : nextplace := str_Copy(d, s);
002591  002795  // Notes    : copy a string from "src" to "dest", stopping only
002592  002796  //          : when the end of source string "src" is encountered
002593  002797  //          : (0x00 terminator).
002594  002798  //          : The terminator is always appended, even if "src" is
002595  002799  //          : an empty string.
002596  002800  // Returns  : returns a pointer to the 0x00 string terminator at
002597  002801  //          : end of "dest" (which is "dest" + str_Length(src); )
002598  002802  //================================================================
002599  002803        
002600  002804  //================================================================
002601  002805  func str_CopyN("dest", "src", "count"), 1;
002602  002806  // Syntax   : str_CopyN(dest, src, bytecount);
002603  002807  // Input    : STR *dest   points to byte aligned destination.
002604  002808  //          : STR *source points to byte aligned source.
002605  002809  //          : VAR count   max number of chars to copy.
002606  002810  // Usage    : nextplace := str_CopyN(d, s, 100);
002607  002811  // Notes    : copy a string from "src" to "dest", stopping only
002608  002812  //          : when "count" is exhausted, or end of source
002609  002813  //          : string "str" is encountered (0x00 string terminator).
002610  002814  //          : The terminator is always appended, even if
002611  002815  //          : "count" is zero, or "src" is a null string.
002612  002816  // Returns  : returns a pointer to the 0x00 string terminator
002613  002817  //          : (which is "dest" + whatever was copied)
002614  002818  //================================================================
002615  002819        
002616  002820  //================================================================
002617  002821  func umul_1616("&res32", "val1", "val2"), 1;
002618  002822  // Syntax   : umul_1616(&res32, varA, varB);
002619  002823  // Input    : DWORD *result   points to 32bit result register.
002620  002824  //          : VAR   val1  16bit register or constant
002621  002825  //          : VAR   val2  16bit register or constant
002622  002826  // Usage    : var res32[2];
002623  002827  //          : umul_1616(&res32, myvar, 50000);
002624  002828  // Notes    : performs an unsigned multiply of 2 x 16bit values
002625  002829  //          : placing the 32bit result in a 2 word array.
002626  002830  // Returns  : the pointer to the 32bit result.
002627  002831  //          : carry and overflow are not affected.
002628  002832  //================================================================
002629  002833        
002630  002834  //================================================================
002631  002835  func uadd_3232("&res32", "&val1", "&val2"), 1;
002632  002836  // Syntax   : cmp_3232(&res32, &varA, &varB);
002633  002837  // Input    : DWORD *res32 points to optional result (or zero for compare)
002634  002838  //          : DWORD *val1 points to 32bit augend
002635  002839  //          : DWORD *val2 points to 32bit addend
002636  002840  // Usage    : var res32[2];
002637  002841  //          : res := cmp_3232(res32, val1, val2);
002638  002842  // Notes    : performs an unsigned addition of 2 x 32bit values
002639  002843  //          : placing the 32bit result in a 2 word array.
002640  002844  // Returns  : returns 1 on 32bit unsigned overflow (carry).
002641  002845  //          ; carry flag is also set on 32bit unsigned overflow
002642  002846  //          ; and can be read with the CY() function.
002643  002847  //================================================================
002644  002848        
002645  002849  //================================================================
002646  002850  func usub_3232("&res32", "&val1", "&val2"), 1;
002647  002851  // Syntax   : cmp_3232(&res32, &varA, &varB);
002648  002852  // Input    : DWORD *res32 points to optional result (or zero for compare)
002649  002853  //          : DWORD *val1 points to first 32bit minuend
002650  002854  //          : DWORD *val2 points to 32bit subtrahend
002651  002855  // Usage    : var res32[2];
002652  002856  //          : res := cmp_3232(res32, val1, val2);
002653  002857  // Notes    : performs an unsigned subtraction of 2 x 32bit values
002654  002858  //          : placing the 32bit result in a 2 word array.
002655  002859  // Returns  : returns 1 on 32bit unsigned overflow (borrow).
002656  002860  //          ; carry flag is also set on 32bit unsigned underflow
002657  002861  //          ; and can be read with the CY() function.
002658  002862  //================================================================
002659  002863        
002660  002864  //================================================================
002661  002865  func ucmp_3232("&val1", "&val2"), 1;
002662  002866  // Syntax   : cmp_3232(&varA, &varB);
002663  002867  // Input    : DWORD *val1 points to 32bit minuend
002664  002868  //          : DWORD *val2 points to 32bit sutrahend
002665  002869  // Usage    : res := cmp_3232(val1, val2);
002666  002870  // Notes    : performs an unsigned comparison of 2 x 32bit values.
002667  002871  //          : The result of the subtraction is returned.
002668  002872  // Returns  : 0  if equal
002669  002873  //          : 1  if val1 > val2
002670  002874  //          : -1 if val1 < val2
002671  002875  //          : This function does not affect the carry flag.
002672  002876  //================================================================
002673  002877        
002674  002878  func disp_Disconnect(), 0;                     // Disconnect display to ensure reduced power after disabling peripheral power. New in v3.8
002675  002879  // Syntax: disp_Disconnect();                  New in v3.8
002676  002880  // Usage : disp_Disconnect();
002677  002881  // Notes : Disconnects the display driver pins and/or reconfigures it to achieve
002678  002882  //       : its lowest possible power consumption. Use after disabling peripheral power
002679  002883  //       : to ensure the minimal power usage by the display.
002680  002884  //       : disp_Init() should be used to reinitialise the display.
002681  002885        
002682  002886  func reserved(), 0;                            
002683  002887        
002684  002888  func sys_DeepSleep("units"), 1;
002685  002889  // Syntax: t := sys_DeepSleep("units");       New in v3.8
002686  002890  // Usage : t := sys_DeepSleep(10);
002687  002891  // Notes : sets the display and processor into lowest power mode for a period of time.
002688  002892  //       : When returning from DeepSleep the display should be reinitialised
002689  002893  //       : with disp_Init().
002690  002894  //       : Touching the touch screen will also wake from sleep.
002691  002895  //       : Returns remaining sleep units.
002692  002896        
002693  002897  //------------------------------------------------------------------//
002694  002898  // CONSTANTS
002695  002899  //------------------------------------------------------------------//
002696  002900        
002697  002901  // generic constants
002698  002902  #CONST
002699  002911  #END
002700  002912        
002701  002913  //------------------------------------------------------------------------------
002702  002914  // Pin related constants
002703  002915  //------------------------------------------------------------------------------
002704  002916  #CONST
002705  002934  #END
002706  002935        
002707  002936  //------------------------------------------------------------------------------
002708  002937  //gfx_Set() related constants
002709  002938  //------------------------------------------------------------------------------
002710  002939  #CONST
002711  002956  #END
002712  002957        
002713  002958        
002714  002959  //gfx_Get() related constants
002715  002960  #CONST
002716  002969  #END
002717  002970        
002718  002971        
002719  002972        
002720  002973        
002721  002974  #CONST
002722  002987  #END
002723  002988        
002724  002989        
002725  002990  #CONST
002726  003013  #END
002727  003014        
002728  003015  //------------------------------------------------------------------------------
002729  003016  //txt_Set() related constants
002730  003017  //------------------------------------------------------------------------------
002731  003018  #CONST
002732  003037  #END
002733  003038        
002734  003039        
002735  003040        
002736  003041  //------------------------------------------------------------------------------
002737  003042  //txt_Set() related arguments
002738  003043  // NB:- FONT4 must be inherited if required,
002739  003044  // eg #inherit "FONT4.fnt"
002740  003045  //------------------------------------------------------------------------------
002741  003046  #CONST
002742  003058  #END
002743  003059        
002744  003060        
002745  003061        
002746  003062  //touch_Set() related constants
002747  003063  #CONST
002748  003067  #END
002749  003068        
002750  003069  //touch_Get() related constants
002751  003070  #CONST
002752  003078  #END
002753  003079        
002754  003080  // image control offset related constants
002755  003081  #CONST
002756  003088  #END
002757  003089        
002758  003090  // image attribute flags
002759  003091  // for img_SetAttributes(...) and img_ClearAttributes(...)
002760  003092  #CONST
002761  003106  #END
002762  003107        
002763  003108        
002764  003109  #constant ALL 0xFFFF // argument for img_xxx functions to update all images
002765  003109  #constant ALL 0xFFFF // argument for img_xxx functions to update all images
002766  003110        
002767  003111  // image control entry offsets
002768  003112  #CONST
002769  003127  #END
002770  003128        
002771  003129  #CONST
002772  003147  #END
002773  003148        
002774  003149        
002775  003150        
002776  003151        
002777  003152  #CONST
002778  003172  #END
002779  003173        
002780  003174        
002781  003175        
002782  003176  // timer control  related constants
002783  003177  #CONST
002784  003186  #END
002785  003187        
002786  003188  // I2C timing related constants
002787  003189  #CONST
002788  003193  #END
002789  003194        
002790  003195        
002791  003196  // spi_Init(...)  mode arguments
002792  003197  #CONST
002793  003207  #END
002794  003208        
002795  003209  //------------------------------------------------------------------------------
002796  003210  // system WORD variables accesible with peekW and pokeW or pointer access
002797  003211  // Note that the txt_Set variables (0-15) and gfx_set variables (16-31)
002798  003212  // can also be accessed with peekW and pokeW
002799  003213  //------------------------------------------------------------------------------
002800  003214        
002801  003215  #CONST
002802  003309  #END
002803  003310        
002804  003311  //------------------------------------------------------------------------------
002805  003312  // FILEIO Error Code Constants
002806  003313  //------------------------------------------------------------------------------
002807  003314  #CONST
002808  003340  #END
002809  003341        
002810  003342  //==================================================================================================
002811  003343        
002812  003344        
002813  003345        
002814  000013      #ENDIF
002815  000014        
002816  000015        
002817  000016      #CONST
002818  000072      #END
002819  000073        
002820  000074        
002821  000075  //===========================================================================================
002822  000076        
002823  000077        
002824  000002        
002825  000003  // generated 15/01/2015 14:16:42
002826  000004        
002827  000005  #MODE RUNFLASH
002828  000006        
file C:\Program Files\4D Labs\4D Workshop 4 IDE\include\4DGL_16bitColours.fnc

002829  000007  #inherit "4DGL_16bitColours.fnc"
002830  000007  #inherit "4DGL_16bitColours.fnc"
002831  000004  */
002832  000005        
002833  000006        
002834  000007        
002835  000008  #CONST
002836  000149  #END
002837  000150        
002838  000008        
file C:\Program Files\4D Labs\4D Workshop 4 IDE\include\VisualConst.inc

002839  000009  #inherit "VisualConst.inc"
002840  000009  #inherit "VisualConst.inc"
002841  000001  // Line Patterns
002842  000002  #constant  LPCOARSE    0xF0F0
002843  000002  #constant  LPCOARSE    0xF0F0
002844  000003  #constant  LPMEDIUM    0x3333
002845  000003  #constant  LPMEDIUM    0x3333
002846  000004  #constant  LPFINE      0xAAAA
002847  000004  #constant  LPFINE      0xAAAA
002848  000005  #constant  LPDASHDOT   0x03CF
002849  000005  #constant  LPDASHDOT   0x03CF
002850  000006  #constant  LPDASHDOTDOT 0x0333
002851  000006  #constant  LPDASHDOTDOT 0x0333
002852  000007  #constant  LPSOLID     0x0000
002853  000007  #constant  LPSOLID     0x0000
002854  000010        
002855  000011        
file C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1Const.inc

002856  000012  #inherit "RepRap_Touchv1Const.inc"
002857  000012  #inherit "RepRap_Touchv1Const.inc"
002858  000001  // File generated 15/01/2015 14:16:30
002859  000002  // Warning! This is a generated file, any manual changes will be
002860  000003  // lost during the next generation.
002861  000004        
002862  000005  #constant  Strings0Count    1
002863  000005  #constant  Strings0Count    1
002864  000006  #constant  Strings0Size     28
002865  000006  #constant  Strings0Size     28
002866  000007  #constant  Strings1Count    0
002867  000007  #constant  Strings1Count    0
002868  000008  #constant  Strings1Size     1
002869  000008  #constant  Strings1Size     1
002870  000009  #constant  Strings3Count    1
002871  000009  #constant  Strings3Count    1
002872  000010  #constant  Strings3Size     18
002873  000010  #constant  Strings3Size     18
002874  000011  #constant  Strings13Count    1
002875  000011  #constant  Strings13Count    1
002876  000012  #constant  Strings13Size     25
002877  000012  #constant  Strings13Size     25
002878  000013  #constant  Strings9Count    1
002879  000013  #constant  Strings9Count    1
002880  000014  #constant  Strings9Size     25
002881  000014  #constant  Strings9Size     25
002882  000015  #constant  Strings20Count    1
002883  000015  #constant  Strings20Count    1
002884  000016  #constant  Strings20Size     25
002885  000016  #constant  Strings20Size     25
002886  000017  #constant  Strings5Count    1
002887  000017  #constant  Strings5Count    1
002888  000018  #constant  Strings5Size     13
002889  000018  #constant  Strings5Size     13
002890  000019  #constant  Strings4Count    1
002891  000019  #constant  Strings4Count    1
002892  000020  #constant  Strings4Size     25
002893  000020  #constant  Strings4Size     25
002894  000021  #constant  Strings6Count    1
002895  000021  #constant  Strings6Count    1
002896  000022  #constant  Strings6Size     26
002897  000022  #constant  Strings6Size     26
002898  000023  #constant  Strings2Count    0
002899  000023  #constant  Strings2Count    0
002900  000024  #constant  Strings2Size     1
002901  000024  #constant  Strings2Size     1
002902  000025  #constant  Strings7Count    0
002903  000025  #constant  Strings7Count    0
002904  000026  #constant  Strings7Size     1
002905  000026  #constant  Strings7Size     1
002906  000027  #constant  Strings8Count    1
002907  000027  #constant  Strings8Count    1
002908  000028  #constant  Strings8Size     25
002909  000028  #constant  Strings8Size     25
002910  000029  #constant  Strings10Count    0
002911  000029  #constant  Strings10Count    0
002912  000030  #constant  Strings10Size     1
002913  000030  #constant  Strings10Size     1
002914  000031  #constant  Strings11Count    1
002915  000031  #constant  Strings11Count    1
002916  000032  #constant  Strings11Size     25
002917  000032  #constant  Strings11Size     25
002918  000033  #constant  Strings12Count    1
002919  000033  #constant  Strings12Count    1
002920  000034  #constant  Strings12Size     19
002921  000034  #constant  Strings12Size     19
002922  000035  #constant  Strings14Count    1
002923  000035  #constant  Strings14Count    1
002924  000036  #constant  Strings14Size     23
002925  000036  #constant  Strings14Size     23
002926  000037  #constant  Strings16Count    1
002927  000037  #constant  Strings16Count    1
002928  000038  #constant  Strings16Size     31
002929  000038  #constant  Strings16Size     31
002930  000039  #constant  Strings15Count    1
002931  000039  #constant  Strings15Count    1
002932  000040  #constant  Strings15Size     24
002933  000040  #constant  Strings15Size     24
002934  000041  #constant  Strings17Count    1
002935  000041  #constant  Strings17Count    1
002936  000042  #constant  Strings17Size     33
002937  000042  #constant  Strings17Size     33
002938  000043  #constant  Strings18Count    1
002939  000043  #constant  Strings18Count    1
002940  000044  #constant  Strings18Size     32
002941  000044  #constant  Strings18Size     32
002942  000045  #constant  Strings19Count    1
002943  000045  #constant  Strings19Count    1
002944  000046  #constant  Strings19Size     29
002945  000046  #constant  Strings19Size     29
002946  000047  #constant  Strings21Count    1
002947  000047  #constant  Strings21Count    1
002948  000048  #constant  Strings21Size     30
002949  000048  #constant  Strings21Size     30
002950  000049  #constant  Strings22Count    1
002951  000049  #constant  Strings22Count    1
002952  000050  #constant  Strings22Size     20
002953  000050  #constant  Strings22Size     20
002954  000051  #constant  Strings23Count    1
002955  000051  #constant  Strings23Count    1
002956  000052  #constant  Strings23Size     15
002957  000052  #constant  Strings23Size     15
002958  000053  #constant  Strings24Count    1
002959  000053  #constant  Strings24Count    1
002960  000054  #constant  Strings24Size     26
002961  000054  #constant  Strings24Size     26
002962  000055  #constant  Strings25Count    1
002963  000055  #constant  Strings25Count    1
002964  000056  #constant  Strings25Size     10
002965  000056  #constant  Strings25Size     10
002966  000057  #constant  Strings26Count    1
002967  000057  #constant  Strings26Count    1
002968  000058  #constant  Strings26Size     10
002969  000058  #constant  Strings26Size     10
002970  000059  #constant  Strings27Count    1
002971  000059  #constant  Strings27Count    1
002972  000060  #constant  Strings27Size     11
002973  000060  #constant  Strings27Size     11
002974  000061  // object indexes into ImageControl
002975  000062  #CONST
002976  000208  #END
002977  000209        
002978  000210  #constant  Strings0StartH   0x0
002979  000210  #constant  Strings0StartH   0x0
002980  000211  #constant  Strings0StartL   0x0
002981  000211  #constant  Strings0StartL   0x0
002982  000212  #constant  Strings1StartH   0x0
002983  000212  #constant  Strings1StartH   0x0
002984  000213  #constant  Strings1StartL   0x200
002985  000213  #constant  Strings1StartL   0x200
002986  000214  #constant  Strings3StartH   0x0
002987  000214  #constant  Strings3StartH   0x0
002988  000215  #constant  Strings3StartL   0x400
002989  000215  #constant  Strings3StartL   0x400
002990  000216  #constant  Strings13StartH   0x0
002991  000216  #constant  Strings13StartH   0x0
002992  000217  #constant  Strings13StartL   0x600
002993  000217  #constant  Strings13StartL   0x600
002994  000218  #constant  Strings9StartH   0x0
002995  000218  #constant  Strings9StartH   0x0
002996  000219  #constant  Strings9StartL   0x800
002997  000219  #constant  Strings9StartL   0x800
002998  000220  #constant  Strings20StartH   0x0
002999  000220  #constant  Strings20StartH   0x0
003000  000221  #constant  Strings20StartL   0xA00
003001  000221  #constant  Strings20StartL   0xA00
003002  000222  #constant  Strings5StartH   0x0
003003  000222  #constant  Strings5StartH   0x0
003004  000223  #constant  Strings5StartL   0xC00
003005  000223  #constant  Strings5StartL   0xC00
003006  000224  #constant  Strings4StartH   0x0
003007  000224  #constant  Strings4StartH   0x0
003008  000225  #constant  Strings4StartL   0xE00
003009  000225  #constant  Strings4StartL   0xE00
003010  000226  #constant  Strings6StartH   0x0
003011  000226  #constant  Strings6StartH   0x0
003012  000227  #constant  Strings6StartL   0x1000
003013  000227  #constant  Strings6StartL   0x1000
003014  000228  #constant  Strings2StartH   0x0
003015  000228  #constant  Strings2StartH   0x0
003016  000229  #constant  Strings2StartL   0x1200
003017  000229  #constant  Strings2StartL   0x1200
003018  000230  #constant  Strings7StartH   0x0
003019  000230  #constant  Strings7StartH   0x0
003020  000231  #constant  Strings7StartL   0x1400
003021  000231  #constant  Strings7StartL   0x1400
003022  000232  #constant  Strings8StartH   0x0
003023  000232  #constant  Strings8StartH   0x0
003024  000233  #constant  Strings8StartL   0x1600
003025  000233  #constant  Strings8StartL   0x1600
003026  000234  #constant  Strings10StartH   0x0
003027  000234  #constant  Strings10StartH   0x0
003028  000235  #constant  Strings10StartL   0x1800
003029  000235  #constant  Strings10StartL   0x1800
003030  000236  #constant  Strings11StartH   0x0
003031  000236  #constant  Strings11StartH   0x0
003032  000237  #constant  Strings11StartL   0x1A00
003033  000237  #constant  Strings11StartL   0x1A00
003034  000238  #constant  Strings12StartH   0x0
003035  000238  #constant  Strings12StartH   0x0
003036  000239  #constant  Strings12StartL   0x1C00
003037  000239  #constant  Strings12StartL   0x1C00
003038  000240  #constant  Strings14StartH   0x0
003039  000240  #constant  Strings14StartH   0x0
003040  000241  #constant  Strings14StartL   0x1E00
003041  000241  #constant  Strings14StartL   0x1E00
003042  000242  #constant  Strings16StartH   0x0
003043  000242  #constant  Strings16StartH   0x0
003044  000243  #constant  Strings16StartL   0x2000
003045  000243  #constant  Strings16StartL   0x2000
003046  000244  #constant  Strings15StartH   0x0
003047  000244  #constant  Strings15StartH   0x0
003048  000245  #constant  Strings15StartL   0x2200
003049  000245  #constant  Strings15StartL   0x2200
003050  000246  #constant  Strings17StartH   0x0
003051  000246  #constant  Strings17StartH   0x0
003052  000247  #constant  Strings17StartL   0x2400
003053  000247  #constant  Strings17StartL   0x2400
003054  000248  #constant  Strings18StartH   0x0
003055  000248  #constant  Strings18StartH   0x0
003056  000249  #constant  Strings18StartL   0x2600
003057  000249  #constant  Strings18StartL   0x2600
003058  000250  #constant  Strings19StartH   0x0
003059  000250  #constant  Strings19StartH   0x0
003060  000251  #constant  Strings19StartL   0x2800
003061  000251  #constant  Strings19StartL   0x2800
003062  000252  #constant  Strings21StartH   0x0
003063  000252  #constant  Strings21StartH   0x0
003064  000253  #constant  Strings21StartL   0x2A00
003065  000253  #constant  Strings21StartL   0x2A00
003066  000254  #constant  Strings22StartH   0x0
003067  000254  #constant  Strings22StartH   0x0
003068  000255  #constant  Strings22StartL   0x2C00
003069  000255  #constant  Strings22StartL   0x2C00
003070  000256  #constant  Strings23StartH   0x0
003071  000256  #constant  Strings23StartH   0x0
003072  000257  #constant  Strings23StartL   0x2E00
003073  000257  #constant  Strings23StartL   0x2E00
003074  000258  #constant  Strings24StartH   0x0
003075  000258  #constant  Strings24StartH   0x0
003076  000259  #constant  Strings24StartL   0x3000
003077  000259  #constant  Strings24StartL   0x3000
003078  000260  #constant  Strings25StartH   0x0
003079  000260  #constant  Strings25StartH   0x0
003080  000261  #constant  Strings25StartL   0x3200
003081  000261  #constant  Strings25StartL   0x3200
003082  000262  #constant  Strings26StartH   0x0
003083  000262  #constant  Strings26StartH   0x0
003084  000263  #constant  Strings26StartL   0x3400
003085  000263  #constant  Strings26StartL   0x3400
003086  000264  #constant  Strings27StartH   0x0
003087  000264  #constant  Strings27StartH   0x0
003088  000265  #constant  Strings27StartL   0x3600
003089  000265  #constant  Strings27StartL   0x3600
003090  000266  #IFNOT EXISTS NOGLOBALS
003091  000267  var disk, hndl ;
003092  000268  #ENDIF
003093  000013        
file C:\Program Files\4D Labs\4D Workshop 4 IDE\include\CLPrintStrings.inc

003094  000014  #inherit "CLPrintStrings.inc"
003095  000014  #inherit "CLPrintStrings.inc"
003096  000001  func PrintStrings(var ID, var *msgid, var String)
003097  000002      var StringID, i, ch, offs32[2], res32[2];
003098  000003      StringID := oStringss[1+ID] ;
003099  000004      if (String)
003100  000005          stringsCV[ID] := -1 ;
003101  000006      else
003102  000007          stringsCV[ID] := msgid ;
003103  000008      endif
003104  000009      if ((StringID == -1) || (*(StringID + STForm) != curform)) return ;
003105  000010      txt_FontID(hFonts[ID]) ;
003106  000011      txt_Attributes(*(StringID + STFontAttribs)) ; // >> 4 fix for r25,6,7,8 PmmC
003107  000012  //    txt_Opacity(*(StringID + STTransparent)) ;
003108  000013        
003109  000014      if (*(StringID + STTransparent))
003110  000015          gfx_RectangleFilled(*(StringID + STx1), *(StringID + STy1), *(StringID + STx2), *(StringID + STy2), *(StringID + STBGColor));
003111  000016      else if (formBGcol[curform] != BGIMAGE)
003112  000017          gfx_RectangleFilled(*(StringID + STx1), *(StringID + STy1), *(StringID + STx2), *(StringID + STy2), formBGcol[curform]);
003113  000018      else
003114  000019          gfx_ClipWindow(*(StringID + STx1), *(StringID + STy1), *(StringID + STx2), *(StringID + STy2)) ;
003115  000020          gfx_Clipping(ON) ;
003116  000021          img_Show(hndl,formstidx[curform]) ;
003117  000022          gfx_Clipping(OFF) ;
003118  000023        
003119  000024      endif
003120  000025        
003121  000026      txt_FGcolour(*(StringID + STFGColor)) ;
003122  000027      txt_BGcolour(*(StringID + STBGColor)) ;
003123  000028      txt_Opacity(TRANSPARENT);                // 8  text OPAQUE or TRANSPARENT
003124  000029        
003125  000030      gfx_MoveTo(*(StringID + STx1) , *(StringID + STy1)) ;
003126  000031        
003127  000032      if (String)
003128  000033          i := 0 ;
003129  000034          ch := msgid[i++] ;
003130  000035          while (ch != 0)
003131  000036              putch(ch) ;
003132  000037              ch := msgid[i++] ;
003133  000038          wend
003134  000039      else
003135  000040          umul_1616(offs32, *(StringID + STSize), msgid);
003136  000041          res32[1] := *(StringID + STStartH) ;
003137  000042          res32[0] := *(StringID + STStartL) ;
003138  000043          uadd_3232(res32,res32,offs32) ;
003139  000044          file_Seek(hstrings, res32[1], res32[0]);
003140  000045          repeat
003141  000046              if (*(StringID + STAnsi))
003142  000047                  ch := file_GetC(hstrings) ;
003143  000048              else
003144  000049                  ch := file_GetW(hstrings) ;
003145  000050              endif
003146  000051              putch(ch) ;
003147  000052          until (ch == 0) ;
003148  000053      endif
003149  000054        
003150  000055  endfunc
003151  000056        
003152  000015        
003153  000016  #constant IPDatasize 22
003154  000016  #constant IPDatasize 22
003155  000017        
003156  000018  #CONST
003157  000020  #END
003158  000021        
003159  000022  #CONST
003160  000122  #END
003161  000123        
003162  000363  #END
3163  13DC
3164  13DD
3165  13DE
3166  13DF
3167  13E0
3168  13E1
3169  13E2
3170  13E3
3171  13E4
3172  13E5
3173  13E6
3174  13E7
3175  13E8
3176  13E9
3177  13EA
3178  13EB
3179  13EC
3180  13ED
3181  13EE
3182  13EF
3183  13F0
3184  13F1
3185  13F2
3186  13F3
3187  13F4
3188  13F5
3189  13F6
3190  13F7
3191  13F8
3192  13F9
3193  13FA
3194  13FB
3195  13FC
3196  13FD
3197  13FE
3198  13FF
3199  1400
3200  1401
3201  1402
3202  1403
3203  1404
3204  1405
3205  1406
3206  1407
3207  1408
3208  1409
3209  140A
3210  140B
3211  140C
3212  140D
3213  140E
3214  140F
3215  1410
3216  1411
3217  1412
3218  1413
3219  1414
3220  1415
3221  1416
3222  1417
3223  1418
3224  1419
3225  141A
3226  141B
3227  141C
3228  141D
3229  141E
3230  141F
3231  1420
3232  1421
3233  1422
3234  1423
3235  1424
3236  1425
3237  1426
3238  1427
3239  1428
3240  1429
3241  142A
3242  142B
3243  142C
3244  142D
3245  142E
3246  142F
3247  1430
3248  1431
3249  1432
3250  1433
3251  1434
3252  1435
3253  1436
3254  1437
3255  1438
3256  1439
3257  143A
3258  143B
3259  143C
3260  143D
3261  143E
3262  143F
3263  1440
3264  1441
3265  1442
3266  1443
3267  1444
3268  1445
3269  1446
3270  1447
3271  1448
3272  1449
3273  144A
3274  144B
3275  144C
3276  144D
3277  144E
3278  144F
3279  1450
3280  1451
3281  1452
3282  1453
3283  1454
3284  1455
3285  1456
3286  1457
3287  1458
3288  1459
3289  145A
3290  145B
3291  145C
3292  145D
3293  145E
3294  145F
3295  1460
3296  1461
3297  1462
3298  1463
3299  1464
3300  1465
3301  1466
3302  1467
3303  1468
3304  1469
3305  146A
3306  146B
3307  146C
3308  146D
3309  146E
3310  146F
3311  1470
3312  1471
3313  1472
3314  1473
3315  1474
3316  1475
3317  1476
3318  1477
3319  1478
3320  1479
3321  147A
3322  147B
3323  147C
3324  147D
3325  147E
3326  147F
3327  1480
3328  1481
3329  1482
3330  1483
3331  1484
3332  1485
3333  1486
3334  1487
3335  1488
3336  1489
3337  148A
3338  148B
3339  148C
3340  148D
3341  148E
3342  148F
3343  1490
3344  1491
3345  1492
3346  1493
3347  1494
3348  1495
3349  1496
3350  1497
3351  1498
3352  1499
3353  149A
3354  149B
3355  149C
3356  149D
3357  149E
3358  149F
3359  14A0
3360  14A1
3361  14A2
3362  14A3
3363  14A4
3364  14A5
3365  14A6
3366  14A7
3367  14A8
3368  14A9
3369  14AA
3370  14AB
3371  14AC
3372  14AD
3373  14AE
3374  14AF
3375  14B0
3376  14B1
3377  14B2
3378  14B3
3379  14B4
3380  14B5
3381  14B6
3382  14B7
3383  14B8
3384  14B9
3385  14BA
3386  14BB
3387  14BC
3388  14BD
3389  14BE
3390  14BF
3391  14C0
3392  14C1
3393  14C2
3394  14C3
3395  14C4
3396  14C5
3397  14C6
3398  14C7
3399  14C8
3400  14C9
3401  14CA
3402  14CB
3403  14CC
3404  14CD
3405  14CE
3406  14CF
3407  14D0
3408  14D1
3409  14D2
3410  14D3
3411  14D4
3412  14D5
3413  14D6
3414  14D7
3415  14D8
3416  14D9
3417  14DA
3418  14DB
3419  14DC
3420  14DD
3421  14DE
3422  14DF
3423  14E0
3424  14E1
3425  14E2
3426  14E3
3427  14E4
3428  14E5
3429  14E6
3430  14E7
3431  14E8
3432  14E9
3433  14EA
3434  14EB
3435  14EC
3436  14ED
3437  14EE
3438  14EF
3439  14F0
3440  14F1
3441  14F2
3442  14F3
3443  14F4
3444  14F5
3445  14F6
3446  14F7
3447  14F8
3448  14F9
3449  14FA
3450  14FB
3451  14FC
3452  14FD
3453  14FE
3454  14FF
3455  1500
3456  1501
3457  1502
3458  1503
3459  1504
3460  1505
3461  1506
3462  1507
3463  1508
3464  1509
3465  150A
3466  150B
3467  150C
3468  150D
3469  150E
3470  150F
3471  1510
3472  1511
3473  1512
3474  1513
3475  1514
3476  1515
3477  1516
3478  1517
3479  1518
3480  1519
3481  151A
3482  151B
3483  151C
3484  151D
3485  151E
3486  151F
3487  1520
3488  1521
3489  1522
3490  1523
3491  1524
3492  1525
3493  1526
3494  1527
3495  1528
3496  1529
3497  152A
3498  152B
3499  152C
3500  152D
3501  152E
3502  152F
3503  1530
3504  1531
3505  1532
3506  1533
3507  1534
3508  1535
3509  1536
3510  1537
3511  1538
3512  1539
3513  153A
3514  153B
3515  153C
3516  153D
3517  153E
3518  153F
3519  1540
3520  1541
3521  1542
3522  1543
3523  1544
3524  1545
3525  1546
3526  1547
3527  1548
3528  1549
3529  154A
3530  154B
3531  154C
3532  154D
3533  154E
3534  154F
3535  1550
3536  1551
3537  1552
3538  1553
3539  1554
3540  1555
3541  1556
3542  1557
3543  1558
3544  1559
3545  155A
3546  155B
3547  155C
3548  155D
3549  155E
3550  155F
3551  1560
3552  1561
3553  1562
3554  1563
3555  1564
3556  1565
3557  1566
3558  1567
3559  1568
3560  1569
3561  156A
3562  156B
3563  156C
3564  156D
3565  156E
3566  156F
3567  1570
3568  1571
3569  1572
3570  1573
3571  1574
3572  1575
3573  1576
3574  1577
3575  1578
3576  1579
3577  157A
3578  157B
3579  157C
3580  157D
3581  157E
3582  157F
3583  1580
3584  1581
3585  1582
3586  1583
3587  1584
3588  1585
3589  1586
3590  1587
3591  1588
3592  1589
3593  158A
3594  158B
3595  158C
3596  158D
3597  158E
3598  158F
3599  1590
3600  1591
3601  1592
3602  1593
3603  1594
3604  1595
3605  1596
3606  1597
3607  1598
3608  1599
3609  159A
3610  159B
3611  159C
3612  159D
3613  159E
3614  159F
3615  15A0
3616  15A1
3617  15A2
3618  15A3
3619  15A4
3620  15A5
3621  15A6
3622  15A7
3623  15A8
3624  15A9
3625  15AA
3626  15AB
3627  15AC
3628  15AD
3629  15AE
3630  15AF
3631  15B0
3632  15B1
3633  15B2
3634  15B3
3635  15B4
3636  15B5
3637  15B6
3638  15B7
3639  15B8
3640  15B9
3641  15BA
3642  15BB
3643  15BC
3644  15BD
3645  15BE
3646  15BF
3647  15C0
3648  15C1
3649  15C2
3650  15C3
3651  15C4
3652  15C5
3653  15C6
3654  15C7
3655  15C8
3656  15C9
3657  15CA
3658  15CB
3659  15CC
3660  15CD
3661  15CE
3662  15CF
3663  15D0
3664  15D1
3665  15D2
3666  15D3
3667  15D4
3668  15D5
3669  15D6
3670  15D7
3671  15D8
3672  15D9
3673  15DA
3674  15DB
3675  15DC
3676  15DD
3677  15DE
3678  15DF
3679  15E0
3680  15E1
3681  15E2
3682  15E3
3683  15E4
3684  15E5
3685  15E6
3686  15E7
3687  15E8
3688  15E9
3689  15EA
3690  15EB
3691  15EC
3692  15ED
3693  15EE
3694  15EF
3695  15F0
3696  15F1
3697  15F2
3698  15F3
3699  15F4
3700  15F5
3701  15F6
3702  15F7
3703  15F8
3704  15F9
3705  15FA
3706  15FB
3707  15FC
3708  15FD
3709  15FE
3710  15FF
3711  1600
3712  1601
3713  1602
3714  1603
3715  1604
3716  1605
3717  1606
3718  1607
3719  1608
3720  1609
3721  160A
3722  160B
3723  160C
3724  160D
3725  160E
3726  160F
3727  1610
3728  1611
3729  1612
3730  1613
3731  1614
3732  1615
3733  1616
3734  1617
3735  1618
3736  1619
3737  161A
3738  161B
3739  161C
3740  161D
3741  161E
3742  161F
3743  1620
3744  1621
3745  1622
3746  1623
3747  1624
3748  1625
3749  1626
3750  1627
3751  1628
3752  1629
3753  162A
3754  162B
3755  162C
3756  162D
3757  162E
3758  162F
3759  1630
3760  1631
3761  1632
3762  1633
3763  1634
3764  1635
3765  1636
3766  1637
3767  1638
3768  1639
3769  163A
3770  163B
3771  163C
3772  163D
3773  163E
3774  163F
3775  1640
3776  1641
3777  1642
3778  1643
3779  1644
3780  1645
3781  1646
3782  1647
3783  1648
3784  1649
3785  164A
3786  164B
3787  164C
3788  164D
3789  164E
3790  164F
3791  1650
3792  1651
3793  1652
3794  1653
3795  1654
3796  1655
3797  1656
3798  1657
3799  1658
3800  1659
3801  165A
3802  165B
3803  165C
3804  165D
3805  165E
3806  165F
3807  1660
3808  1661
3809  1662
3810  1663
3811  1664
3812  1665
3813  1666
3814  1667
3815  1668
3816  1669
3817  166A
3818  166B
3819  166C
3820  166D
3821  166E
3822  166F
3823  1670
3824  1671
3825  1672
3826  1673
3827  1674
3828  1675
3829  1676
3830  1677
3831  1678
3832  1679
3833  167A
3834  167B
3835  167C
3836  167D
3837  167E
3838  167F
3839  1680
3840  1681
3841  1682
3842  1683
3843  1684
3844  1685
3845  1686
3846  1687
3847  1688
3848  1689
3849  168A
3850  168B
3851  168C
3852  168D
3853  168E
3854  168F
3855  1690
3856  1691
3857  1692
3858  1693
3859  1694
3860  1695
3861  1696
3862  1697
3863  1698
3864  1699
3865  169A
3866  169B
3867  169C
3868  169D
3869  169E
3870  169F
3871  16A0
3872  16A1
3873  16A2
3874  16A3
3875  16A4
3876  16A5
3877  16A6
3878  16A7
3879  16A8
3880  16A9
3881  16AA
3882  16AB
3883  16AC
3884  16AD
3885  16AE
3886  16AF
3887  16B0
3888  16B1
3889  16B2
3890  16B3
3891  16B4
3892  16B5
3893  16B6
3894  16B7
3895  16B8
3896  16B9
3897  16BA
3898  16BB
3899  16BC
3900  16BD
3901  16BE
3902  16BF
3903  16C0
3904  16C1
3905  16C2
3906  16C3
3907  16C4
3908  16C5
3909  16C6
3910  16C7
3911  16C8
3912  16C9
3913  16CA
3914  16CB
3915  16CC
3916  16CD
3917  16CE
3918  16CF
3919  16D0
3920  16D1
3921  16D2
3922  16D3
3923  16D4
3924  16D5
3925  16D6
3926  16D7
3927  16D8
3928  16D9
3929  16DA
3930  16DB
3931  16DC
3932  16DD
3933  16DE
3934  16DF
3935  16E0
3936  16E1
3937  16E2
3938  16E3
3939  16E4
3940  16E5
3941  16E6
3942  16E7
3943  16E8
3944  16E9
3945  16EA
3946  16EB
3947  16EC
3948  16ED
3949  16EE
3950  16EF
3951  16F0
3952  16F1
3953  16F2
3954  16F3
3955  16F4
3956  16F5
3957  16F6
3958  16F7
3959  16F8
3960  16F9
3961  16FA
3962  16FB
3963  16FC
3964  16FD
3965  16FE
3966  16FF
3967  1700
3968  1701
3969  1702
3970  1703
3971  1704
3972  1705
3973  1706
3974  1707
3975  1708
3976  1709
3977  170A
3978  170B
3979  170C
3980  170D
3981  170E
3982  170F
3983  1710
3984  1711
3985  1712
3986  1713
3987  1714
3988  1715
3989  1716
3990  1717
3991  1718
3992  1719
3993  171A
3994  171B
3995  171C
3996  171D
3997  171E
3998  171F
3999  1720
4000  1721
4001  1722
4002  1723
4003  1724
4004  1725
4005  1726
4006  1727
4007  1728
4008  1729
4009  172A
4010  172B
4011  172C
4012  172D
4013  172E
4014  172F
4015  1730
4016  1731
4017  1732
4018  1733
4019  1734
4020  1735
4021  1736
4022  1737
4023  1738
4024  1739
4025  173A
4026  173B
4027  173C
4028  173D
4029  173E
4030  173F
4031  1740
4032  1741
4033  1742
4034  1743
4035  1744
4036  1745
4037  1746
4038  1747
4039  1748
4040  1749
4041  174A
4042  174B
4043  174C
4044  174D
4045  174E
4046  174F
4047  1750
4048  1751
4049  1752
4050  1753
4051  1754
4052  1755
4053  1756
4054  1757
4055  1758
4056  1759
4057  175A
4058  175B
4059  175C
4060  175D
4061  175E
4062  175F
4063  1760
4064  1761
4065  1762
4066  1763
4067  1764
4068  1765
4069  1766
4070  1767
4071  1768
4072  1769
4073  176A
4074  176B
4075  176C
4076  176D
4077  176E
4078  176F
4079  1770
4080  1771
4081  1772
4082  1773
4083  1774
4084  1775
4085  1776
4086  1777
4087  1778
4088  1779
4089  177A
4090  177B
4091  177C
4092  177D
4093  177E
4094  177F
4095  1780
4096  1781
4097  1782
4098  1783
4099  1784
4100  1785
4101  1786
4102  1787
4103  1788
4104  1789
4105  178A
4106  178B
4107  178C
4108  178D
4109  178E
4110  178F
4111  1790
4112  1791
4113  1792
4114  1793
4115  1794
4116  1795
4117  1796
4118  1797
4119  1798
4120  1799
4121  179A
4122  179B
4123  179C
4124  179D
4125  179E
4126  179F
4127  17A0
4128  17A1
4129  17A2
4130  17A3
4131  17A4
4132  17A5
4133  17A6
4134  17A7
4135  17A8
4136  17A9
4137  17AA
4138  17AB
4139  17AC
4140  17AD
4141  17AE
4142  17AF
4143  17B0
4144  17B1
4145  17B2
4146  17B3
4147  17B4
4148  17B5
4149  17B6
4150  17B7
4151  17B8
4152  17B9
4153  17BA
4154  17BB
4155  17BC
4156  17BD
4157  17BE
4158  17BF
4159  17C0
4160  17C1
4161  17C2
4162  17C3
4163  17C4
4164  17C5
4165  17C6
4166  17C7
4167  17C8
4168  17C9
4169  17CA
4170  17CB
4171  17CC
4172  17CD
4173  17CE
4174  17CF
4175  17D0
4176  17D1
4177  17D2
4178  17D3
4179  17D4
4180  17D5
4181  17D6
4182  17D7
4183  17D8
4184  17D9
4185  17DA
4186  17DB
4187  17DC
4188  17DD
4189  17DE
4190  17DF
4191  17E0
4192  17E1
4193  17E2
4194  17E3
4195  17E4
4196  17E5
4197  17E6
4198  17E7
4199  17E8
4200  17E9
4201  17EA
4202  17EB
4203  17EC
4204  17ED
4205  17EE
4206  17EF
4207  17F0
4208  17F1
4209  17F2
4210  17F3
4211  17F4
4212  17F5
4213  17F6
4214  17F7
4215  17F8
4216  17F9
4217  17FA
4218  17FB
4219  17FC
4220  17FD
4221  17FE
4222  17FF
4223  1800
4224  1801
4225  1802
4226  1803
4227  1804
4228  1805
4229  1806
4230  1807
4231  1808
4232  1809
4233  180A
4234  180B
4235  180C
4236  180D
4237  180E
4238  180F
4239  1810
4240  1811
4241  1812
4242  1813
4243  1814
4244  1815
4245  1816
4246  1817
4247  1818
4248  1819
4249  181A
4250  181B
4251  181C
4252  181D
4253  181E
4254  181F
4255  1820
4256  1821
4257  1822
4258  1823
4259  1824
4260  1825
4261  1826
4262  1827
4263  1828
4264  1829
4265  182A
4266  182B
4267  182C
4268  182D
4269  182E
4270  182F
4271  1830
4272  1831
4273  1832
4274  1833
4275  1834
4276  1835
4277  1836
4278  1837
4279  1838
4280  1839
4281  183A
4282  183B
4283  183C
4284  183D
4285  183E
4286  183F
4287  1840
4288  1841
4289  1842
4290  1843
4291  1844
4292  1845
4293  1846
4294  1847
4295  1848
4296  1849
4297  184A
4298  184B
4299  184C
4300  184D
4301  184E
4302  184F
4303  1850
4304  1851
4305  1852
4306  1853
4307  1854
4308  1855
4309  1856
4310  1857
4311  1858
4312  1859
4313  185A
4314  185B
4315  185C
4316  185D
4317  185E
4318  185F
4319  1860
4320  1861
4321  1862
4322  1863
4323  1864
4324  1865
4325  1866
4326  1867
4327  1868
4328  1869
4329  186A
4330  186B
4331  186C
4332  186D
4333  186E
4334  186F
4335  1870
4336  1871
4337  1872
4338  1873
4339  1874
4340  1875
4341  1876
4342  1877
4343  1878
4344  1879
4345  187A
4346  187B
4347  187C
4348  187D
4349  187E
4350  187F
4351  1880
4352  1881
4353  1882
4354  1883
4355  1884
4356  1885
4357  1886
4358  1887
4359  1888
4360  1889
4361  188A
4362  188B
4363  188C
4364  188D
4365  188E
4366  188F
4367  1890
4368  1891
4369  1892
4370  1893
4371  1894
4372  1895
4373  1896
4374  1897
4375  1898
4376  1899
4377  189A
4378  189B
4379  189C
4380  189D
4381  189E
4382  189F
4383  18A0
4384  18A1
4385  18A2
4386  18A3
4387  18A4
4388  18A5
4389  18A6
4390  18A7
4391  18A8
4392  18A9
4393  18AA
4394  18AB
4395  18AC
4396  18AD
4397  18AE
4398  18AF
4399  18B0
4400  18B1
4401  18B2
4402  18B3
4403  18B4
4404  18B5
4405  18B6
4406  18B7
4407  18B8
4408  18B9
4409  18BA
4410  18BB
4411  18BC
4412  18BD
4413  18BE
4414  18BF
4415  18C0
4416  18C1
4417  18C2
4418  18C3
4419  18C4
4420  18C5
4421  18C6
4422  18C7
4423  18C8
4424  18C9
4425  18CA
4426  18CB
4427  18CC
4428  18CD
4429  18CE
4430  18CF
4431  18D0
4432  18D1
4433  18D2
4434  18D3
4435  18D4
4436  18D5
4437  18D6
4438  18D7
4439  18D8
4440  18D9
4441  18DA
4442  18DB
4443  18DC
4444  18DD
4445  18DE
4446  18DF
4447  18E0
4448  18E1
4449  18E2
4450  18E3
4451  18E4
4452  18E5
4453  18E6
4454  18E7
4455  18E8
4456  18E9
4457  18EA
4458  18EB
4459  18EC
4460  18ED
4461  18EE
4462  18EF
4463  18F0
4464  18F1
4465  18F2
4466  18F3
4467  18F4
4468  18F5
4469  18F6
4470  18F7
4471  18F8
4472  18F9
4473  18FA
4474  18FB
4475  18FC
4476  18FD
4477  18FE
4478  18FF
4479  1900
4480  1901
4481  1902
4482  1903
4483  1904
4484  1905
4485  1906
4486  1907
4487  1908
4488  1909
4489  190A
4490  190B
4491  190C
4492  190D
4493  190E
4494  190F
4495  1910
4496  1911
4497  1912
4498  1913
4499  1914
4500  1915
4501  1916
4502  1917
4503  1918
4504  1919
4505  191A
4506  191B
4507  191C
4508  191D
4509  191E
4510  191F
4511  1920
4512  1921
4513  1922
4514  1923
4515  1924
4516  1925
4517  1926
4518  1927
4519  1928
4520  1929
4521  192A
4522  192B
4523  192C
4524  192D
4525  192E
4526  192F
4527  1930
4528  1931
4529  1932
4530  1933
4531  1934
4532  1935
4533  1936
4534  1937
4535  1938
4536  1939
4537  193A
4538  193B
4539  193C
4540  193D
4541  193E
4542  193F
4543  1940
4544  1941
4545  1942
4546  1943
4547  1944
4548  1945
4549  1946
4550  1947
4551  1948
4552  1949
4553  194A
4554  194B
4555  194C
4556  194D
4557  194E
4558  194F
4559  1950
4560  1951
4561  1952
4562  1953
4563  1954
4564  1955
4565  1956
4566  1957
4567  1958
4568  1959
4569  195A
4570  195B
4571  195C
4572  195D
4573  195E
4574  195F
4575  1960
4576  1961
4577  1962
4578  1963
4579  1964
4580  1965
4581  1966
4582  1967
4583  1968
4584  1969
4585  196A
4586  196B
4587  196C
4588  196D
4589  196E
4590  196F
4591  1970
4592  1971
4593  1972
4594  1973
4595  1974
4596  1975
4597  1976
4598  1977
4599  1978
4600  1979
4601  197A
4602  197B
4603  197C
4604  197D
4605  197E
4606  197F
4607  1980
4608  1981
4609  1982
4610  1983
4611  1984
4612  1985
4613  1986
4614  1987
4615  1988
4616  1989
4617  198A
4618  198B
4619  198C
4620  198D
4621  198E
4622  198F
4623  1990
4624  1991
4625  1992
4626  1993
4627  1994
4628  1995
4629  1996
4630  1997
4631  1998
4632  1999
4633  199A
4634  199B
4635  199C
4636  199D
4637  199E
4638  199F
4639  19A0
4640  19A1
4641  19A2
4642  19A3
4643  19A4
4644  19A5
4645  19A6
4646  19A7
4647  19A8
4648  19A9
4649  19AA
4650  19AB
4651  19AC
4652  19AD
4653  19AE
4654  19AF
4655  19B0
4656  19B1
4657  19B2
4658  19B3
4659  19B4
4660  19B5
4661  19B6
4662  19B7
4663  19B8
4664  19B9
4665  19BA
4666  19BB
4667  19BC
4668  19BD
4669  19BE
4670  19BF
4671  19C0
4672  19C1
4673  19C2
4674  19C3
4675  19C4
4676  19C5
4677  19C6
4678  19C7
4679  19C8
4680  19C9
4681  19CA
4682  19CB
4683  19CC
4684  19CD
4685  19CE
4686  19CF
4687  19D0
4688  19D1
4689  19D2
4690  19D3
4691  19D4
4692  19D5
4693  19D6
4694  19D7
4695  19D8
4696  19D9
4697  19DA
4698  19DB
4699  19DC
4700  19DD
4701  19DE
4702  19DF
4703  19E0
4704  19E1
4705  19E2
4706  19E3
4707  19E4
4708  19E5
4709  19E6
4710  19E7
4711  19E8
4712  19E9
4713  19EA
4714  19EB
4715  19EC
4716  19ED
4717  19EE
4718  19EF
4719  19F0
4720  19F1
4721  19F2
4722  19F3
4723  19F4
4724  19F5
4725  19F6
4726  19F7
4727  19F8
4728  19F9
4729  19FA
4730  19FB
4731  19FC
4732  19FD
4733  19FE
4734  19FF
4735  1A00
4736  1A01
4737  1A02
4738  1A03
4739  1A04
4740  1A05
4741  1A06
4742  1A07
4743  1A08
4744  1A09
4745  1A0A
4746  1A0B
4747  1A0C
4748  1A0D
4749  1A0E
4750  1A0F
4751  1A10
4752  1A11
4753  1A12
4754  1A13
4755  1A14
4756  1A15
4757  1A16
4758  1A17
4759  1A18
4760  1A19
4761  1A1A
4762  1A1B
4763  1A1C
4764  1A1D
4765  1A1E
4766  1A1F
4767  1A20
4768  1A21
4769  1A22
4770  1A23
4771  1A24
4772  1A25
4773  1A26
4774  1A27
4775  1A28
4776  1A29
4777  1A2A
4778  1A2B
4779  1A2C
4780  1A2D
4781  1A2E
4782  1A2F
4783  1A30
4784  1A31
4785  1A32
4786  1A33
4787  1A34
4788  1A35
4789  1A36
4790  1A37
4791  1A38
4792  1A39
4793  1A3A
4794  1A3B
4795  1A3C
4796  1A3D
4797  1A3E
4798  1A3F
4799  1A40
4800  1A41
4801  1A42
4802  1A43
4803  1A44
4804  1A45
4805  1A46
4806  1A47
4807  1A48
4808  1A49
4809  1A4A
4810  1A4B
4811  1A4C
4812  1A4D
4813  1A4E
4814  1A4F
4815  1A50
4816  1A51
4817  1A52
4818  1A53
4819  1A54
4820  1A55
4821  1A56
4822  1A57
4823  1A58
4824  1A59
4825  1A5A
4826  1A5B
4827  1A5C
4828  1A5D
4829  1A5E
4830  1A5F
4831  1A60
4832  1A61
4833  1A62
4834  1A63
4835  1A64
4836  1A65
4837  1A66
4838  1A67
4839  1A68
4840  1A69
4841  1A6A
4842  1A6B
4843  1A6C
4844  1A6D
4845  1A6E
4846  1A6F
4847  1A70
4848  1A71
4849  1A72
4850  1A73
4851  1A74
4852  1A75
4853  1A76
4854  1A77
4855  1A78
4856  1A79
4857  1A7A
4858  1A7B
4859  1A7C
4860  1A7D
4861  1A7E
4862  1A7F
4863  1A80
4864  1A81
4865  1A82
4866  1A83
4867  1A84
4868  1A85
4869  1A86
4870  1A87
4871  1A88
4872  1A89
4873  1A8A
4874  1A8B
4875  1A8C
4876  1A8D
4877  1A8E
4878  1A8F
4879  1A90
4880  1A91
4881  1A92
4882  1A93
4883  1A94
4884  1A95
4885  1A96
4886  1A97
4887  1A98
4888  1A99
4889  1A9A
4890  1A9B
4891  1A9C
4892  1A9D
4893  1A9E
4894  1A9F
4895  1AA0
4896  1AA1
4897  1AA2
4898  1AA3
4899  1AA4
4900  1AA5
4901  1AA6
4902  1AA7
4903  1AA8
4904  1AA9
4905  1AAA
4906  1AAB
4907  1AAC
4908  1AAD
4909  1AAE
4910  1AAF
4911  1AB0
4912  1AB1
4913  1AB2
4914  1AB3
4915  1AB4
4916  1AB5
4917  1AB6
4918  1AB7
4919  1AB8
4920  1AB9
4921  1ABA
4922  1ABB
4923  1ABC
4924  1ABD
4925  1ABE
4926  1ABF
4927  1AC0
4928  1AC1
4929  1AC2
4930  1AC3
4931  1AC4
4932  1AC5
4933  1AC6
4934  1AC7
4935  1AC8
4936  1AC9
4937  1ACA
4938  1ACB
4939  1ACC
4940  1ACD
4941  1ACE
4942  1ACF
4943  1AD0
4944  1AD1
4945  1AD2
4946  1AD3
4947  1AD4
4948  1AD5
4949  1AD6
4950  1AD7
4951  1AD8
4952  1AD9
4953  1ADA
4954  1ADB
4955  1ADC
4956  1ADD
4957  1ADE
4958  1ADF
4959  1AE0
4960  1AE1
4961  1AE2
4962  1AE3
4963  1AE4
4964  1AE5
4965  1AE6
4966  1AE7
4967  1AE8
4968  1AE9
4969  1AEA
4970  1AEB
4971  1AEC
4972  1AED
4973  1AEE
4974  1AEF
4975  1AF0
4976  1AF1
4977  1AF2
4978  1AF3
4979  1AF4
4980  1AF5
4981  1AF6
4982  1AF7
4983  1AF8
4984  1AF9
4985  1AFA
4986  1AFB
4987  1AFC
4988  1AFD
4989  1AFE
4990  1AFF
4991  1B00
4992  1B01
4993  1B02
4994  1B03
4995  1B04
4996  1B05
4997  1B06
4998  1B07
4999  1B08
5000  1B09
5001  1B0A
5002  1B0B
5003  1B0C
5004  1B0D
5005  1B0E
5006  1B0F
5007  1B10
5008  1B11
5009  1B12
5010  1B13
5011  1B14
5012  1B15
5013  1B16
5014  1B17
5015  1B18
5016  1B19
5017  1B1A
5018  1B1B
5019  1B1C
5020  1B1D
5021  1B1E
5022  1B1F
5023  1B20
5024  1B21
5025  1B22
5026  1B23
5027  1B24
5028  1B25
5029  1B26
5030  1B27
5031  1B28
5032  1B29
5033  1B2A
5034  1B2B
5035  1B2C
5036  1B2D
5037  1B2E
5038  1B2F
5039  1B30
5040  1B31
5041  1B32
5042  1B33
5043  1B34
5044  1B35
5045  1B36
5046  1B37
5047  1B38
5048  1B39
5049  1B3A
5050  1B3B
5051  1B3C
5052  1B3D
5053  1B3E
5054  1B3F
5055  1B40
5056  1B41
5057  1B42
5058  1B43
5059  1B44
5060  1B45
5061  1B46
5062  1B47
5063  1B48
5064  1B49
5065  1B4A
5066  1B4B
5067  1B4C
5068  1B4D
5069  1B4E
5070  1B4F
5071  1B50
5072  1B51
5073  1B52
5074  1B53
5075  1B54
5076  1B55
5077  1B56
5078  1B57
5079  1B58
5080  1B59
5081  1B5A
5082  1B5B
5083  1B5C
5084  1B5D
5085  1B5E
5086  1B5F
5087  1B60
5088  1B61
5089  1B62
5090  1B63
5091  1B64
5092  1B65
5093  1B66
5094  1B67
5095  1B68
5096  1B69
5097  1B6A
5098  1B6B
5099  1B6C
5100  1B6D
5101  1B6E
5102  1B6F
5103  1B70
5104  1B71
5105  1B72
5106  1B73
5107  1B74
5108  1B75
5109  1B76
5110  1B77
5111  1B78
5112  1B79
5113  1B7A
5114  1B7B
5115  1B7C
5116  1B7D
5117  1B7E
5118  1B7F
5119  1B80
5120  1B81
5121  1B82
5122  1B83
5123  1B84
5124  1B85
5125  1B86
5126  1B87
5127  1B88
5128  1B89
5129  1B8A
5130  1B8B
5131  1B8C
5132  1B8D
5133  1B8E
5134  1B8F
5135  1B90
5136  1B91
5137  1B92
5138  1B93
5139  1B94
5140  1B95
5141  1B96
5142  1B97
5143  1B98
5144  1B99
5145  1B9A
5146  1B9B
5147  1B9C
5148  1B9D
5149  1B9E
5150  1B9F
5151  1BA0
5152  1BA1
5153  1BA2
5154  1BA3
5155  1BA4
5156  1BA5
5157  1BA6
5158  1BA7
5159  1BA8
5160  1BA9
5161  1BAA
5162  1BAB
5163  1BAC
5164  1BAD
5165  1BAE
5166  1BAF
5167  1BB0
5168  1BB1
5169  1BB2
5170  1BB3
5171  1BB4
5172  1BB5
5173  1BB6
5174  1BB7
5175  1BB8
5176  1BB9
5177  1BBA
5178  1BBB
5179  1BBC
5180  1BBD
5181  1BBE
5182  1BBF
5183  1BC0
5184  1BC1
5185  1BC2
5186  1BC3
5187  1BC4
5188  1BC5
5189  1BC6
5190  1BC7
5191  1BC8
5192  1BC9
5193  1BCA
5194  1BCB
5195  1BCC
5196  1BCD
5197  1BCE
5198  1BCF
5199  1BD0
5200  1BD1
5201  1BD2
5202  1BD3
5203  1BD4
5204  1BD5
5205  1BD6
5206  1BD7
5207  1BD8
5208  1BD9
5209  1BDA
5210  1BDB
5211  1BDC
5212  1BDD
5213  1BDE
5214  1BDF
5215  1BE0
5216  1BE1
5217  1BE2
5218  1BE3
5219  1BE4
5220  1BE5
5221  1BE6
5222  1BE7
5223  1BE8
5224  1BE9
5225  1BEA
5226  1BEB
5227  1BEC
5228  1BED
5229  1BEE
5230  1BEF
5231  1BF0
5232  1BF1
5233  1BF2
5234  1BF3
5235  1BF4
5236  1BF5
5237  1BF6
5238  1BF7
5239  1BF8
5240  1BF9
5241  1BFA
5242  1BFB
5243  1BFC
5244  1BFD
5245  1BFE
5246  1BFF
5247  1C00
5248  1C01
5249  1C02
5250  1C03
5251  1C04
5252  1C05
5253  1C06
5254  1C07
5255  1C08
5256  1C09
5257  1C0A
5258  1C0B
5259  1C0C
5260  1C0D
5261  1C0E
5262  1C0F
5263  1C10
5264  1C11
5265  1C12
5266  1C13
5267  1C14
5268  1C15
5269  1C16
5270  1C17
5271  1C18
5272  1C19
5273  1C1A
5274  1C1B
5275  1C1C
5276  1C1D
5277  1C1E
5278  1C1F
5279  1C20
5280  1C21
5281  1C22
5282  1C23
5283  1C24
5284  1C25
5285  1C26
5286  1C27
5287  1C28
5288  1C29
5289  1C2A
5290  1C2B
5291  1C2C
5292  1C2D
5293  1C2E
5294  1C2F
5295  1C30
5296  1C31
5297  1C32
5298  1C33
5299  1C34
5300  1C35
5301  1C36
5302  1C37
5303  1C38
5304  1C39
5305  1C3A
5306  1C3B
5307  1C3C
5308  1C3D
5309  1C3E
5310  1C3F
5311  1C40
5312  1C41
5313  1C42
5314  1C43
5315  1C44
5316  1C45
5317  1C46
5318  1C47
5319  1C48
5320  1C49
5321  1C4A
5322  1C4B
5323  1C4C
5324  1C4D
5325  1C4E
5326  1C4F
5327  1C50
5328  1C51
5329  1C52
5330  1C53
5331  1C54
5332  1C55
5333  1C56
5334  1C57
5335  1C58
5336  1C59
5337  1C5A
5338  1C5B
5339  1C5C
5340  1C5D
5341  1C5E
5342  1C5F
5343  1C60
5344  1C61
5345  1C62
5346  1C63
5347  1C64
5348  1C65
5349  1C66
5350  1C67
5351  1C68
5352  1C69
5353  1C6A
5354  1C6B
5355  1C6C
5356  1C6D
5357  1C6E
5358  1C6F
5359  1C70
5360  1C71
5361  1C72
5362  1C73
5363  1C74
5364  1C75
5365  1C76
5366  1C77
5367  1C78
5368  1C79
5369  1C7A
5370  1C7B
5371  1C7C
5372  1C7D
5373  1C7E
5374  1C7F
5375  1C80
5376  1C81
5377  1C82
5378  1C83
5379  1C84
5380  1C85
5381  1C86
5382  1C87
5383  1C88
5384  1C89
5385  1C8A
5386  1C8B
5387  1C8C
5388  1C8D
5389  1C8E
5390  1C8F
5391  1C90
5392  1C91
5393  1C92
5394  1C93
5395  1C94
5396  1C95
5397  1C96
5398  1C97
5399  1C98
5400  1C99
5401  1C9A
5402  1C9B
5403  1C9C
5404  1C9D
5405  1C9E
5406  1C9F
5407  1CA0
5408  1CA1
5409  1CA2
5410  1CA3
5411  1CA4
5412  1CA5
5413  1CA6
5414  1CA7
5415  1CA8
5416  1CA9
5417  1CAA
5418  1CAB
5419  1CAC
5420  1CAD
5421  1CAE
5422  1CAF
5423  1CB0
5424  1CB1
5425  1CB2
5426  1CB3
5427  1CB4
5428  1CB5
5429  1CB6
5430  1CB7
5431  1CB8
5432  1CB9
5433  1CBA
5434  1CBB
5435  1CBC
5436  1CBD
5437  1CBE
5438  1CBF
5439  1CC0
5440  1CC1
5441  1CC2
5442  1CC3
5443  1CC4
5444  1CC5
5445  1CC6
5446  1CC7
5447  1CC8
5448  1CC9
5449  1CCA
5450  1CCB
5451  1CCC
5452  1CCD
5453  1CCE
5454  1CCF
5455  1CD0
5456  1CD1
5457  1CD2
5458  1CD3
5459  1CD4
5460  1CD5
5461  1CD6
5462  1CD7
5463  1CD8
5464  1CD9
5465  1CDA
5466  1CDB
5467  1CDC
5468  1CDD
5469  1CDE
5470  1CDF
5471  1CE0
5472  1CE1
5473  1CE2
5474  1CE3
5475  1CE4
5476  1CE5
5477  1CE6
5478  1CE7
5479  1CE8
5480  1CE9
5481  1CEA
5482  1CEB
5483  1CEC
5484  1CED
5485  1CEE
5486  1CEF
5487  1CF0
5488  1CF1
5489  1CF2
5490  1CF3
5491  1CF4
5492  1CF5
5493  1CF6
5494  1CF7
5495  1CF8
5496  1CF9
5497  1CFA
5498  1CFB
5499  1CFC
5500  1CFD
5501  1CFE
5502  1CFF
5503  1D00
5504  1D01
5505  1D02
5506  1D03
5507  1D04
5508  1D05
5509  1D06
5510  1D07
5511  1D08
5512  1D09
5513  1D0A
5514  1D0B
5515  1D0C
5516  1D0D
5517  1D0E
5518  1D0F
5519  1D10
5520  1D11
5521  1D12
5522  1D13
5523  1D14
5524  1D15
5525  1D16
5526  1D17
5527  1D18
5528  1D19
5529  1D1A
5530  1D1B
5531  1D1C
5532  1D1D
5533  1D1E
5534  1D1F
5535  1D20
5536  1D21
5537  1D22
5538  1D23
5539  1D24
5540  1D25
5541  1D26
5542  1D27
5543  1D28
5544  1D29
5545  1D2A
5546  1D2B
5547  1D2C
5548  1D2D
5549  1D2E
5550  1D2F
5551  1D30
5552  1D31
5553  1D32
5554  1D33
5555  1D34
5556  1D35
5557  1D36
5558  1D37
5559  1D38
5560  1D39
5561  1D3A
5562  1D3B
5563  1D3C
5564  1D3D
5565  1D3E
5566  1D3F
5567  1D40
5568  1D41
5569  1D42
5570  1D43
5571  1D44
5572  1D45
5573  1D46
5574  1D47
5575  1D48
5576  1D49
5577  1D4A
5578  1D4B
5579  1D4C
5580  1D4D
5581  1D4E
5582  1D4F
5583  1D50
5584  1D51
5585  1D52
5586  1D53
5587  1D54
5588  1D55
5589  1D56
5590  1D57
5591  1D58
5592  1D59
5593  1D5A
5594  1D5B
5595  1D5C
5596  1D5D
5597  1D5E
5598  1D5F
5599  1D60
5600  1D61
5601  1D62
5602  1D63
5603  1D64
5604  1D65
5605  1D66
5606  1D67
5607  1D68
5608  1D69
5609  1D6A
5610  1D6B
5611  1D6C
5612  1D6D
5613  1D6E
5614  1D6F
5615  1D70
5616  1D71
5617  1D72
5618  1D73
5619  1D74
5620  1D75
5621  1D76
5622  1D77
5623  1D78
5624  1D79
5625  1D7A
5626  1D7B
5627  1D7C
5628  1D7D
5629  1D7E
5630  1D7F
5631  1D80
5632  1D81
5633  1D82
5634  1D83
5635  1D84
5636  1D85
5637  1D86
5638  1D87
5639  1D88
5640  1D89
5641  1D8A
5642  1D8B
5643  1D8C
5644  1D8D
5645  1D8E
5646  1D8F
5647  1D90
5648  1D91
5649  1D92
5650  1D93
5651  1D94
5652  1D95
5653  1D96
5654  1D97
5655  1D98
5656  1D99
5657  1D9A
5658  1D9B
5659  1D9C
5660  1D9D
5661  1D9E
5662  1D9F
5663  1DA0
5664  1DA1
5665  1DA2
5666  1DA3
5667  1DA4
5668  1DA5
5669  1DA6
5670  1DA7
5671  1DA8
5672  1DA9
5673  1DAA
5674  1DAB
5675  1DAC
5676  1DAD
5677  1DAE
5678  1DAF
5679  1DB0
5680  1DB1
5681  1DB2
5682  1DB3
5683  1DB4
5684  1DB5
5685  1DB6
5686  1DB7
5687  1DB8
5688  1DB9
5689  1DBA
5690  1DBB
5691  1DBC
5692  1DBD
5693  1DBE
5694  1DBF
5695  1DC0
5696  1DC1
5697  1DC2
5698  1DC3
5699  1DC4
5700  1DC5
5701  1DC6
5702  1DC7
5703  1DC8
5704  1DC9
5705  1DCA
5706  1DCB
5707  1DCC
5708  1DCD
5709  1DCE
5710  1DCF
5711  1DD0
5712  1DD1
5713  1DD2
5714  1DD3
5715  1DD4
5716  1DD5
5717  1DD6
5718  1DD7
5719  1DD8
5720  1DD9
5721  1DDA
5722  1DDB
5723  1DDC
5724  1DDD
5725  1DDE
5726  1DDF
5727  1DE0
5728  1DE1
5729  1DE2
5730  1DE3
5731  1DE4
5732  1DE5
5733  1DE6
5734  1DE7
5735  1DE8
5736  1DE9
5737  1DEA
5738  1DEB
5739  1DEC
5740  1DED
5741  1DEE
5742  1DEF
5743  1DF0
5744  1DF1
5745  1DF2
5746  1DF3
5747  1DF4
5748  1DF5
5749  1DF6
5750  1DF7
5751  1DF8
5752  1DF9
5753  1DFA
5754  1DFB
5755  1DFC
5756  1DFD
5757  1DFE
5758  1DFF
5759  1E00
5760  1E01
5761  1E02
5762  1E03
5763  1E04
5764  1E05
5765  1E06
5766  1E07
5767  1E08
5768  1E09
5769  1E0A
5770  1E0B
5771  1E0C
5772  1E0D
5773  1E0E
5774  1E0F
5775  1E10
5776  1E11
5777  1E12
5778  1E13
5779  1E14
5780  1E15
5781  1E16
5782  1E17
5783  1E18
5784  1E19
5785  1E1A
5786  1E1B
5787  1E1C
5788  1E1D
5789  1E1E
5790  1E1F
5791  1E20
5792  1E21
5793  1E22
5794  1E23
5795  1E24
5796  1E25
5797  1E26
5798  1E27
5799  1E28
5800  1E29
5801  1E2A
5802  1E2B
5803  1E2C
5804  1E2D
5805  1E2E
5806  1E2F
5807  1E30
5808  1E31
5809  1E32
5810  1E33
5811  1E34
5812  1E35
5813  1E36
5814  1E37
5815  1E38
5816  1E39
5817  1E3A
5818  1E3B
5819  1E3C
5820  1E3D
5821  1E3E
5822  1E3F
5823  1E40
5824  1E41
5825  1E42
5826  1E43
5827  1E44
5828  1E45
5829  1E46
5830  1E47
5831  1E48
5832  1E49
5833  1E4A
5834  1E4B
5835  1E4C
5836  1E4D
5837  1E4E
5838  1E4F
5839  1E50
5840  1E51
5841  1E52
5842  1E53
5843  1E54
5844  1E55
5845  1E56
5846  1E57
5847  1E58
5848  1E59
5849  1E5A
5850  1E5B
5851  1E5C
5852  1E5D
5853  1E5E
5854  1E5F
5855  1E60
5856  1E61
5857  1E62
5858  1E63
5859  1E64
5860  1E65
5861  1E66
5862  1E67
5863  1E68
5864  1E69
5865  1E6A
5866  1E6B
5867  1E6C
5868  1E6D
5869  1E6E
5870  1E6F
5871  1E70
5872  1E71
5873  1E72
5874  1E73
5875  1E74
5876  1E75
5877  1E76
5878  1E77
5879  1E78
5880  1E79
5881  1E7A
5882  1E7B
5883  1E7C
5884  1E7D
5885  1E7E
5886  1E7F
5887  1E80
5888  1E81
5889  1E82
5890  1E83
5891  1E84
5892  1E85
5893  1E86
5894  1E87
5895  1E88
5896  1E89
5897  1E8A
5898  1E8B
5899  1E8C
5900  1E8D
5901  1E8E
5902  1E8F
5903  1E90
5904  1E91
5905  1E92
5906  1E93
5907  1E94
5908  1E95
5909  1E96
5910  1E97
5911  1E98
5912  1E99
5913  1E9A
5914  1E9B
5915  1E9C
5916  1E9D
5917  1E9E
5918  1E9F
5919  1EA0
5920  1EA1
5921  1EA2
5922  1EA3
5923  1EA4
5924  1EA5
5925  1EA6
5926  1EA7
5927  1EA8
5928  1EA9
5929  1EAA
5930  1EAB
5931  1EAC
5932  1EAD
5933  1EAE
5934  1EAF
5935  1EB0
5936  1EB1
5937  1EB2
5938  1EB3
5939  1EB4
5940  1EB5
5941  1EB6
5942  1EB7
5943  1EB8
5944  1EB9
5945  1EBA
5946  1EBB
5947  1EBC
5948  1EBD
5949  1EBE
5950  1EBF
5951  1EC0
5952  1EC1
5953  1EC2
5954  1EC3
5955  1EC4
5956  1EC5
5957  1EC6
5958  1EC7
5959  1EC8
5960  1EC9
5961  1ECA
5962  1ECB
5963  1ECC
5964  1ECD
5965  1ECE
5966  1ECF
5967  1ED0
5968  1ED1
5969  1ED2
5970  1ED3
5971  1ED4
5972  1ED5
5973  1ED6
5974  1ED7
5975  1ED8
5976  1ED9
5977  1EDA
5978  1EDB
5979  1EDC
5980  1EDD
5981  1EDE
5982  1EDF
5983  1EE0
5984  1EE1
5985  1EE2
5986  1EE3
5987  1EE4
5988  1EE5
5989  1EE6
5990  1EE7
5991  1EE8
5992  1EE9
5993  1EEA
5994  1EEB
5995  1EEC
5996  1EED
5997  1EEE
5998  1EEF
5999  1EF0
6000  1EF1
6001  1EF2
6002  1EF3
6003  1EF4
6004  1EF5
6005  1EF6
6006  1EF7
6007  1EF8
6008  1EF9
6009  1EFA
6010  1EFB
6011  1EFC
6012  1EFD
6013  1EFE
6014  1EFF
6015  1F00
6016  1F01
6017  1F02
6018  1F03
6019  1F04
6020  1F05
6021  1F06
6022  1F07
6023  1F08
6024  1F09
6025  1F0A
6026  1F0B
6027  1F0C
6028  1F0D
6029  1F0E
6030  1F0F
6031  1F10
6032  1F11
6033  1F12
6034  1F13
6035  1F14
6036  1F15
6037  1F16
6038  1F17
6039  1F18
6040  1F19
6041  1F1A
6042  1F1B
6043  1F1C
6044  1F1D
6045  1F1E
6046  1F1F
6047  1F20
6048  1F21
6049  1F22
6050  1F23
6051  1F24
6052  1F25
6053  1F26
6054  1F27
6055  1F28
6056  1F29
6057  1F2A
6058  1F2B
6059  1F2C
6060  1F2D
6061  1F2E
6062  1F2F
6063  1F30
6064  1F31
6065  1F32
6066  1F33
6067  1F34
6068  1F35
6069  1F36
6070  1F37
6071  1F38
6072  1F39
6073  1F3A
6074  1F3B
6075  1F3C
6076  1F3D
6077  1F3E
6078  1F3F
6079  1F40
6080  1F41
6081  1F42
6082  1F43
6083  1F44
6084  1F45
6085  1F46
6086  1F47
6087  1F48
6088  1F49
6089  1F4A
6090  1F4B
6091  1F4C
6092  1F4D
6093  1F4E
6094  1F4F
6095  1F50
6096  1F51
6097  1F52
6098  1F53
6099  1F54
6100  1F55
6101  1F56
6102  1F57
6103  1F58
6104  1F59
6105  1F5A
6106  1F5B
6107  1F5C
6108  1F5D
6109  1F5E
6110  1F5F
6111  1F60
6112  1F61
6113  1F62
6114  1F63
6115  1F64
6116  1F65
6117  1F66
6118  1F67
6119  1F68
6120  1F69
6121  1F6A
6122  1F6B
6123  1F6C
6124  1F6D
6125  1F6E
6126  1F6F
6127  1F70
6128  1F71
6129  1F72
6130  1F73
6131  1F74
6132  1F75
6133  1F76
6134  1F77
6135  1F78
6136  1F79
6137  1F7A
6138  1F7B
6139  1F7C
6140  1F7D
6141  1F7E
6142  1F7F
6143  1F80
6144  1F81
6145  1F82
6146  1F83
6147  1F84
6148  1F85
6149  1F86
6150  1F87
6151  1F88
6152  1F89
6153  1F8A
6154  1F8B
6155  1F8C
6156  1F8D
6157  1F8E
6158  1F8F
6159  1F90
6160  1F91
6161  1F92
6162  1F93
6163  1F94
6164  1F95
6165  1F96
6166  1F97
6167  1F98
6168  1F99
6169  1F9A
6170  1F9B
6171  1F9C
6172  1F9D
6173  1F9E
6174  1F9F
6175  1FA0
6176  1FA1
6177  1FA2
6178  1FA3
6179  1FA4
6180  1FA5
6181  1FA6
6182  1FA7
6183  1FA8
6184  1FA9
6185  1FAA
6186  1FAB
6187  1FAC
6188  1FAD
6189  1FAE
6190  1FAF
6191  1FB0
6192  1FB1
6193  1FB2
6194  1FB3
6195  1FB4
6196  1FB5
6197  1FB6
6198  1FB7
6199  1FB8
6200  1FB9
6201  1FBA
6202  1FBB
6203  1FBC
6204  1FBD
6205  1FBE
6206  1FBF
6207  1FC0
6208  1FC1
6209  1FC2
6210  1FC3
6211  1FC4
6212  1FC5
6213  1FC6
6214  1FC7
6215  1FC8
6216  1FC9
6217  1FCA
6218  1FCB
6219  1FCC
6220  1FCD
6221  1FCE
6222  1FCF
6223  1FD0
6224  1FD1
6225  1FD2
6226  1FD3
6227  1FD4
6228  1FD5
6229  1FD6
6230  1FD7
6231  1FD8
6232  1FD9
6233  1FDA
6234  1FDB
6235  1FDC
6236  1FDD
6237  1FDE
6238  1FDF
6239  1FE0
6240  1FE1
6241  1FE2
6242  1FE3
6243  1FE4
6244  1FE5
6245  1FE6
6246  1FE7
6247  1FE8
6248  1FE9
6249  1FEA
6250  1FEB
6251  1FEC
6252  1FED
6253  1FEE
6254  1FEF
6255  1FF0
6256  1FF1
6257  1FF2
6258  1FF3
6259  1FF4
6260  1FF5
6261  1FF6
6262  1FF7
6263  1FF8
6264  1FF9
6265  1FFA
6266  1FFB
6267  1FFC
6268  1FFD
6269  1FFE
6270  1FFF
6271  2000
6272  2001
6273  2002
6274  2003
6275  2004
6276  2005
6277  2006
6278  2007
6279  2008
6280  2009
6281  200A
6282  200B
6283  200C
6284  200D
6285  200E
6286  200F
6287  2010
6288  2011
6289  2012
6290  2013
6291  2014
6292  2015
6293  2016
6294  2017
6295  2018
6296  2019
6297  201A
6298  201B
6299  201C
6300  201D
6301  201E
6302  201F
6303  2020
6304  2021
6305  2022
6306  2023
6307  2024
6308  2025
6309  2026
6310  2027
6311  2028
6312  2029
6313  202A
6314  202B
6315  202C
6316  202D
6317  202E
6318  202F
6319  2030
6320  2031
6321  2032
6322  2033
6323  2034
6324  2035
6325  2036
6326  2037
6327  2038
6328  2039
6329  203A
6330  203B
6331  203C
6332  203D
6333  203E
6334  203F
6335  2040
6336  2041
6337  2042
6338  2043
6339  2044
6340  2045
6341  2046
6342  2047
6343  2048
6344  2049
6345  204A
6346  204B
6347  204C
6348  204D
6349  204E
6350  204F
6351  2050
6352  2051
6353  2052
6354  2053
6355  2054
6356  2055
6357  2056
6358  2057
6359  2058
6360  2059
6361  205A
6362  205B
6363  205C
6364  205D
6365  205E
6366  205F
6367  2060
6368  2061
6369  2062
6370  2063
6371  2064
6372  2065
6373  2066
6374  2067
6375  2068
6376  2069
6377  206A
6378  206B
6379  206C
6380  206D
6381  206E
6382  206F
6383  2070
6384  2071
6385  2072
6386  2073
6387  2074
6388  2075
6389  2076
6390  2077
6391  2078
6392  2079
6393  207A
6394  207B
6395  207C
6396  207D
6397  207E
6398  207F
6399  2080
6400  2081
6401  2082
6402  2083
6403  2084
6404  2085
6405  2086
6406  2087
6407  2088
6408  2089
6409  208A
6410  208B
6411  208C
6412  208D
6413  208E
6414  208F
6415  2090
6416  2091
6417  2092
6418  2093
6419  2094
6420  2095
6421  2096
6422  2097
6423  2098
6424  2099
6425  209A
6426  209B
6427  209C
6428  209D
6429  209E
6430  209F
6431  20A0
6432  20A1
6433  20A2
6434  20A3
6435  20A4
6436  20A5
6437  20A6
6438  20A7
6439  20A8
6440  20A9
6441  20AA
6442  20AB
6443  20AC
6444  20AD
6445  20AE
6446  20AF
6447  20B0
6448  20B1
6449  20B2
6450  20B3
6451  20B4
6452  20B5
6453  20B6
6454  20B7
6455  20B8
6456  20B9
6457  20BA
6458  20BB
6459  20BC
6460  20BD
6461  20BE
6462  20BF
6463  20C0
6464  20C1
6465  20C2
6466  20C3
6467  20C4
6468  20C5
6469  20C6
6470  20C7
6471  20C8
6472  20C9
6473  20CA
6474  20CB
6475  20CC
6476  20CD
6477  20CE
6478  20CF
6479  20D0
6480  20D1
6481  20D2
6482  20D3
6483  20D4
6484  20D5
6485  20D6
6486  20D7
6487  20D8
6488  20D9
6489  20DA
6490  20DB
6491  20DC
6492  20DD
6493  20DE
6494  20DF
6495  20E0
6496  20E1
6497  20E2
6498  20E3
6499  20E4
6500  20E5
6501  20E6
6502  20E7
6503  20E8
6504  20E9
6505  20EA
6506  20EB
6507  20EC
6508  20ED
6509  20EE
6510  20EF
6511  20F0
6512  20F1
6513  20F2
6514  20F3
6515  20F4
6516  20F5
6517  20F6
6518  20F7
6519  20F8
6520  20F9
6521  20FA
6522  20FB
6523  20FC
6524  20FD
6525  20FE
6526  20FF
6527  2100
6528  2101
6529  2102
6530  2103
6531  2104
6532  2105
6533  2106
6534  2107
6535  2108
6536  2109
6537  210A
6538  210B
6539  210C
6540  210D
6541  210E
6542  210F
6543  2110
6544  2111
6545  2112
6546  2113
6547  2114
6548  2115
6549  2116
6550  2117
6551  2118
6552  2119
6553  211A
6554  211B
6555  211C
6556  211D
6557  211E
6558  211F
6559  2120
6560  2121
6561  2122
6562  2123
6563  2124
6564  2125
6565  2126
6566  2127
6567  2128
6568  2129
6569  212A
6570  212B
6571  212C
6572  212D
6573  212E
6574  212F
6575  2130
6576  2131
6577  2132
6578  2133
6579  2134
6580  2135
6581  2136
6582  2137
6583  2138
6584  2139
6585  213A
6586  213B
6587  213C
6588  213D
6589  213E
6590  213F
6591  2140
6592  2141
6593  2142
6594  2143
6595  2144
6596  2145
6597  2146
6598  2147
6599  2148
6600  2149
6601  214A
6602  214B
6603  214C
6604  214D
6605  214E
6606  214F
6607  2150
6608  2151
6609  2152
6610  2153
6611  2154
6612  2155
6613  2156
6614  2157
6615  2158
6616  2159
6617  215A
6618  215B
6619  215C
6620  215D
6621  215E
6622  215F
6623  2160
6624  2161
6625  2162
6626  2163
6627  2164
6628  2165
6629  2166
6630  2167
6631  2168
6632  2169
6633  216A
6634  216B
6635  216C
6636  216D
6637  216E
6638  216F
6639  2170
6640  2171
6641  2172
6642  2173
6643  2174
6644  2175
6645  2176
6646  2177
6647  2178
6648  2179
6649  217A
6650  217B
6651  217C
6652  217D
6653  217E
6654  217F
6655  2180
6656  2181
6657  2182
6658  2183
6659  2184
6660  2185
6661  2186
6662  2187
6663  2188
6664  2189
6665  218A
6666  218B
6667  218C
6668  218D
6669  218E
6670  218F
6671  2190
6672  2191
6673  2192
6674  2193
6675  2194
6676  2195
6677  2196
6678  2197
6679  2198
6680  2199
6681  219A
6682  219B
6683  219C
6684  219D
6685  219E
6686  219F
6687  21A0
6688  21A1
6689  21A2
6690  21A3
6691  21A4
6692  21A5
6693  21A6
6694  21A7
6695  21A8
6696  21A9
6697  21AA
6698  21AB
6699  21AC
6700  21AD
6701  21AE
6702  21AF
6703  21B0
6704  21B1
6705  21B2
6706  21B3
6707  21B4
6708  21B5
6709  21B6
6710  21B7
6711  21B8
6712  21B9
6713  21BA
6714  21BB
6715  21BC
6716  21BD
6717  21BE
6718  21BF
6719  21C0
6720  21C1
6721  21C2
6722  21C3
6723  21C4
6724  21C5
6725  21C6
6726  21C7
6727  21C8
6728  21C9
6729  21CA
6730  21CB
6731  21CC
6732  21CD
6733  21CE
6734  21CF
6735  21D0
6736  21D1
6737  21D2
6738  21D3
6739  21D4
6740  21D5
6741  21D6
6742  21D7
6743  21D8
6744  21D9
6745  21DA
6746  21DB
6747  21DC
6748  21DD
6749  21DE
6750  21DF
6751  21E0
6752  21E1
6753  21E2
6754  21E3
6755  21E4
6756  21E5
6757  21E6
6758  21E7
6759  21E8
6760  21E9
6761  21EA
6762  21EB
6763  21EC
6764  21ED
6765  21EE
6766  21EF
6767  21F0
6768  21F1
6769  21F2
6770  21F3
6771  21F4
6772  21F5
6773  21F6
6774  21F7
6775  21F8
6776  21F9
6777  21FA
6778  21FB
6779  21FC
6780  21FD
6781  21FE
6782  21FF
6783  2200
6784  2201
6785  2202
6786  2203
6787  2204
6788  2205
6789  2206
6790  2207
6791  2208
6792  2209
6793  220A
6794  220B
6795  220C
6796  220D
6797  220E
6798  220F
6799  2210
6800  2211
6801  2212
6802  2213
6803  2214
6804  2215
6805  2216
6806  2217
6807  2218
6808  2219
6809  221A
6810  221B
6811  221C
6812  221D
6813  221E
6814  221F
6815  2220
6816  2221
6817  2222
6818  2223
6819  2224
6820  2225
6821  2226
6822  2227
6823  2228
6824  2229
6825  222A
6826  222B
6827  222C
6828  222D
6829  222E
6830  222F
6831  2230
6832  2231
6833  2232
6834  2233
6835  2234
6836  2235
6837  2236
6838  2237
6839  2238
6840  2239
6841  223A
6842  223B
6843  223C
6844  223D
6845  223E
6846  223F
6847  2240
6848  2241
6849  2242
6850  2243
6851  2244
6852  2245
6853  2246
6854  2247
6855  2248
6856  2249
6857  224A
6858  224B
6859  224C
6860  224D
6861  224E
6862  224F
6863  2250
6864  2251
6865  2252
6866  2253
6867  2254
6868  2255
6869  2256
6870  2257
6871  2258
6872  2259
6873  225A
6874  225B
6875  225C
6876  225D
6877  225E
6878  225F
6879  2260
6880  2261
6881  2262
6882  2263
6883  2264
6884  2265
6885  2266
6886  2267
6887  2268
6888  2269
6889  226A
6890  226B
6891  226C
6892  226D
6893  226E
6894  226F
6895  2270
6896  2271
6897  2272
6898  2273
6899  2274
6900  2275
6901  2276
6902  2277
6903  2278
6904  2279
6905  227A
6906  227B
6907  227C
6908  227D
6909  227E
6910  227F
6911  2280
6912  2281
6913  2282
6914  2283
6915  2284
6916  2285
6917  2286
6918  2287
6919  2288
6920  2289
6921  228A
6922  228B
6923  228C
6924  228D
6925  228E
6926  228F
6927  2290
6928  2291
6929  2292
6930  2293
6931  2294
6932  2295
6933  2296
6934  2297
6935  2298
6936  2299
6937  229A
6938  229B
6939  229C
6940  229D
6941  229E
6942  229F
6943  22A0
6944  22A1
6945  22A2
6946  22A3
6947  22A4
6948  22A5
6949  22A6
6950  22A7
6951  22A8
6952  22A9
6953  22AA
6954  22AB
6955  22AC
6956  22AD
6957  22AE
6958  22AF
6959  22B0
6960  22B1
6961  22B2
6962  22B3
6963  22B4
6964  22B5
6965  22B6
6966  22B7
6967  22B8
6968  22B9
6969  22BA
6970  22BB
6971  22BC
6972  22BD
6973  22BE
6974  22BF
6975  22C0
6976  22C1
6977  22C2
6978  22C3
6979  22C4
6980  22C5
6981  22C6
6982  22C7
6983  22C8
6984  22C9
6985  22CA
6986  22CB
6987  22CC
6988  22CD
6989  22CE
6990  22CF
6991  22D0
6992  22D1
6993  22D2
6994  22D3
6995  22D4
6996  22D5
6997  22D6
6998  22D7
6999  22D8
7000  22D9
7001  22DA
7002  22DB
7003  22DC
7004  22DD
7005  22DE
7006  22DF
7007  22E0
7008  22E1
7009  22E2
7010  22E3
7011  22E4
7012  22E5
7013  22E6
7014  22E7
7015  22E8
7016  22E9
7017  22EA
7018  22EB
7019  22EC
7020  22ED
7021  22EE
7022  22EF
7023  22F0
7024  22F1
7025  22F2
7026  22F3
7027  22F4
7028  22F5
7029  22F6
7030  22F7
7031  22F8
7032  22F9
7033  22FA
7034  22FB
7035  22FC
7036  22FD
7037  22FE
7038  22FF
7039  2300
7040  2301
7041  2302
7042  2303
7043  2304
7044  2305
7045  2306
7046  2307
7047  2308
7048  2309
7049  230A
7050  230B
7051  230C
7052  230D
7053  230E
7054  230F
7055  2310
7056  2311
7057  2312
7058  2313
7059  2314
7060  2315
7061  2316
7062  2317
7063  2318
7064  2319
7065  231A
7066  231B
7067  231C
7068  231D
7069  231E
7070  231F
7071  2320
7072  2321
7073  2322
7074  2323
7075  2324
7076  2325
7077  2326
7078  2327
7079  2328
7080  2329
7081  232A
7082  232B
7083  232C
7084  232D
7085  232E
7086  232F
7087  2330
7088  2331
7089  2332
7090  2333
7091  2334
7092  2335
7093  2336
7094  2337
7095  2338
7096  2339
7097  233A
7098  233B
7099  233C
7100  233D
7101  233E
7102  233F
7103  2340
7104  2341
7105  2342
7106  2343
7107  2344
7108  2345
7109  2346
7110  2347
7111  2348
7112  2349
7113  234A
7114  234B
7115  234C
7116  234D
7117  234E
7118  234F
7119  2350
7120  2351
7121  2352
7122  2353
7123  2354
7124  2355
7125  2356
7126  2357
7127  2358
7128  2359
7129  235A
7130  235B
7131  235C
7132  235D
7133  235E
7134  235F
7135  2360
7136  2361
7137  2362
7138  2363
7139  2364
7140  2365
7141  2366
7142  2367
7143  2368
7144  2369
7145  236A
7146  236B
7147  236C
7148  236D
7149  236E
7150  236F
7151  2370
7152  2371
7153  2372
7154  2373
7155  2374
7156  2375
7157  2376
7158  2377
7159  2378
7160  2379
7161  237A
7162  237B
7163  237C
7164  237D
7165  237E
7166  237F
7167  2380
7168  2381
7169  2382
7170  2383
7171  2384
7172  2385
7173  2386
7174  2387
7175  2388
7176  2389
7177  238A
7178  238B
7179  238C
7180  238D
7181  238E
7182  238F
7183  2390
7184  2391
7185  2392
7186  2393
7187  2394
7188  2395
7189  2396
7190  2397
7191  2398
7192  2399
7193  239A
7194  239B
7195  239C
7196  239D
7197  239E
7198  239F
7199  23A0
7200  23A1
7201  23A2
7202  23A3
7203  23A4
7204  23A5
7205  23A6
7206  23A7
7207  23A8
7208  23A9
7209  23AA
7210  23AB
7211  23AC
7212  23AD
7213  23AE
7214  23AF
7215  23B0
7216  23B1
7217  23B2
7218  23B3
7219  23B4
7220  23B5
7221  23B6
7222  23B7
7223  23B8
7224  23B9
7225  23BA
7226  23BB
7227  23BC
7228  23BD
7229  23BE
7230  23BF
7231  23C0
7232  23C1
7233  23C2
7234  23C3
7235  23C4
7236  23C5
7237  23C6
7238  23C7
7239  23C8
7240  23C9
7241  23CA
7242  23CB
7243  23CC
7244  23CD
7245  23CE
7246  23CF
7247  23D0
7248  23D1
7249  23D2
7250  23D3
7251  23D4
7252  23D5
7253  23D6
7254  23D7
7255  23D8
7256  23D9
7257  23DA
7258  23DB
7259  23DC
7260  23DD
7261  23DE
7262  23DF
7263  23E0
7264  23E1
7265  23E2
7266  23E3
7267  23E4
7268  23E5
7269  23E6
7270  23E7
7271  23E8
7272  23E9
7273  23EA
7274  23EB
7275  23EC
7276  23ED
7277  23EE
7278  23EF
7279  23F0
7280  23F1
7281  23F2
7282  23F3
7283  23F4
7284  23F5
7285  23F6
7286  23F7
7287  23F8
7288  23F9
7289  23FA
7290  23FB
7291  23FC
7292  23FD
7293  23FE
7294  23FF
7295  2400
7296  2401
7297  2402
7298  2403
7299  2404
7300  2405
7301  2406
7302  2407
7303  2408
7304  2409
7305  240A
7306  240B
7307  240C
7308  240D
7309  240E
7310  240F
7311  2410
7312  2411
7313  2412
7314  2413
7315  2414
7316  2415
7317  2416
7318  2417
7319  2418
7320  2419
7321  241A
7322  241B
7323  241C
7324  241D
7325  241E
7326  241F
7327  2420
7328  2421
7329  2422
7330  2423
7331  2424
7332  2425
7333  2426
7334  2427
7335  2428
7336  2429
7337  242A
7338  242B
7339  242C
7340  242D
7341  242E
7342  242F
7343  2430
7344  2431
7345  2432
7346  2433
7347  2434
7348  2435
7349  2436
7350  2437
7351  2438
7352  2439
7353  243A
7354  243B
7355  243C
7356  243D
7357  243E
7358  243F
7359  2440
7360  2441
7361  2442
7362  2443
7363  2444
7364  2445
7365  2446
7366  2447
7367  2448
7368  2449
7369  244A
7370  244B
7371  244C
7372  244D
7373  244E
7374  244F
7375  2450
7376  2451
7377  2452
7378  2453
7379  2454
7380  2455
7381  2456
7382  2457
7383  2458
7384  2459
7385  245A
7386  245B
7387  245C
7388  245D
7389  245E
7390  245F
7391  2460
7392  2461
7393  2462
7394  2463
7395  2464
7396  2465
7397  2466
7398  2467
7399  2468
7400  2469
7401  246A
7402  246B
7403  246C
7404  246D
7405  246E
7406  246F
7407  2470
7408  2471
7409  2472
7410  2473
7411  2474
7412  2475
7413  2476
7414  2477
7415  2478
7416  2479
7417  247A
7418  247B
7419  247C
7420  247D
7421  247E
7422  247F
7423  2480
7424  2481
7425  2482
7426  2483
7427  2484
7428  2485
7429  2486
7430  2487
7431  2488
7432  2489
7433  248A
7434  248B
7435  248C
7436  248D
7437  248E
7438  248F
7439  2490
7440  2491
7441  2492
7442  2493
7443  2494
7444  2495
7445  2496
7446  2497
7447  2498
7448  2499
7449  249A
7450  249B
7451  249C
7452  249D
7453  249E
7454  249F
7455  24A0
7456  24A1
7457  24A2
7458  24A3
7459  24A4
7460  24A5
7461  24A6
7462  24A7
7463  24A8
7464  24A9
7465  24AA
7466  24AB
7467  24AC
7468  24AD
7469  24AE
7470  24AF
7471  24B0
7472  24B1
7473  24B2
7474  24B3
7475  24B4
7476  24B5
7477  24B6
7478  24B7
7479  24B8
7480  24B9
7481  24BA
7482  24BB
7483  24BC
7484  24BD
7485  24BE
7486  24BF
7487  24C0
7488  24C1
7489  24C2
7490  24C3
7491  24C4
7492  24C5
7493  24C6
7494  24C7
7495  24C8
7496  24C9
7497  24CA
7498  24CB
7499  24CC
7500  24CD
7501  24CE
7502  24CF
7503  24D0
7504  24D1
7505  24D2
7506  24D3
7507  24D4
7508  24D5
7509  24D6
7510  24D7
7511  24D8
7512  24D9
7513  24DA
7514  24DB
7515  24DC
7516  24DD
7517  24DE
7518  24DF
7519  24E0
7520  24E1
7521  24E2
7522  24E3
7523  24E4
7524  24E5
7525  24E6
7526  24E7
7527  24E8
7528  24E9
7529  24EA
7530  24EB
7531  24EC
7532  24ED
7533  24EE
7534  24EF
7535  24F0
7536  24F1
7537  24F2
7538  24F3
7539  24F4
7540  24F5
7541  24F6
7542  24F7
7543  24F8
7544  24F9
7545  24FA
7546  24FB
7547  24FC
7548  24FD
7549  24FE
7550  24FF
7551  2500
7552  2501
7553  2502
7554  2503
7555  2504
7556  2505
7557  2506
7558  2507
7559  2508
7560  2509
7561  250A
7562  250B
7563  250C
7564  250D
7565  250E
7566  250F
7567  2510
7568  2511
7569  2512
7570  2513
7571  2514
7572  2515
7573  2516
7574  2517
7575  2518
7576  2519
7577  251A
7578  251B
7579  251C
7580  251D
7581  251E
7582  251F
7583  2520
7584  2521
7585  2522
7586  2523
7587  2524
7588  2525
7589  2526
7590  2527
7591  2528
7592  2529
7593  252A
7594  252B
7595  252C
7596  252D
7597  252E
7598  252F
7599  2530
7600  2531
7601  2532
7602  2533
7603  2534
7604  2535
7605  2536
7606  2537
7607  2538
7608  2539
7609  253A
7610  253B
7611  253C
7612  253D
7613  253E
7614  253F
7615  2540
7616  2541
7617  2542
7618  2543
7619  2544
7620  2545
7621  2546
7622  2547
7623  2548
7624  2549
7625  254A
7626  254B
7627  254C
7628  254D
7629  254E
7630  254F
7631  2550
7632  2551
7633  2552
7634  2553
7635  2554
7636  2555
7637  2556
7638  2557
7639  2558
7640  2559
7641  255A
7642  255B
7643  255C
7644  255D
7645  255E
7646  255F
7647  2560
7648  2561
7649  2562
7650  2563
7651  2564
7652  2565
7653  2566
7654  2567
7655  2568
7656  2569
7657  256A
7658  256B
7659  256C
7660  256D
7661  256E
7662  256F
7663  2570
7664  2571
7665  2572
7666  2573
7667  2574
7668  2575
7669  2576
7670  2577
7671  2578
7672  2579
7673  257A
7674  257B
7675  257C
7676  257D
7677  257E
7678  257F
7679  2580
7680  2581
7681  2582
7682  2583
7683  2584
7684  2585
7685  2586
7686  2587
7687  2588
7688  2589
7689  258A
7690  258B
7691  258C
7692  258D
7693  258E
7694  258F
7695  2590
7696  2591
7697  2592
7698  2593
7699  2594
7700  2595
7701  2596
7702  2597
7703  2598
7704  2599
7705  259A
7706  259B
7707  259C
7708  259D
7709  259E
7710  259F
7711  25A0
7712  25A1
7713  25A2
7714  25A3
7715  25A4
7716  25A5
7717  25A6
7718  25A7
7719  25A8
7720  25A9
7721  25AA
7722  25AB
7723  25AC
7724  25AD
7725  25AE
7726  25AF
7727  25B0
7728  25B1
7729  25B2
7730  25B3
7731  25B4
7732  25B5
7733  25B6
7734  25B7
7735  25B8
7736  25B9
7737  25BA
7738  25BB
7739  25BC
7740  25BD
7741  25BE
7742  25BF
7743  25C0
7744  25C1
7745  25C2
7746  25C3
7747  25C4
7748  25C5
7749  25C6
7750  25C7
7751  25C8
7752  25C9
7753  25CA
7754  25CB
7755  25CC
7756  25CD
7757  25CE
7758  25CF
7759  25D0
7760  25D1
7761  25D2
7762  25D3
7763  25D4
7764  25D5
7765  25D6
7766  25D7
7767  25D8
7768  25D9
7769  25DA
7770  25DB
7771  25DC
7772  25DD
7773  25DE
7774  25DF
7775  25E0
7776  25E1
7777  25E2
7778  25E3
7779  25E4
7780  25E5
7781  25E6
7782  25E7
7783  25E8
7784  25E9
7785  25EA
7786  25EB
7787  25EC
7788  25ED
7789  25EE
7790  25EF
7791  25F0
7792  25F1
7793  25F2
7794  25F3
7795  25F4
7796  25F5
7797  25F6
7798  25F7
7799  25F8
7800  25F9
7801  25FA
7802  25FB
7803  25FC
7804  25FD
7805  25FE
7806  25FF
7807  2600
7808  2601
7809  2602
7810  2603
7811  2604
7812  2605
7813  2606
7814  2607
7815  2608
7816  2609
7817  260A
7818  260B
7819  260C
7820  260D
7821  260E
7822  260F
7823  2610
7824  2611
7825  2612
7826  2613
7827  2614
7828  2615
7829  2616
7830  2617
7831  2618
7832  2619
7833  261A
7834  261B
7835  261C
7836  261D
7837  261E
7838  261F
7839  2620
7840  2621
7841  2622
7842  2623
7843  2624
7844  2625
7845  2626
7846  2627
7847  2628
7848  2629
7849  262A
7850  262B
7851  262C
7852  262D
7853  262E
7854  262F
7855  2630
7856  2631
7857  2632
7858  2633
7859  2634
7860  2635
7861  2636
7862  2637
7863  2638
7864  2639
7865  263A
7866  263B
7867  263C
7868  263D
7869  263E
7870  263F
7871  2640
7872  2641
7873  2642
7874  2643
7875  2644
7876  2645
7877  2646
7878  2647
7879  2648
7880  2649
7881  264A
7882  264B
7883  264C
7884  264D
7885  264E
7886  264F
7887  2650
7888  2651
7889  2652
7890  2653
7891  2654
7892  2655
7893  2656
7894  2657
7895  2658
7896  2659
7897  265A
7898  265B
7899  265C
7900  265D
7901  265E
7902  265F
7903  2660
7904  2661
7905  2662
7906  2663
7907  2664
7908  2665
7909  2666
7910  2667
7911  2668
7912  2669
7913  266A
7914  266B
7915  266C
7916  266D
7917  266E
7918  266F
7919  2670
7920  2671
7921  2672
7922  2673
7923  2674
7924  2675
7925  2676
7926  2677
7927  2678
7928  2679
7929  267A
7930  267B
7931  267C
7932  267D
7933  267E
7934  267F
7935  2680
7936  2681
7937  2682
7938  2683
7939  2684
7940  2685
7941  2686
7942  2687
7943  2688
7944  2689
7945  268A
7946  268B
7947  268C
7948  268D
7949  268E
7950  268F
7951  2690
7952  2691
7953  2692
7954  2693
7955  2694
7956  2695
7957  2696
7958  2697
7959  2698
7960  2699
7961  269A
7962  269B
7963  269C
7964  269D
7965  269E
7966  269F
7967  26A0
7968  26A1
7969  26A2
7970  26A3
7971  26A4
7972  26A5
7973  26A6
7974  26A7
7975  26A8
7976  26A9
7977  26AA
7978  26AB
7979  26AC
7980  26AD
7981  26AE
7982  26AF
7983  26B0
7984  26B1
7985  26B2
7986  26B3
7987  26B4
7988  26B5
7989  26B6
7990  26B7
7991  26B8
7992  26B9
7993  26BA
7994  26BB
7995  26BC
7996  26BD
7997  26BE
7998  26BF
7999  26C0
8000  26C1
8001  26C2
8002  26C3
8003  26C4
8004  26C5
8005  26C6
8006  26C7
8007  26C8
8008  26C9
8009  26CA
8010  26CB
8011  26CC
8012  26CD
8013  26CE
8014  26CF
8015  26D0
8016  26D1
8017  26D2
8018  26D3
8019  26D4
8020  26D5
8021  26D6
8022  26D7
8023  26D8
8024  26D9
8025  26DA
8026  26DB
8027  26DC
8028  26DD
8029  26DE
8030  26DF
8031  26E0
8032  26E1
8033  26E2
8034  26E3
8035  26E4
8036  26E5
8037  26E6
8038  26E7
8039  26E8
8040  26E9
8041  26EA
8042  26EB
8043  26EC
8044  26ED
8045  26EE
8046  26EF
8047  26F0
8048  26F1
8049  26F2
8050  26F3
8051  26F4
8052  26F5
8053  26F6
8054  26F7
8055  26F8
8056  26F9
8057  26FA
8058  26FB
8059  26FC
8060  26FD
8061  26FE
8062  26FF
8063  2700
8064  2701
8065  2702
8066  2703
8067  2704
8068  2705
8069  2706
8070  2707
8071  2708
8072  2709
8073  270A
8074  270B
8075  270C
8076  270D
8077  270E
8078  270F
8079  2710
8080  2711
8081  2712
8082  2713
8083  2714
8084  2715
8085  2716
8086  2717
8087  2718
8088  2719
8089  271A
8090  271B
8091  271C
8092  271D
8093  271E
8094  271F
8095  2720
8096  2721
8097  2722
8098  2723
8099  2724
8100  2725
8101  2726
8102  2727
8103  2728
8104  2729
8105  272A
8106  272B
8107  272C
8108  272D
8109  272E
8110  272F
8111  2730
8112  2731
8113  2732
8114  2733
8115  2734
8116  2735
8117  2736
8118  2737
8119  2738
8120  2739
8121  273A
8122  273B
8123  273C
8124  273D
8125  273E
8126  273F
8127  2740
8128  2741
8129  2742
8130  2743
8131  2744
8132  2745
8133  2746
8134  2747
8135  2748
8136  2749
8137  274A
8138  274B
8139  274C
8140  274D
8141  274E
8142  274F
8143  2750
8144  2751
8145  2752
8146  2753
8147  2754
8148  2755
8149  2756
8150  2757
8151  2758
8152  2759
8153  275A
8154  275B
8155  275C
8156  275D
8157  275E
8158  275F
8159  2760
8160  2761
8161  2762
8162  2763
8163  2764
8164  2765
8165  2766
8166  2767
8167  2768
8168  2769
8169  276A
8170  276B
8171  276C
8172  276D
8173  276E
8174  276F
8175  2770
8176  2771
8177  2772
8178  2773
8179  2774
8180  2775
8181  2776
8182  2777
8183  2778
8184  2779
8185  277A
8186  277B
8187  277C
8188  277D
8189  277E
8190  277F
8191  2780
8192  2781
8193  2782
8194  2783
8195  2784
8196  2785
8197  2786
8198  2787
8199  2788
8200  2789
8201  278A
8202  278B
8203  278C
8204  278D
8205  278E
8206  278F
8207  2790
8208  2791
8209  2792
8210  2793
8211  2794
8212  2795
8213  2796
8214  2797
8215  2798
8216  2799
8217  279A
8218  279B
8219  279C
8220  279D
8221  279E
8222  279F
8223  27A0
8224  27A1
8225  27A2
8226  27A3
8227  27A4
8228  27A5
8229  27A6
8230  27A7
8231  27A8
8232  27A9
8233  27AA
8234  27AB
8235  27AC
8236  27AD
8237  27AE
8238  27AF
8239  27B0
8240  27B1
008241  000364        
008242  000365  var hFonts[28] ;
008243  000366  var stringsCV[28] := [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], hstrings ;
8244  1414
8245  1415
8246  1416
8247  1417
8248  1418
8249  1419
8250  141A
8251  141B
8252  141C
8253  141D
8254  141E
8255  141F
8256  1420
8257  1421
8258  1422
8259  1423
8260  1424
8261  1425
8262  1426
8263  1427
8264  1428
8265  1429
8266  142A
8267  142B
8268  142C
8269  142D
8270  142E
8271  142F
8272  1430
8273  1431
8274  1432
8275  1433
8276  1434
8277  1435
8278  1436
8279  1437
8280  1438
8281  1439
8282  143A
8283  143B
8284  143C
8285  143D
8286  143E
8287  143F
8288  1440
8289  1441
8290  1442
8291  1443
8292  1444
8293  1445
8294  1446
8295  1447
8296  1448
8297  1449
8298  144A
8299  144B
008300  000367  // Start P2.inc
008301  000368  var oObjects[MaxTotObjects+1] ;                 // address of objects
008302  000369  var curform ;
008303  000370  var x, y ;
008304  000371  var inputtype, TState, input, object ;
008305  000372  var comRX[40], cmd[CMDLenMAX] ;
008306  000373        
008307  000374  var cs, Ocs ;
008308  000375        
008309  000376  func seroutCS(var op)
008310  000377      serout(op) ;
008311  000378      Ocs ^= op ;
008312  000379  endfunc
008313  000380        
008314  000381  func seroutOcs()
008315  000382      serout(Ocs) ;
008316  000383      Ocs := 0 ;
008317  000384  endfunc
008318  000385        
008319  000386        
008320  000387  func ReadObject(var ObjectType, var ObjectIdx)
008321  000388      var j, k, Objects ;
008322  000389      Objects := *(oObjects+ObjectType) ;
008323  000390        
008324  000391      seroutCS(REPORT_OBJ) ;
008325  000392      seroutCS(ObjectType) ;
008326  000393      seroutCS(ObjectIdx) ;
008327  000394      j := 2 + ObjectIdx * 2 + Objects ;
008328  000395       if (ObjectType == tForm)
008329  000396          k := curform ;
008330  000397      else if ((ObjectType == tCustomdigits) || (ObjectType == tLeddigits))
008331  000398          k := img_GetWord(hndl, *j, IMAGE_TAG2);
008332  000399      else if (ObjectType == tStrings)
008333  000400          k := stringsCV[ObjectIdx];
008334  000401          else
008335  000402          k := img_GetWord(hndl, *j, IMAGE_INDEX);
008336  000403          if (((ObjectType == tWinButton) || (ObjectType == tAniButton) || (ObjectType == tUserButton) || (ObjectType == t4Dbutton)) && (k)) k := 1 ; // this is not correct for blocked buttons and cannot be fixed as we cannot 
008337  000404                                                                                                                                                      // determine if button is momentary or not which is needed for correct answer.
008338  000405      endif
008339  000406      seroutCS(k >> 8) ; // first 8 bits
008340  000407      seroutCS(k) ;
008341  000408      seroutOcs() ;
008342  000409  endfunc
008343  000410        
008344  000411        
008345  000412  func WriteObject(var ObjectType, var ObjectIdx, var NewVal)
008346  000413      var i, j, k, Objects ;
008347  000414      ObjectType &= 0x3f ;
008348  000415      if (ObjectType == tForm)
008349  000416          ActivateForm(ObjectIdx) ;
008350  000417      else
008351  000418          Objects := *(oObjects+ObjectType)+ObjectIdx*2+2 ;
008352  000419          i := *(Objects) ;
008353  000420          switch (ObjectType)
008354  000421              case tWinButton :
008355  000422                  j := IPControls[oWinButtons[ObjectIdx+1]] ;
008356  000423                  break ;
008357  000424              case tUserButton :
008358  000425                  j := IPControls[oUserButtons[ObjectIdx+1]] ;
008359  000426                  break ;
008360  000427              default : j := -1 ;
008361  000428          endswitch
008362  000429          if (j != -1) 
008363  000430              k := img_GetWord(hndl, i , IMAGE_INDEX) ;
008364  000431              NewVal := NewVal << 1 ;  
008365  000432              if (OVF())      // button group index change
008366  000433                  if (*(j+IPData+IPD_P1))   
008367  000434                      k &= 1 ;    // mask off old group index for momentary
008368  000435                  else
008369  000436                      k &= 3 ;    // mask off old group index for toggle
008370  000437                  endif
008371  000438              else            // normal set
008372  000439                  if (*(j+IPData+IPD_P2) != -1) TurnOffButtons(*(j+IPData+IPD_P2)) ;
008373  000440                  k &= 0xfffc ;    // retain only group index for state set
008374  000441              endif
008375  000442              NewVal |= k ;
008376  000443          endif
008377  000444           if (ObjectType == tLeddigits)
008378  000445              img_SetWord(hndl, i , IMAGE_TAG2, NewVal); // where state is 0 to 2
008379  000446              ledDigitsDisplay(i, oLeddigitss, OPDataL) ;
008380  000447          else if (ObjectType == tStrings)
008381  000448              PrintStrings(ObjectIdx, NewVal, 0);
008382  000449          else
008383  000450              img_SetWord(hndl, i , IMAGE_INDEX, NewVal); // where state is 0 to 2
008384  000451              img_Show(hndl, i) ; // will only display if form is current
008385  000452          endif
008386  000453      endif
008387  000454  endfunc
008388  000455        
008389  000456  func TurnOffButtons(var group)
008390  000457      var j, k, l;
008391  000458      for (j := 0; j < nInputs; j++)
008392  000459          k := j*IPDatasize ;
008393  000460          if (*(IPData+k+IPD_P2) == group)
008394  000461              l := -1 ;
008395  000462               if (*(IPData+k) == tWinButton)
008396  000463                  l := oWinButtons[*(IPData+k+IPD_OBJVidx)/2] ;
008397  000464                  img_SetWord(hndl, l, IMAGE_INDEX, 0);
008398  000465                  img_Show(hndl, l);      // only shows on current form
008399  000466              else if (*(IPData+k) == tUserButton)
008400  000467                  l := oUserButtons[*(IPData+k+IPD_OBJVidx)/2] ;
008401  000468                  img_SetWord(hndl, l, IMAGE_INDEX, img_GetWord(hndl, l, IMAGE_INDEX) & 0xfffc );
008402  000469                  img_Show(hndl, l);      // only shows on current form
008403  000470              endif
008404  000471          endif
008405  000472      next
008406  000473  endfunc
008407  000474        
008408  000475        
008409  000476  // WARNING, this code will crash if newval exceeds maximum displayable number
008410  000477  func ledDigitsDisplay(var imgidx, var typeptr, var setptr)
008411  000478      var i, j, k, l, lb, newval ;
008412  000479      if (!((img_GetWord(hndl, imgidx, IMAGE_FLAGS) & I_ENABLED))) return ;  // ;img_GetWord(hndl, imgidx, IMAGE_TAG2) ;if diabled then exit
008413  000480      newval := img_GetWord(hndl, imgidx, IMAGE_TAG2) ;
008414  000481      i := -1 ;
008415  000482      j := *(typeptr) ;
008416  000483      repeat
008417  000484          typeptr += 2 ;
008418  000485          i++ ;
008419  000486          until (*(typeptr) == imgidx);
008420  000487      j := setptr + i*10 ;
008421  000488        
008422  000489      imgidx++ ;
008423  000490      l := 1 ;
008424  000491      for (i := 1; i < *(j+iDigits); i++)
008425  000492          l *= 10 ;
008426  000493      next
008427  000494      lb := *(j+iLeadingBlanks) ;
008428  000495      for (i := 0; i < *(j+iDigits); i++)
008429  000496          k := newval / l ;
008430  000497          newval -= k * l ;
008431  000498          if ( lb && (i < *(j+iDigits) - *(j+iMinDigits)) )
008432  000499              if (k == 0)
008433  000500                  k := 10 ;
008434  000501              else
008435  000502                  lb := 0 ;
008436  000503              endif
008437  000504          endif
008438  000505          l /= 10 ;
008439  000506          img_SetWord(hndl, imgidx, IMAGE_INDEX, k);
008440  000507          img_SetWord(hndl, imgidx, IMAGE_XPOS, *(j+ileft)+i* *(j+iWidthDigit)) ;
008441  000508          img_Show(hndl, imgidx);
008442  000509      next
008443  000510  endfunc
008444  000511        
008445  000512        
008446  000513  func ActivateForm(var newform)
008447  000514      var i, j, *p ;
008448  000515      if (curform != -1) // deactivate old form, by disabling all inputs
008449  000516          for (i := formstidx[curform]; i <= formenidx[curform]; i++)
008450  000517              if (img_GetWord(hndl, i, IMAGE_TAG))
008451  000518                  img_Disable(hndl,i) ;
008452  000519              endif
008453  000520          next
008454  000521      endif
008455  000522      curform := newform ;
008456  000523      // display newform image or clear to image color
008457  000524      if (formBGcol[curform] != BGIMAGE)
008458  000525          gfx_Set(BACKGROUND_COLOUR,formBGcol[curform]);
008459  000526          gfx_Cls() ;
008460  000527          DoGFXObjects() ;                                    // display GFX 'widgets'
008461  000528      endif
008462  000529        
008463  000530      // enable inputs
008464  000531      for (i := formstidx[curform]; i < formenidx[curform]; i++)
008465  000532          j := img_GetWord(hndl, i, IMAGE_TAG) ;
008466  000533          if (j)
008467  000534              j-- ;
008468  000535              img_SetAttributes(hndl, i, I_STAYONTOP+I_ENABLED);        // make sure this is on top of form, if applicable
008469  000536              //if (j != tKeyboard)
008470  000537              if ((j <= tWinButton) || (j >= t4Dbutton) )               // enable inputs
008471  000538                  img_ClearAttributes(hndl, i, I_TOUCH_DISABLE);        // ensure touch is enabled
008472  000539              endif
008473  000540              img_Show(hndl,i) ; // show initialy, if required
008474  000541              if (j == tForm)
008475  000542                  DoGFXObjects() ;                                    // display GFX 'widgets' for image backgruobds
008476  000543              else if (j == tLeddigits)
008477  000544                  ledDigitsDisplay(i, oLeddigitss, OPDataL) ;
008478  000545              endif
008479  000546          endif
008480  000547      next
008481  000548      for (i := 0; i < oStringss[0]; i++)
008482  000549          if (stringsCV[i] != -1)
008483  000550              WriteObject(tStrings, i, stringsCV[i]) ;
008484  000551          endif
008485  000552      next
008486  000553  endfunc
008487  000554        
008488  000555  func UpdateObjects(var newval)
008489  000556      var IPidx, otherOBJ ;
008490  000557      if ( ( img_GetWord(hndl, *(object), IMAGE_INDEX) != newval) || (TState == IPD_RELEASE) ) // only bother if values changed, or release
008491  000558        
008492  000559          img_SetWord(hndl, *(object), IMAGE_INDEX, newval);
008493  000560  // temp for **User??       if ((inputtype != tUserButton) || (!*(input+IPD_P1)))
008494  000561              img_Show(hndl, *(object));      // only shows on current form
008495  000562  //        endif
008496  000563          if ((inputtype == t4Dbutton) || (inputtype == tUserButton) || (inputtype == tWinButton)) 
008497  000564              if (*(input+IPD_P1))
008498  000565                  newval &= 1;
008499  000566              else
008500  000567                  newval &= 3;
008501  000568              endif
008502  000569              if (newval > 1) newval := 1;
008503  000570          endif
008504  000571          IPidx := *(input+TState) ;
008505  000572          while(IPidx != 0)
008506  000573              otherOBJ := IPidx + IPData;
008507  000574              if (*(otherOBJ) == OT_REPORT)
008508  000575                  seroutCS(REPORT_EVENT) ;
008509  000576                  seroutCS(inputtype) ;
008510  000577                  seroutCS(*(otherOBJ+IPD_OBJVidx)) ;
008511  000578                  seroutCS(newval >> 8) ;
008512  000579                  seroutCS(newval) ;
008513  000580                  seroutOcs() ;
008514  000581              else if (TState == *(otherOBJ+IPD_P4))
008515  000582                  if (*(otherOBJ) == OT_ACTIVATE)
008516  000583                      ActivateForm(*(otherOBJ+IPD_P2) ) ;
008517  000584                      inputtype := tForm ;
008518  000585                  else if (*(otherOBJ) == OT_SETCONST)
008519  000586                      newval := *(otherOBJ+IPD_P3) ;
008520  000587                      WriteObject(*(otherOBJ+IPD_P1), *(otherOBJ+IPD_P2), newval) ;
008521  000588                  else if (*(otherOBJ) == OT_SETANOTHER)
008522  000589                      WriteObject(*(otherOBJ+IPD_P1), *(otherOBJ+IPD_P2), newval) ;
008523  000590                  else if (*(otherOBJ) == OT_PREVFRAME)
008524  000591                      if (img_GetWord(hndl, *(otherOBJ+IPD_P6), IMAGE_INDEX))
008525  000592                          WriteObject(*(otherOBJ+IPD_P5),*(otherOBJ+IPD_P2),img_GetWord(hndl, *(otherOBJ+IPD_P6), IMAGE_INDEX)-1) ;
008526  000593                      endif
008527  000594                      newval := img_GetWord(hndl, *(otherOBJ+IPD_P6), IMAGE_INDEX) ;
008528  000595                  else if (*(otherOBJ) == OT_NEXTFRAME)
008529  000596                      if (img_GetWord(hndl, *(otherOBJ+IPD_P6), IMAGE_INDEX) < *(otherOBJ+IPD_P3)) 
008530  000597                          WriteObject(*(otherOBJ+IPD_P5),*(otherOBJ+IPD_P2),img_GetWord(hndl, *(otherOBJ+IPD_P6), IMAGE_INDEX)+1) ;
008531  000598                      endif
008532  000599                      newval := img_GetWord(hndl, *(otherOBJ+IPD_P6), IMAGE_INDEX) ;
008533  000600                  else if (*(otherOBJ) == OT_PREVSTRING)
008534  000601                      if (stringsCV[*(otherOBJ+IPD_P2)])
008535  000602                          WriteObject(tStrings,*(otherOBJ+IPD_P2),stringsCV[*(otherOBJ+IPD_P2)]-1) ;
008536  000603                      endif
008537  000604                  else if (*(otherOBJ) == OT_NEXTSTRING)
008538  000605                      if (stringsCV[*(otherOBJ+IPD_P2)] < *(otherOBJ+IPD_P3)) // fix IPD_P2 not filled in yet
008539  000606                          WriteObject(tStrings,*(otherOBJ+IPD_P2),stringsCV[*(otherOBJ+IPD_P2)]+1) ;
008540  000607                      endif
008541  000608                  endif
008542  000609              endif
008543  000610              IPidx := *(otherOBJ+TState) ;
008544  000611          wend
008545  000612      endif
008546  000613  endfunc
008547  000614        
008548  000615  // End P2.inc
008549  000616  func DoGFXObjects()
008550  000617      switch (curform)
008551  000618          case 2:
008552  000619              gfx_Panel(PANEL_RAISED, 80, 44, 162, 135, WHEAT) ;
008553  000620          break ;
008554  000621      endswitch
008555  000622  endfunc
008556  000623        
008557  000624  // Start P3.inc
008558  000625  func main()
008559  000626      var comTX[50], cmdi, i, j, n, state, oldn ;
008560  000627      putstr("Mounting...\n");
008561  000628      if (!(disk:=file_Mount()))
008562  000629          while(!(disk :=file_Mount()))
008563  000630              putstr("Drive not mounted...");
008564  000631              pause(200);
008565  000632              gfx_Cls();
008566  000633              pause(200);
008567  000634          wend
008568  000635      endif
008569  000636  //    gfx_MoveTo(0, 0);
008570  000637  //    print(mem_Heap()," ") ;
008571  000638  //    gfx_TransparentColour(0x0020);
008572  000639  //    gfx_Transparency(ON);
008573  000640        
008574  000641      gfx_ScreenMode(LANDSCAPE_R) ;
008575  000642        
008576  000643      // open image control
008577  000644      hndl := file_LoadImageControl("REPRAP~1.dat", "REPRAP~1.gci", 1);
008578  000645        
008579  000646      // init 'constants'
008580  000647  // End P3.inc
008581  000648        
008582  000649      oObjects[tDipSwitch] := oDipSwitchs ;
008583  000650      oObjects[tKnob] := oKnobs ;
008584  000651      oObjects[tRockerSwitch] := oRockerSwitchs ;
008585  000652      oObjects[tRotarySwitch] := oRotarySwitchs ;
008586  000653      oObjects[tGSlider] := oGSliders ;
008587  000654      oObjects[tTrackbar] := oTrackbars ;
008588  000655      oObjects[tWinButton] := oWinButtons ;
008589  000656      oObjects[tAngularmeter] := oAngularmeters ;
008590  000657      oObjects[tCoolgauge] := oCoolgauges ;
008591  000658      oObjects[tCustomdigits] := oCustomdigitss ;
008592  000659      oObjects[tForm] := oForms ;
008593  000660      oObjects[tGauge] := oGauges ;
008594  000661      oObjects[tImage] := oImages ;
008595  000662      oObjects[tKeyboard] := oKeyboards ;
008596  000663      oObjects[tLed] := oLeds ;
008597  000664      oObjects[tLeddigits] := oLeddigitss ;
008598  000665      oObjects[tMeter] := oMeters ;
008599  000666      oObjects[tStrings] := oStringss ;
008600  000667      oObjects[tThermometer] := oThermometers ;
008601  000668      oObjects[tUserled] := oUserleds ;
008602  000669      oObjects[tVideo] := oVideos ;
008603  000670      oObjects[tStaticText] := oStaticTexts ;
008604  000671      oObjects[tSounds] := oSoundss ;
008605  000672      oObjects[tTimer] := oTimers ;
008606  000673      oObjects[tSpectrum] := oSpectrums ;
008607  000674      oObjects[tTank] := oTanks ;
008608  000675      oObjects[tUserImages] := oUserImagess ;
008609  000676      oObjects[tPinOutput] := oPinOutputs ;
008610  000677      oObjects[tPinInput] := oPinInputs ;
008611  000678      oObjects[t4Dbutton] := o4Dbuttons ;
008612  000679      oObjects[tAniButton] := oAniButtons ;
008613  000680      oObjects[tColorPicker] := oColorPickers ;
008614  000681      oObjects[tUserButton] := oUserButtons ;
008615  000682      hFonts[0] := FONT3 ;
008616  000683      hFonts[1] := FONT3 ;
008617  000684      hFonts[2] := FONT3 ;
008618  000685      hFonts[3] := FONT3 ;
008619  000686      hFonts[4] := FONT3 ;
008620  000687      hFonts[5] := FONT3 ;
008621  000688      hFonts[6] := FONT3 ;
008622  000689      hFonts[7] := FONT3 ;
008623  000690      hFonts[8] := FONT3 ;
008624  000691      hFonts[9] := FONT3 ;
008625  000692      hFonts[10] := FONT3 ;
008626  000693      hFonts[11] := FONT3 ;
008627  000694      hFonts[12] := FONT3 ;
008628  000695      hFonts[13] := FONT3 ;
008629  000696      hFonts[14] := FONT3 ;
008630  000697      hFonts[15] := FONT3 ;
008631  000698      hFonts[16] := FONT3 ;
008632  000699      hFonts[17] := FONT3 ;
008633  000700      hFonts[18] := FONT3 ;
008634  000701      hFonts[19] := FONT3 ;
008635  000702      hFonts[20] := FONT3 ;
008636  000703      hFonts[21] := FONT3 ;
008637  000704      hFonts[22] := FONT3 ;
008638  000705      hFonts[23] := FONT3 ;
008639  000706      hFonts[24] := FONT3 ;
008640  000707      hFonts[25] := file_LoadImageControl("REPRAP~1.da1", "REPRAP~1.gc1", 1)  ;
008641  000708      hFonts[26] := hFonts[25] ;
008642  000709      hFonts[27] := hFonts[25] ;
008643  000710  // Start P4.inc
008644  000711      hstrings := file_Open("REPRAP~1.txf", 'r') ; // Open handle to access uSD strings, uncomment if required
008645  000712      // init comms
008646  000713      com_Init(comRX,CMDLenMAX,0);
008647  000714      com_SetBaud(COM0,20000);
008648  000715      com_TXbuffer(comTX, 100, 0);
008649  000716      snd_BufSize(2) ;
008650  000717      // tag 'real' objects
008651  000718      for (i := 0; i <= MaxTotObjects; i++)
008652  000719          if (   (i != tSounds)
008653  000720              && (i != tTimer)
008654  000721              && (i != tPinOutput)
008655  000722              && (i != tPinInput) )
008656  000723              x := oObjects[i] ;
008657  000724              y := *(x) ;
008658  000725              for (n := 1; n <= y; n++)
008659  000726                  oldn := *(x+n*2) ;
008660  000727                  img_SetAttributes(hndl, oldn, I_TOUCH_DISABLE);  // ensure touch is enabled
008661  000728                  if (oldn != -1)
008662  000729                      img_SetWord(hndl, oldn, IMAGE_TAG, i+1);
008663  000730                      img_Disable(hndl, oldn) ;
008664  000731                  endif
008665  000732              next
008666  000733          endif
008667  000734      next
008668  000735        
008669  000736      // display initial form
008670  000737      curform := -1 ;
008671  000738      ActivateForm(0) ; // need to change this according to first actual form
008672  000739  // End P4.inc
008673  000740  // Start P5.inc
008674  000741      touch_Set(TOUCH_ENABLE);                            // enable the touch screen
008675  000742      oldn := -1 ;
008676  000743      repeat
008677  000744          // check comms for command, how to NAK invalid command
008678  000745          if (com_Count() != 0)
008679  000746              i := serin() ;
008680  000747              cs ^= i ;               // update checksum
008681  000748              if (   (cmdi > 2)
008682  000749                  && (cmd[0] == WRITE_STRU) )
008683  000750                  j := (cmdi-1) >> 1 + 2 ;
008684  000751                  if (j == CMDLenMAX)    // max length exceeded
008685  000752                      serout(NAK) ;
008686  000753                      cs := 0 ;
008687  000754                      cmdi := -1 ;
008688  000755                  else if (cmdi & 1)
008689  000756                      cmd[j] := i ;
008690  000757                      if (cmd[2] == 0)    // if string complete
008691  000758                          if (cs)
008692  000759                              serout(NAK) ;
008693  000760                              cs := 0 ;
008694  000761                          else
008695  000762                              cmd[j] := 0 ;                     // terminate it
008696  000763                              PrintStrings(cmd[1], &cmd[3], 1) ;
008697  000764                              serout(ACK) ;
008698  000765                          endif
008699  000766                          cmdi := -1 ;
008700  000767                      endif
008701  000768                  else
008702  000769                      cmd[j] := cmd[j] << 8 + i ;
008703  000770                      cmd[2]-- ;          // dec length
008704  000771                  endif
008705  000772                  cmdi++ ;
008706  000773              else // not unicode string
008707  000774                  cmd[cmdi++] := i ;
008708  000775                   if (cmd[0] == WRITE_STR)        // ansi string
008709  000776                      if (cmdi == CMDLenMAX)      // max length exceeded
008710  000777                          serout(NAK) ;
008711  000778                          cs := 0 ;
008712  000779                          cmdi := 0 ;
008713  000780                      else if (cmdi > 2)
008714  000781                          if (cmd[2] == -1)
008715  000782                              if (cs)
008716  000783                                  serout(NAK) ;
008717  000784                                  cs := 0 ;
008718  000785                              else
008719  000786                                  cmd[cmdi-1] := 0 ;                     // terminate it
008720  000787                                  PrintStrings(cmd[1], &cmd[3], 1) ;
008721  000788                                  serout(ACK) ;
008722  000789                              endif
008723  000790                              cmdi := 0 ;
008724  000791                          else
008725  000792                              cmd[2]-- ;          // dec length
008726  000793                          endif
008727  000794                      endif
008728  000795                  else if (   (cmd[0] == READ_OBJ)
008729  000796                           && (cmdi == 4)         )
008730  000797                      if (cs)
008731  000798                          serout(NAK) ;
008732  000799                          cs := 0 ;
008733  000800                      else
008734  000801                          ReadObject(cmd[1], cmd[2]) ;
008735  000802                      endif
008736  000803                      cmdi := 0 ;
008737  000804                  else if (   (cmd[0] == WRITE_OBJ)    // 6 byte write command (gen option)
008738  000805                           && (cmdi == 6)          )
008739  000806                      if (cs)
008740  000807                          serout(NAK) ;
008741  000808                          cs := 0 ;
008742  000809                      else
008743  000810                          WriteObject(cmd[1], cmd[2], cmd[3] << 8 + cmd[4]) ;
008744  000811                          serout(ACK) ;
008745  000812                      endif
008746  000813                      cmdi := 0 ;
008747  000814                  else if (   (cmd[0] == WRITE_CONTRAST)
008748  000815                           && (cmdi == 3)         )
008749  000816                      if (cs)
008750  000817                          serout(NAK) ;
008751  000818                          cs := 0 ;
008752  000819                      else
008753  000820                          gfx_Contrast(cmd[1]) ;
008754  000821                          serout(ACK) ;
008755  000822                      endif
008756  000823                      cmdi := 0 ;
008757  000824                  else if (cmdi == 6)    // we have 6 bytes and we've gotten here -> something wrong
008758  000825                      serout(NAK) ;
008759  000826                      cs := 0 ;
008760  000827                      cmdi := 0 ;
008761  000828                  endif
008762  000829              endif   // not unicode string
008763  000830          endif   // a character is available
008764  000831        
008765  000832        
008766  000833      // touch code processing
008767  000834        
008768  000835          state := touch_Get(TOUCH_STATUS);               // get touchscreen status
008769  000836          n := img_Touched(hndl,-1) ;
008770  000837          if ((state == TOUCH_PRESSED) || (state == TOUCH_RELEASED) || (state == TOUCH_MOVING))
008771  000838              if ((state != TOUCH_RELEASED) && (n != oldn) && (oldn != -1)) 
008772  000839                  state := TOUCH_RELEASED ;       // simulate release if we move off object
008773  000840              endif
008774  000841              if (state != TOUCH_RELEASED)        // if not released
008775  000842                  if (oldn != -1) 
008776  000843                      n := oldn ;
008777  000844                  else 
008778  000845                      oldn := n ;
008779  000846                      state := TOUCH_PRESSED ;
008780  000847                  endif
008781  000848                  x  := touch_Get(TOUCH_GETX);
008782  000849                  y  := touch_Get(TOUCH_GETY);
008783  000850                  TState := IPD_DOWN ;
008784  000851              else
008785  000852                  n := oldn ;                     // simulate release of what we touched
008786  000853                  oldn := -1 ;                    // prevent double release
008787  000854                  TState := IPD_RELEASE ;
008788  000855              endif
008789  000856              if (n != -1)
008790  000857                          input := IPControls[n] + IPData;
008791  000858                          inputtype := *(input) ;
008792  000859                          i := inputtype ;
008793  000860                          if (inputtype >= t4Dbutton) i -= 23 ; // adjust to ensure next in gosub
008794  000861                          gosub (i), (cDipswitch, cKnob, cRockerswitch, cRotaryswitch, cSlider, cTrackbar, cWinbutton, c4DButton, cAniButton, cColorPicker, cUserButton) ;
008795  000862              endif
008796  000863          endif
008797  000864   //       if ((n != -1) && (oldn == -1)) oldn := n ;    // save what we touched in case we move off it
008798  000865        
008799  000866          sys_EventsResume() ;
008800  000867      forever
008801  000868        
008802  000869  cDipswitch:
008803  000870        
008804  000871  cKnob:
008805  000872        
008806  000873  cRockerswitch:
008807  000874        
008808  000875  cRotaryswitch:
008809  000876        
008810  000877  cSlider:
008811  000878  cTrackbar:
008812  000879        
008813  000880  c4DButton:
008814  000881  cUserButton:
008815  000882      object := oUserButtons + *(input+IPD_OBJVidx) ;
008816  000883      goto gbutton ;
008817  000884  cWinbutton:
008818  000885      object := oWinButtons + *(input+IPD_OBJVidx) ;
008819  000886  gbutton:
008820  000887      i := img_GetWord(hndl, *(object), IMAGE_INDEX) ; // current state
008821  000888      if (*(input+IPD_P1))                                 // momentary, reports 0, but should report 1
008822  000889          if (state == TOUCH_RELEASED)
008823  000890              i &= 0xfffe ;
008824  000891              TState == IPD_DOWN ;
008825  000892          else
008826  000893              i |= 1 ;
008827  000894              TState == IPD_RELEASE ;
008828  000895          endif
008829  000896      else if (*(input+IPD_P2) == -1)                      // Toggle, reports 0+2, but should report 0+1
008830  000897          if (state == TOUCH_RELEASED)                     // only truly change on release
008831  000898              if ((i & 3) == 3)
008832  000899                  i &= 0xfffc ;
008833  000900              else
008834  000901                  i++ ;
008835  000902              endif
008836  000903          else
008837  000904              i |= 1 ;                                      // make down regardless of current state
008838  000905          endif
008839  000906      else                        // group action, up all other buttons on touch press, reports 0 for button down
008840  000907          if (state == TOUCH_PRESSED)                     // only truly change on release
008841  000908              TurnOffButtons(*(input+IPD_P2)) ;
008842  000909          endif
008843  000910          i := (i & 0xfffc) | 2 ;
008844  000911      endif
008845  000912        
008846  000913      UpdateObjects(i) ;
008847  000914  endsub ;
008848  000915        
008849  000916  cAniButton:
008850  000917        
008851  000918  cColorPicker:
008852  000919        
008853  000920  endfunc
008854  000921  // End P5.inc
Notice: local var 'p' in func 'ActivateForm' is never used (line 514 file:RepRap_Touchv1.4DGenieS)


Symbol Table:
name                 decimal    hex
_1F                                  -40  0xffffffd8 (PmmC func) args[0] r=0  (not used)
__MAXMEM                           14400  0x00003840 (const dword)  (usage 1)
__MAXPROG                          14400  0x00003840 (const dword)  (usage 1)
__PLATFORM                             1  0x00000001 (const dword)  (not used)
ABS                                  -13  0xfffffff3 (PmmC func) args[1] r=1  (not used)
ACK                                    6  0x00000006 (const dword)  (usage 12)
ActivateForm                        7791  0x00001e6f (User func) args[1] r=0  (usage 9)
ALICEBLUE                          63455  0x0000f7df (const dword)  (not used)
ALL                                65535  0x0000ffff (const dword)  (not used)
ANITIMERS                              0  0x00000000 (const dword)  (not used)
ANTIQUEWHITE                       65370  0x0000ff5a (const dword)  (not used)
APPEND                                 0  0x00000000 (const dword)  (not used)
AQUA                                2047  0x000007ff (const dword)  (not used)
AQUAMARINE                         32762  0x00007ffa (const dword)  (not used)
AUDIO_ENABLE                           7  0x00000007 (const dword)  (not used)
AZURE                              63487  0x0000f7ff (const dword)  (not used)
BACKGROUND_COLOUR                     17  0x00000011 (const dword)  (usage 3)
BACKLITE                               6  0x00000006 (const dword)  (not used)
BAUD_110                               0  0x00000000 (const dword)  (not used)
BAUD_115200                           13  0x0000000d (const dword)  (not used)
BAUD_1200                              3  0x00000003 (const dword)  (not used)
BAUD_128000                           14  0x0000000e (const dword)  (not used)
BAUD_14400                             7  0x00000007 (const dword)  (not used)
BAUD_19200                             8  0x00000008 (const dword)  (not used)
BAUD_2400                              4  0x00000004 (const dword)  (not used)
BAUD_256000                           15  0x0000000f (const dword)  (not used)
BAUD_300                               1  0x00000001 (const dword)  (not used)
BAUD_300000                           16  0x00000010 (const dword)  (not used)
BAUD_31250                             9  0x00000009 (const dword)  (not used)
BAUD_375000                           17  0x00000011 (const dword)  (not used)
BAUD_38400                            10  0x0000000a (const dword)  (not used)
BAUD_4800                              5  0x00000005 (const dword)  (not used)
BAUD_500000                           18  0x00000012 (const dword)  (not used)
BAUD_56000                            11  0x0000000b (const dword)  (not used)
BAUD_57600                            12  0x0000000c (const dword)  (not used)
BAUD_600                               2  0x00000002 (const dword)  (not used)
BAUD_600000                           19  0x00000013 (const dword)  (not used)
BAUD_9600                              6  0x00000006 (const dword)  (not used)
BEIGE                              63419  0x0000f7bb (const dword)  (not used)
BEVEL_SHADOW                          29  0x0000001d (const dword)  (not used)
BEVEL_WIDTH                           28  0x0000001c (const dword)  (not used)
BGIMAGE                               32  0x00000020 (const dword)  (usage 6)
BIN                                    2  0x00000002 (const dword)  (not used)
BIN1                                 258  0x00000102 (const dword)  (not used)
BIN10                               2562  0x00000a02 (const dword)  (not used)
BIN10Z                              6658  0x00001a02 (const dword)  (not used)
BIN10ZB                            10754  0x00002a02 (const dword)  (not used)
BIN11                               2818  0x00000b02 (const dword)  (not used)
BIN11Z                              6914  0x00001b02 (const dword)  (not used)
BIN11ZB                            11010  0x00002b02 (const dword)  (not used)
BIN12                               3074  0x00000c02 (const dword)  (not used)
BIN12Z                              7170  0x00001c02 (const dword)  (not used)
BIN12ZB                            11266  0x00002c02 (const dword)  (not used)
BIN13                               3330  0x00000d02 (const dword)  (not used)
BIN13Z                              7426  0x00001d02 (const dword)  (not used)
BIN13ZB                            11522  0x00002d02 (const dword)  (not used)
BIN14                               3586  0x00000e02 (const dword)  (not used)
BIN14Z                              7682  0x00001e02 (const dword)  (not used)
BIN14ZB                            11778  0x00002e02 (const dword)  (not used)
BIN15                               3842  0x00000f02 (const dword)  (not used)
BIN15Z                              7938  0x00001f02 (const dword)  (not used)
BIN15ZB                            12034  0x00002f02 (const dword)  (not used)
BIN16                                  2  0x00000002 (const dword)  (not used)
BIN16Z                              4098  0x00001002 (const dword)  (not used)
BIN16ZB                             8194  0x00002002 (const dword)  (not used)
BIN1Z                               4354  0x00001102 (const dword)  (not used)
BIN1ZB                              8450  0x00002102 (const dword)  (not used)
BIN2                                 514  0x00000202 (const dword)  (not used)
BIN2Z                               4610  0x00001202 (const dword)  (not used)
BIN2ZB                              8706  0x00002202 (const dword)  (not used)
BIN3                                 770  0x00000302 (const dword)  (not used)
BIN3Z                               4866  0x00001302 (const dword)  (not used)
BIN3ZB                              8962  0x00002302 (const dword)  (not used)
BIN4                                1026  0x00000402 (const dword)  (not used)
BIN4Z                               5122  0x00001402 (const dword)  (not used)
BIN4ZB                              9218  0x00002402 (const dword)  (not used)
BIN5                                1282  0x00000502 (const dword)  (not used)
BIN5Z                               5378  0x00001502 (const dword)  (not used)
BIN5ZB                              9474  0x00002502 (const dword)  (not used)
BIN6                                1538  0x00000602 (const dword)  (not used)
BIN6Z                               5634  0x00001602 (const dword)  (not used)
BIN6ZB                              9730  0x00002602 (const dword)  (not used)
BIN7                                1794  0x00000702 (const dword)  (not used)
BIN7Z                               5890  0x00001702 (const dword)  (not used)
BIN7ZB                              9986  0x00002702 (const dword)  (not used)
BIN8                                2050  0x00000802 (const dword)  (not used)
BIN8Z                               6146  0x00001802 (const dword)  (not used)
BIN8ZB                             10242  0x00002802 (const dword)  (not used)
BIN9                                2306  0x00000902 (const dword)  (not used)
BIN9Z                               6402  0x00001902 (const dword)  (not used)
BIN9ZB                             10498  0x00002902 (const dword)  (not used)
BINZ                                4098  0x00001002 (const dword)  (not used)
BINZB                               8194  0x00002002 (const dword)  (not used)
BISQUE                             65336  0x0000ff38 (const dword)  (not used)
BLACK                                  0  0x00000000 (const dword)  (usage 78)
BLANCHEDALMOND                     65369  0x0000ff59 (const dword)  (usage 6)
BLUE                                  31  0x0000001f (const dword)  (not used)
BLUEVIOLET                         35164  0x0000895c (const dword)  (not used)
BOLD                                  16  0x00000010 (const dword)  (not used)
BOTTOM_POS                             5  0x00000005 (const dword)  (not used)
BROWN                              41285  0x0000a145 (const dword)  (not used)
BURLYWOOD                          56784  0x0000ddd0 (const dword)  (not used)
BUS_0                                  8  0x00000008 (const dword)  (not used)
BUS_1                                  9  0x00000009 (const dword)  (not used)
BUS_2                                 10  0x0000000a (const dword)  (not used)
BUS_3                                 11  0x0000000b (const dword)  (not used)
BUS_4                                 12  0x0000000c (const dword)  (not used)
BUS_5                                 13  0x0000000d (const dword)  (not used)
BUS_6                                 14  0x0000000e (const dword)  (not used)
BUS_7                                 15  0x0000000f (const dword)  (not used)
bus_In                               -45  0xffffffd3 (PmmC func) args[0] r=1  (not used)
bus_Out                              -46  0xffffffd2 (PmmC func) args[1] r=0  (not used)
BUS_RD_PIN                             4  0x00000004 (const dword)  (not used)
bus_Read                             -49  0xffffffcf (PmmC func) args[0] r=1  (not used)
bus_Set                              -47  0xffffffd1 (PmmC func) args[1] r=0  (not used)
BUS_WR_PIN                             5  0x00000005 (const dword)  (not used)
bus_Write                            -48  0xffffffd0 (PmmC func) args[1] r=0  (not used)
BUTTON_DOWN                            0  0x00000000 (const dword)  (not used)
BUTTON_UP                              1  0x00000001 (const dword)  (not used)
ByteSwap                            -215  0xffffff29 (PmmC func) args[1] r=1  (not used)
c4DButton                         UNRESOLVED  (not used)
C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS    2710  0x00000a96 (const ??? 0)  (not used)
CADETBLUE                          23796  0x00005cf4 (const dword)  (not used)
cAniButton                        UNRESOLVED  (not used)
cColorPicker                      UNRESOLVED  (not used)
cDipswitch                        UNRESOLVED  (not used)
charheight                          -159  0xffffff61 (PmmC func) args[1] r=1  (not used)
CHARTREUSE                         32736  0x00007fe0 (const dword)  (not used)
charwidth                           -158  0xffffff62 (PmmC func) args[1] r=1  (not used)
CHOCOLATE                          54083  0x0000d343 (const dword)  (not used)
CHR                                  129  0x00000081 (const dword)  (not used)
CKMODE_0                               0  0x00000000 (const dword)  (not used)
CKMODE_1                               1  0x00000001 (const dword)  (not used)
CKMODE_2                               2  0x00000002 (const dword)  (not used)
CKMODE_3                               3  0x00000003 (const dword)  (not used)
cKnob                             UNRESOLVED  (not used)
CLIPPING                              19  0x00000013 (const dword)  (not used)
cmd                                  280  0x00000118 (mem) word[80] (global)  (usage 78)
CMDLenMAX                             80  0x00000050 (const dword)  (usage 12)
COLOUR16                               0  0x00000000 (const dword)  (not used)
COLOUR8                                1  0x00000001 (const dword)  (not used)
COLOUR_MODE                           27  0x0000001b (const dword)  (not used)
COLUMN_ADDRESS_END1                    5  0x00000005 (const dword)  (not used)
COLUMN_ADDRESS_END2                    4  0x00000004 (const dword)  (not used)
COLUMN_ADDRESS_START1                  3  0x00000003 (const dword)  (not used)
COLUMN_ADDRESS_START2                  2  0x00000002 (const dword)  (not used)
COM0                               63492  0x0000f804 (const dword)  (usage 3)
COM1                               63496  0x0000f808 (const dword)  (not used)
com1_Count                          -132  0xffffff7c (PmmC func) args[0] r=1  (not used)
com1_Error                          -134  0xffffff7a (PmmC func) args[0] r=1  (not used)
com1_Full                           -133  0xffffff7b (PmmC func) args[0] r=1  (not used)
com1_Init                           -130  0xffffff7e (PmmC func) args[3] r=0  (not used)
com1_Reset                          -131  0xffffff7d (PmmC func) args[0] r=0  (not used)
com1_Sync                           -135  0xffffff79 (PmmC func) args[0] r=1  (not used)
com1_TXbuffer                       -136  0xffffff78 (PmmC func) args[3] r=0  (not used)
com1_TXbufferHold                   -139  0xffffff75 (PmmC func) args[1] r=1  (not used)
com1_TXcount                        -137  0xffffff77 (PmmC func) args[0] r=1  (not used)
com1_TXemptyEvent                   -138  0xffffff76 (PmmC func) args[1] r=1  (not used)
com_Count                           -122  0xffffff86 (PmmC func) args[0] r=1  (usage 3)
com_Error                           -124  0xffffff84 (PmmC func) args[0] r=1  (not used)
com_Full                            -123  0xffffff85 (PmmC func) args[0] r=1  (not used)
com_Init                            -120  0xffffff88 (PmmC func) args[3] r=0  (usage 3)
com_Reset                           -121  0xffffff87 (PmmC func) args[0] r=0  (not used)
com_SetBaud                         -142  0xffffff72 (PmmC func) args[2] r=1  (usage 3)
com_Sync                            -125  0xffffff83 (PmmC func) args[0] r=1  (not used)
com_TXbuffer                        -126  0xffffff82 (PmmC func) args[3] r=0  (usage 3)
com_TXbufferHold                    -129  0xffffff7f (PmmC func) args[1] r=1  (not used)
com_TXcount                         -127  0xffffff81 (PmmC func) args[0] r=1  (not used)
com_TXemptyEvent                    -128  0xffffff80 (PmmC func) args[1] r=1  (not used)
comRX                                200  0x000000c8 (mem) word[40] (global)  (usage 3)
CONTRAST                              25  0x00000019 (const dword)  (not used)
CORAL                              64490  0x0000fbea (const dword)  (not used)
CORNFLOWERBLUE                     25789  0x000064bd (const dword)  (not used)
CORNSILK                           65499  0x0000ffdb (const dword)  (not used)
COS                                  -18  0xffffffee (PmmC func) args[1] r=1  (not used)
CRIMSON                            55463  0x0000d8a7 (const dword)  (not used)
cRockerswitch                     UNRESOLVED  (not used)
cRotaryswitch                     UNRESOLVED  (not used)
cs                                   440  0x000001b8 (mem) word (global)  (usage 42)
cSlider                           UNRESOLVED  (not used)
cTrackbar                         UNRESOLVED  (not used)
curform                              186  0x000000ba (mem) word (global)  (usage 45)
cUserButton                       UNRESOLVED  (not used)
cWinbutton                        UNRESOLVED  (not used)
CY                                  -285  0xfffffee3 (PmmC func) args[0] r=1  (not used)
CYAN                                2047  0x000007ff (const dword)  (not used)
CYCLE_CONTROL_1                       58  0x0000003a (const dword)  (not used)
CYCLE_CONTROL_2                       59  0x0000003b (const dword)  (not used)
CYCLE_CONTROL_3                       60  0x0000003c (const dword)  (not used)
CYCLE_CONTROL_4                       61  0x0000003d (const dword)  (not used)
CYCLE_CONTROL_5                       62  0x0000003e (const dword)  (not used)
CYCLE_CONTROL_6                       64  0x00000040 (const dword)  (not used)
DARKBLUE                              17  0x00000011 (const dword)  (not used)
DARKCYAN                            1105  0x00000451 (const dword)  (not used)
DARKGOLDENROD                      48161  0x0000bc21 (const dword)  (usage 6)
DARKGRAY                           44373  0x0000ad55 (const dword)  (not used)
DARKGREEN                            800  0x00000320 (const dword)  (not used)
DARKKHAKI                          48557  0x0000bdad (const dword)  (not used)
DARKMAGENTA                        34833  0x00008811 (const dword)  (not used)
DARKOLIVEGREEN                     21317  0x00005345 (const dword)  (not used)
DARKORANGE                         64608  0x0000fc60 (const dword)  (not used)
DARKORCHID                         39321  0x00009999 (const dword)  (not used)
DARKRED                            34816  0x00008800 (const dword)  (not used)
DARKSALMON                         60591  0x0000ecaf (const dword)  (not used)
DARKSEAGREEN                       36337  0x00008df1 (const dword)  (not used)
DARKSLATEBLUE                      18929  0x000049f1 (const dword)  (not used)
DARKSLATEGRAY                      10857  0x00002a69 (const dword)  (not used)
DARKTURQUOISE                       1658  0x0000067a (const dword)  (not used)
DARKVIOLET                         36890  0x0000901a (const dword)  (not used)
DEC                                 1290  0x0000050a (const dword)  (not used)
DEC1                                 266  0x0000010a (const dword)  (not used)
DEC1Z                               4362  0x0000110a (const dword)  (not used)
DEC1ZB                              8458  0x0000210a (const dword)  (not used)
DEC2                                 522  0x0000020a (const dword)  (not used)
DEC2Z                               4618  0x0000120a (const dword)  (not used)
DEC2ZB                              8714  0x0000220a (const dword)  (not used)
DEC3                                 778  0x0000030a (const dword)  (not used)
DEC3Z                               4874  0x0000130a (const dword)  (not used)
DEC3ZB                              8970  0x0000230a (const dword)  (not used)
DEC4                                1034  0x0000040a (const dword)  (not used)
DEC4Z                               5130  0x0000140a (const dword)  (not used)
DEC4ZB                              9226  0x0000240a (const dword)  (not used)
DEC5                                1290  0x0000050a (const dword)  (not used)
DEC5Z                               5386  0x0000150a (const dword)  (not used)
DEC5ZB                              9482  0x0000250a (const dword)  (not used)
DECZ                                5386  0x0000150a (const dword)  (not used)
DECZB                               9482  0x0000250a (const dword)  (not used)
DEEPPINK                           63666  0x0000f8b2 (const dword)  (not used)
DEEPSKYBLUE                         1535  0x000005ff (const dword)  (not used)
DIMGRAY                            27469  0x00006b4d (const dword)  (not used)
DISABLE                                0  0x00000000 (const dword)  (not used)
disk                                   0  0x00000000 (mem) word (global)  (usage 6)
DISK_BUF                              15  0x0000000f (const dword)  (not used)
DISK_DATA_HI                           7  0x00000007 (const dword)  (not used)
DISK_DATA_LO                           6  0x00000006 (const dword)  (not used)
DISK_FAT_HI                            3  0x00000003 (const dword)  (not used)
DISK_FAT_LO                            2  0x00000002 (const dword)  (not used)
DISK_FATCOPIES                        12  0x0000000c (const dword)  (not used)
DISK_FATSIZE                          11  0x0000000b (const dword)  (not used)
DISK_FIRST_SECT_HI                     1  0x00000001 (const dword)  (not used)
DISK_FIRST_SECT_LO                     0  0x00000000 (const dword)  (not used)
DISK_MAXCLUS_HI                        9  0x00000009 (const dword)  (not used)
DISK_MAXCLUS_LO                        8  0x00000008 (const dword)  (not used)
DISK_MAXROOT                          10  0x0000000a (const dword)  (not used)
DISK_ROOT_HI                           5  0x00000005 (const dword)  (not used)
DISK_ROOT_LO                           4  0x00000004 (const dword)  (not used)
DISK_SECT_PER_CLUS                    13  0x0000000d (const dword)  (not used)
DISK_TYPE                             14  0x0000000e (const dword)  (not used)
disp_Disconnect                     -293  0xfffffedb (PmmC func) args[0] r=0  (not used)
disp_Init                           -143  0xffffff71 (PmmC func) args[0] r=0  (not used)
disp_ReadWord                       -149  0xffffff6b (PmmC func) args[0] r=1  (not used)
disp_setGRAM                        -145  0xffffff6f (PmmC func) args[4] r=0  (not used)
disp_SetReg                         -144  0xffffff70 (PmmC func) args[2] r=0  (not used)
disp_Sync                           -284  0xfffffee4 (PmmC func) args[1] r=0  (not used)
disp_WrGRAM                         -146  0xffffff6e (PmmC func) args[1] r=0  (not used)
disp_WriteControl                   -147  0xffffff6d (PmmC func) args[1] r=0  (not used)
disp_WriteWord                      -148  0xffffff6c (PmmC func) args[1] r=0  (not used)
DISPLAY_CONTROL_1                     38  0x00000026 (const dword)  (not used)
DISPLAY_CONTROL_10                    54  0x00000036 (const dword)  (not used)
DISPLAY_CONTROL_14                    65  0x00000041 (const dword)  (not used)
DISPLAY_CONTROL_2                     39  0x00000027 (const dword)  (not used)
DISPLAY_CONTROL_3                     40  0x00000028 (const dword)  (not used)
DISPLAY_CONTROL_4                     41  0x00000029 (const dword)  (not used)
DISPLAY_CONTROL_5                     42  0x0000002a (const dword)  (not used)
DISPLAY_CONTROL_6                     44  0x0000002c (const dword)  (not used)
DISPLAY_CONTROL_7                     45  0x0000002d (const dword)  (not used)
DISPLAY_CONTROL_8                    144  0x00000090 (const dword)  (not used)
DISPLAY_CONTROL_9                     53  0x00000035 (const dword)  (not used)
DISPLAY_MODE_CONTROL                   1  0x00000001 (const dword)  (not used)
DODGERBLUE                          7327  0x00001c9f (const dword)  (not used)
DoGFXObjects                        7101  0x00001bbd (User func) args[0] r=0  (usage 6)
DOWN                                   0  0x00000000 (const dword)  (not used)
DSK                                63490  0x0000f802 (const dword)  (not used)
ENABLE                                 1  0x00000001 (const dword)  (not used)
EVE_SP                              -282  0xfffffee6 (PmmC func) args[0] r=1  (not used)
EVE_SSIZE                           -283  0xfffffee5 (PmmC func) args[0] r=1  (not used)
FE_CANNOT_INIT                        15  0x0000000f (const dword)  (not used)
FE_CANNOT_READ_MBR                    16  0x00000010 (const dword)  (not used)
FE_DIR_FULL                           12  0x0000000c (const dword)  (not used)
FE_DISK_FULL                          13  0x0000000d (const dword)  (not used)
FE_DISK_NOT_MNTD                       6  0x00000006 (const dword)  (not used)
FE_EOF                                10  0x0000000a (const dword)  (not used)
FE_FAT_EOF                             9  0x00000009 (const dword)  (not used)
FE_FILE_NOT_FOUND                      7  0x00000007 (const dword)  (not used)
FE_FILE_OVERWRITE                     14  0x0000000e (const dword)  (not used)
FE_FILE_TIMEOUT                       26  0x0000001a (const dword)  (not used)
FE_FIND_ERROR                         19  0x00000013 (const dword)  (not used)
FE_IDE_ERROR                           1  0x00000001 (const dword)  (not used)
FE_INVALID_BR                          5  0x00000005 (const dword)  (not used)
FE_INVALID_CLUSTER                    11  0x0000000b (const dword)  (not used)
FE_INVALID_FILE                        8  0x00000008 (const dword)  (not used)
FE_INVALID_FNAME                      20  0x00000014 (const dword)  (not used)
FE_INVALID_MBR                         4  0x00000004 (const dword)  (not used)
FE_INVALID_MEDIA                      21  0x00000015 (const dword)  (not used)
FE_INVALID_MODE                       18  0x00000012 (const dword)  (not used)
FE_MALLOC_FAILED                      17  0x00000011 (const dword)  (not used)
FE_NOT_PRESENT                         2  0x00000002 (const dword)  (not used)
FE_OK                                  0  0x00000000 (const dword)  (not used)
FE_PARTITION_TYPE                      3  0x00000003 (const dword)  (not used)
FE_SECTOR_READ_FAIL                   22  0x00000016 (const dword)  (not used)
FE_SECTOR_WRITE_FAIL                  23  0x00000017 (const dword)  (not used)
FILE_ATTRIBUTES                       18  0x00000012 (const dword)  (not used)
FILE_BUFFER                           22  0x00000016 (const dword)  (not used)
file_Close                          -232  0xffffff18 (PmmC func) args[1] r=1  (not used)
file_Count                          -226  0xffffff1e (PmmC func) args[1] r=1  (not used)
FILE_CURR_CLUSTER                      1  0x00000001 (const dword)  (not used)
FILE_CURR_SECTOR                       2  0x00000002 (const dword)  (not used)
FILE_CURR_SECTOR_POS                   3  0x00000003 (const dword)  (not used)
FILE_CURR_SECTOR_TOP                   4  0x00000004 (const dword)  (not used)
FILE_DATE                             10  0x0000000a (const dword)  (not used)
file_Dir                            -227  0xffffff1d (PmmC func) args[1] r=1  (not used)
FILE_DISK                             21  0x00000015 (const dword)  (not used)
FILE_ENTRY                            20  0x00000014 (const dword)  (not used)
file_Erase                          -247  0xffffff09 (PmmC func) args[1] r=1  (not used)
file_Error                          -225  0xffffff1f (PmmC func) args[0] r=1  (not used)
file_Exec                           -251  0xffffff05 (PmmC func) args[2] r=1  (not used)
file_Exists                         -230  0xffffff1a (PmmC func) args[1] r=1  (not used)
file_FindFirst                      -228  0xffffff1c (PmmC func) args[1] r=1  (not used)
file_FindNext                       -229  0xffffff1b (PmmC func) args[0] r=1  (not used)
FILE_FIRST_CLUSTER                     0  0x00000000 (const dword)  (not used)
file_GetC                           -242  0xffffff0e (PmmC func) args[1] r=1  (usage 3)
file_GetS                           -246  0xffffff0a (PmmC func) args[3] r=1  (not used)
file_GetW                           -244  0xffffff0c (PmmC func) args[1] r=1  (usage 3)
file_Image                          -239  0xffffff11 (PmmC func) args[3] r=1  (not used)
file_Index                          -235  0xffffff15 (PmmC func) args[4] r=1  (not used)
file_LoadFunction                   -249  0xffffff07 (PmmC func) args[1] r=1  (not used)
file_LoadImageControl               -252  0xffffff04 (PmmC func) args[3] r=1  (usage 6)
FILE_MODE                             17  0x00000011 (const dword)  (not used)
file_Mount                          -253  0xffffff03 (PmmC func) args[0] r=1  (usage 6)
FILE_NAME                             11  0x0000000b (const dword)  (not used)
file_Open                           -231  0xffffff19 (PmmC func) args[2] r=1  (usage 3)
FILE_PAGEFLAG                         19  0x00000013 (const dword)  (not used)
file_PlayWAV                        -255  0xffffff01 (PmmC func) args[1] r=1  (not used)
file_PutC                           -241  0xffffff0f (PmmC func) args[2] r=1  (not used)
file_PutS                           -245  0xffffff0b (PmmC func) args[2] r=1  (not used)
file_PutW                           -243  0xffffff0d (PmmC func) args[2] r=1  (not used)
file_Read                           -233  0xffffff17 (PmmC func) args[3] r=1  (not used)
file_Rewind                         -248  0xffffff08 (PmmC func) args[1] r=1  (not used)
file_Run                            -250  0xffffff06 (PmmC func) args[2] r=1  (not used)
file_ScreenCapture                  -240  0xffffff10 (PmmC func) args[5] r=1  (not used)
file_Seek                           -234  0xffffff16 (PmmC func) args[3] r=1  (usage 3)
FILE_SEEK_POS_HI                       6  0x00000006 (const dword)  (not used)
FILE_SEEK_POS_LO                       5  0x00000005 (const dword)  (not used)
file_Size                           -238  0xffffff12 (PmmC func) args[3] r=1  (not used)
FILE_SIZE_HI                           8  0x00000008 (const dword)  (not used)
FILE_SIZE_LO                           7  0x00000007 (const dword)  (not used)
file_Tell                           -236  0xffffff14 (PmmC func) args[3] r=1  (not used)
FILE_TIME                              9  0x00000009 (const dword)  (not used)
file_Unmount                        -254  0xffffff02 (PmmC func) args[0] r=0  (not used)
file_Write                          -237  0xffffff13 (PmmC func) args[3] r=1  (not used)
FIREBRICK                          45316  0x0000b104 (const dword)  (not used)
flash_BlockErase                    -157  0xffffff63 (PmmC func) args[1] r=1  (not used)
flash_BulkErase                     -156  0xffffff64 (PmmC func) args[0] r=0  (not used)
flash_ID                            -155  0xffffff65 (PmmC func) args[0] r=1  (not used)
flash_SIG                           -154  0xffffff66 (PmmC func) args[0] r=1  (not used)
FLORALWHITE                        65502  0x0000ffde (const dword)  (not used)
FONT1                                  0  0x00000000 (const dword)  (not used)
FONT2                                  1  0x00000001 (const dword)  (not used)
FONT3                                  2  0x00000002 (const dword)  (usage 75)
FONT_ID                                2  0x00000002 (const dword)  (not used)
FONT_SIZE                              2  0x00000002 (const dword)  (not used)
FORESTGREEN                         9284  0x00002444 (const dword)  (not used)
formBGcol                           4817  0x000012d1formBGcol                           4817  0x000012d1 (mem) word[23] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 8)
formBGcol                         UNRESOLVED  (usage 4)
formenidx                             53  0x00000035formenidx                             53  0x00000035 (mem) word[23] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 6)
formstidx                              7  0x00000007formstidx                              7  0x00000007 (mem) word[23] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 7)
formstidx                         UNRESOLVED  (usage 2)
FRAME_DELAY                           22  0x00000016 (const dword)  (not used)
FUCHSIA                            63519  0x0000f81f (const dword)  (not used)
GAINSBORO                          57083  0x0000defb (const dword)  (not used)
GAMMA_CONTROL_1                       70  0x00000046 (const dword)  (not used)
GAMMA_CONTROL_10                      79  0x0000004f (const dword)  (not used)
GAMMA_CONTROL_11                      80  0x00000050 (const dword)  (not used)
GAMMA_CONTROL_12                      81  0x00000051 (const dword)  (not used)
GAMMA_CONTROL_2                       71  0x00000047 (const dword)  (not used)
GAMMA_CONTROL_3                       72  0x00000048 (const dword)  (not used)
GAMMA_CONTROL_4                       73  0x00000049 (const dword)  (not used)
GAMMA_CONTROL_5                       74  0x0000004a (const dword)  (not used)
GAMMA_CONTROL_6                       75  0x0000004b (const dword)  (not used)
GAMMA_CONTROL_7                       76  0x0000004c (const dword)  (not used)
GAMMA_CONTROL_8                       77  0x0000004d (const dword)  (not used)
GAMMA_CONTROL_9                       78  0x0000004e (const dword)  (not used)
gbutton                           UNRESOLVED  (not used)
GFX                                63489  0x0000f801 (const dword)  (not used)
gfx_332to565                         -85  0xffffffab (PmmC func) args[1] r=1  (not used)
gfx_BevelShadow                     -104  0xffffff98 (PmmC func) args[1] r=1  (not used)
gfx_BevelWidth                      -103  0xffffff99 (PmmC func) args[1] r=1  (not used)
gfx_BGcolour                         -92  0xffffffa4 (PmmC func) args[1] r=1  (not used)
GFX_BOTTOM                            51  0x00000033 (const dword)  (not used)
gfx_BoxTo                            -74  0xffffffb6 (PmmC func) args[2] r=0  (not used)
gfx_Bullet                           -71  0xffffffb9 (PmmC func) args[1] r=0  (not used)
gfx_Button                           -80  0xffffffb0 (PmmC func) args[9] r=0  (not used)
GFX_BUTTON_BACKGROUND                 64  0x00000040 (const dword)  (not used)
GFX_BUTTON_FOREGROUND                 63  0x0000003f (const dword)  (not used)
GFX_BUTTON_MODE                       65  0x00000041 (const dword)  (not used)
gfx_ChangeColour                     -76  0xffffffb4 (PmmC func) args[2] r=0  (not used)
gfx_Circle                           -61  0xffffffc3 (PmmC func) args[4] r=0  (not used)
gfx_CircleFilled                     -62  0xffffffc2 (PmmC func) args[4] r=0  (not used)
GFX_CLIP_BOTTOM                      114  0x00000072 (const dword)  (not used)
GFX_CLIP_BOTTOM_VAL                  110  0x0000006e (const dword)  (not used)
GFX_CLIP_LEFT                        111  0x0000006f (const dword)  (not used)
GFX_CLIP_LEFT_VAL                    107  0x0000006b (const dword)  (not used)
GFX_CLIP_RIGHT                       113  0x00000071 (const dword)  (not used)
GFX_CLIP_RIGHT_VAL                   109  0x0000006d (const dword)  (not used)
GFX_CLIP_TOP                         112  0x00000070 (const dword)  (not used)
GFX_CLIP_TOP_VAL                     108  0x0000006c (const dword)  (not used)
gfx_Clipping                         -94  0xffffffa2 (PmmC func) args[1] r=0  (usage 6)
gfx_ClipWindow                       -75  0xffffffb5 (PmmC func) args[4] r=0  (usage 3)
gfx_Cls                              -51  0xffffffcd (PmmC func) args[0] r=0  (usage 6)
gfx_ColourMode                      -102  0xffffff9a (PmmC func) args[1] r=1  (not used)
gfx_Contrast                        -100  0xffffff9c (PmmC func) args[1] r=1  (usage 3)
gfx_Dot                              -70  0xffffffba (PmmC func) args[0] r=0  (not used)
gfx_Ellipse                          -78  0xffffffb2 (PmmC func) args[5] r=0  (not used)
gfx_EllipseFilled                    -79  0xffffffb1 (PmmC func) args[5] r=0  (not used)
gfx_FrameDelay                       -97  0xffffff9f (PmmC func) args[1] r=1  (not used)
gfx_Get                              -90  0xffffffa6 (PmmC func) args[1] r=1  (not used)
gfx_GetPixel                         -64  0xffffffc0 (PmmC func) args[2] r=1  (not used)
GFX_HILIGHT_BACKGROUND                61  0x0000003d (const dword)  (not used)
GFX_HILIGHT_FOREGROUND                62  0x0000003e (const dword)  (not used)
GFX_HILITE_LINE                       58  0x0000003a (const dword)  (not used)
gfx_Hline                            -57  0xffffffc7 (PmmC func) args[4] r=1  (not used)
gfx_IncX                             -72  0xffffffb8 (PmmC func) args[0] r=1  (not used)
gfx_IncY                             -73  0xffffffb7 (PmmC func) args[0] r=1  (not used)
GFX_LAST_CHAR_HEIGHT                 120  0x00000078 (const dword)  (not used)
GFX_LAST_CHAR_WIDTH                  119  0x00000077 (const dword)  (not used)
GFX_LAST_SELECTION                    60  0x0000003c (const dword)  (not used)
GFX_LAST_STR_HEIGHT                  122  0x0000007a (const dword)  (not used)
GFX_LAST_STR_WIDTH                   121  0x00000079 (const dword)  (not used)
GFX_LEFT                              48  0x00000030 (const dword)  (not used)
GFX_LEFT_GUTTER_WIDTH                 68  0x00000044 (const dword)  (not used)
gfx_Line                             -56  0xffffffc8 (PmmC func) args[5] r=0  (not used)
GFX_LINE_COUNT                        59  0x0000003b (const dword)  (not used)
gfx_LinePattern                     -101  0xffffff9b (PmmC func) args[1] r=1  (not used)
gfx_LineRel                          -55  0xffffffc9 (PmmC func) args[2] r=0  (not used)
gfx_LineTo                           -54  0xffffffca (PmmC func) args[2] r=0  (not used)
gfx_MoveRel                          -53  0xffffffcb (PmmC func) args[2] r=0  (not used)
gfx_MoveTo                           -52  0xffffffcc (PmmC func) args[2] r=0  (usage 3)
gfx_ObjectColour                     -93  0xffffffa3 (PmmC func) args[1] r=1  (not used)
gfx_Orbit                            -67  0xffffffbd (PmmC func) args[2] r=0  (not used)
gfx_OrbitInit                        -66  0xffffffbe (PmmC func) args[2] r=0  (not used)
gfx_Origin                           -89  0xffffffa7 (PmmC func) args[2] r=0  (not used)
gfx_OutlineColour                    -99  0xffffff9d (PmmC func) args[1] r=1  (not used)
gfx_Panel                            -81  0xffffffaf (PmmC func) args[6] r=0  (usage 3)
gfx_PenSize                          -91  0xffffffa5 (PmmC func) args[1] r=1  (not used)
GFX_PIXEL_SHIFT                       70  0x00000046 (const dword)  (not used)
gfx_Polygon                          -69  0xffffffbb (PmmC func) args[4] r=0  (not used)
gfx_PolygonFilled                    -88  0xffffffa8 (PmmC func) args[4] r=0  (not used)
gfx_Polyline                         -68  0xffffffbc (PmmC func) args[4] r=0  (not used)
gfx_PutPixel                         -63  0xffffffc1 (PmmC func) args[3] r=0  (not used)
GFX_RECT_X1                           71  0x00000047 (const dword)  (not used)
GFX_RECT_X2                           73  0x00000049 (const dword)  (not used)
GFX_RECT_Y1                           72  0x00000048 (const dword)  (not used)
GFX_RECT_Y2                           74  0x0000004a (const dword)  (not used)
gfx_Rectangle                        -59  0xffffffc5 (PmmC func) args[5] r=0  (not used)
gfx_RectangleFilled                  -60  0xffffffc4 (PmmC func) args[5] r=0  (usage 6)
gfx_RGBto565                         -84  0xffffffac (PmmC func) args[3] r=1  (not used)
GFX_RIGHT                             50  0x00000032 (const dword)  (not used)
GFX_RIGHT_GUTTER_WIDTH                69  0x00000045 (const dword)  (not used)
gfx_ScreenCopyPaste                  -83  0xffffffad (PmmC func) args[6] r=0  (not used)
gfx_ScreenMode                       -98  0xffffff9e (PmmC func) args[1] r=1  (usage 3)
gfx_Selection                        -86  0xffffffaa (PmmC func) args[3] r=0  (not used)
gfx_Set                              -50  0xffffffce (PmmC func) args[2] r=0  (usage 3)
gfx_SetClipRegion                    -77  0xffffffb3 (PmmC func) args[0] r=0  (not used)
gfx_Slider                           -82  0xffffffae (PmmC func) args[8] r=1  (not used)
GFX_STATUSBAR_HEIGHT                  67  0x00000043 (const dword)  (not used)
GFX_THUMB_BORDER_DARK                 76  0x0000004c (const dword)  (not used)
GFX_THUMB_BORDER_LIGHT                77  0x0000004d (const dword)  (not used)
GFX_THUMB_PERCENT                     75  0x0000004b (const dword)  (not used)
GFX_TOOLBAR_HEIGHT                    66  0x00000042 (const dword)  (not used)
GFX_TOP                               49  0x00000031 (const dword)  (not used)
GFX_TOUCH_REGION_X1                  103  0x00000067 (const dword)  (not used)
GFX_TOUCH_REGION_X2                  105  0x00000069 (const dword)  (not used)
GFX_TOUCH_REGION_Y1                  104  0x00000068 (const dword)  (not used)
GFX_TOUCH_REGION_Y2                  106  0x0000006a (const dword)  (not used)
gfx_Transparency                     -96  0xffffffa0 (PmmC func) args[1] r=1  (not used)
gfx_TransparentColour                -95  0xffffffa1 (PmmC func) args[1] r=1  (not used)
gfx_Triangle                         -65  0xffffffbf (PmmC func) args[7] r=0  (not used)
gfx_TriangleFilled                   -87  0xffffffa9 (PmmC func) args[7] r=0  (not used)
gfx_Vline                            -58  0xffffffc6 (PmmC func) args[4] r=1  (not used)
GFX_X1                                52  0x00000034 (const dword)  (not used)
GFX_X2                                54  0x00000036 (const dword)  (not used)
GFX_X_ORG                             56  0x00000038 (const dword)  (not used)
GFX_XMAX                              46  0x0000002e (const dword)  (not used)
gfx_Xorigin                         -105  0xffffff97 (PmmC func) args[1] r=1  (not used)
GFX_Y1                                53  0x00000035 (const dword)  (not used)
GFX_Y2                                55  0x00000037 (const dword)  (not used)
GFX_Y_ORG                             57  0x00000039 (const dword)  (not used)
GFX_YMAX                              47  0x0000002f (const dword)  (not used)
gfx_Yorigin                         -106  0xffffff96 (PmmC func) args[1] r=1  (not used)
GHOSTWHITE                         65503  0x0000ffdf (const dword)  (not used)
GOLD                               65184  0x0000fea0 (const dword)  (not used)
GOLDENROD                          56612  0x0000dd24 (const dword)  (not used)
GRAM_PIXEL_COUNT_HI                  116  0x00000074 (const dword)  (not used)
GRAM_PIXEL_COUNT_LO                  115  0x00000073 (const dword)  (not used)
GRAY                               33808  0x00008410 (const dword)  (not used)
GREEN                               1024  0x00000400 (const dword)  (not used)
GREENYELLOW                        45029  0x0000afe5 (const dword)  (not used)
HEX                                 5136  0x00001410 (const dword)  (not used)
HEX1                                4368  0x00001110 (const dword)  (not used)
HEX1Z                                272  0x00000110 (const dword)  (not used)
HEX1ZB                              8464  0x00002110 (const dword)  (not used)
HEX2                                4624  0x00001210 (const dword)  (not used)
HEX2Z                                528  0x00000210 (const dword)  (not used)
HEX2ZB                              8720  0x00002210 (const dword)  (not used)
HEX3                                4880  0x00001310 (const dword)  (not used)
HEX3Z                                784  0x00000310 (const dword)  (not used)
HEX3ZB                              8976  0x00002310 (const dword)  (not used)
HEX4                                5136  0x00001410 (const dword)  (not used)
HEX4Z                               1040  0x00000410 (const dword)  (not used)
HEX4ZB                              9232  0x00002410 (const dword)  (not used)
HEXZ                                1040  0x00000410 (const dword)  (not used)
HEXZB                               9232  0x00002410 (const dword)  (not used)
hFonts                                 4  0x00000004 (mem) word[28] (global)  (usage 93)
HI                                     1  0x00000001 (const dword)  (not used)
HIbyte                              -214  0xffffff2a (PmmC func) args[1] r=1  (not used)
HIDE                                   2  0x00000002 (const dword)  (not used)
hndl                                   2  0x00000002 (mem) word (global)  (usage 114)
HONEYDEW                           63486  0x0000f7fe (const dword)  (not used)
HOTPINK                            64342  0x0000fb56 (const dword)  (not used)
hstrings                             116  0x00000074 (mem) word (global)  (usage 12)
I2C                                63520  0x0000f820 (const dword)  (not used)
I2C_Ack                             -169  0xffffff57 (PmmC func) args[0] r=0  (not used)
I2C_AckPoll                         -172  0xffffff54 (PmmC func) args[1] r=1  (not used)
I2C_AckStatus                       -171  0xffffff55 (PmmC func) args[0] r=0  (not used)
I2C_Close                           -163  0xffffff5d (PmmC func) args[0] r=0  (not used)
I2C_FAST                               2  0x00000002 (const dword)  (not used)
I2C_Getn                            -175  0xffffff51 (PmmC func) args[2] r=1  (not used)
I2C_Gets                            -174  0xffffff52 (PmmC func) args[2] r=1  (not used)
I2C_Idle                            -173  0xffffff53 (PmmC func) args[0] r=0  (not used)
I2C_MED                                1  0x00000001 (const dword)  (not used)
I2C_Nack                            -170  0xffffff56 (PmmC func) args[0] r=0  (not used)
I2C_Open                            -162  0xffffff5e (PmmC func) args[1] r=0  (not used)
I2C_Putn                            -177  0xffffff4f (PmmC func) args[2] r=1  (not used)
I2C_Puts                            -176  0xffffff50 (PmmC func) args[1] r=1  (not used)
I2C_Read                            -167  0xffffff59 (PmmC func) args[0] r=1  (not used)
I2C_Restart                         -166  0xffffff5a (PmmC func) args[0] r=1  (not used)
I2C_SLOW                               0  0x00000000 (const dword)  (not used)
I2C_Start                           -164  0xffffff5c (PmmC func) args[0] r=1  (not used)
I2C_Stop                            -165  0xffffff5b (PmmC func) args[0] r=1  (not used)
I2C_Write                           -168  0xffffff58 (PmmC func) args[1] r=1  (not used)
I_COLOUR16                            16  0x00000010 (const dword)  (not used)
I_DARKEN                           16384  0x00004000 (const dword)  (not used)
I_ENABLED                          32768  0x00008000 (const dword)  (usage 6)
I_LIGHTEN                           8192  0x00002000 (const dword)  (not used)
I_MOVIE                              128  0x00000080 (const dword)  (not used)
I_NOGROUP                             64  0x00000040 (const dword)  (not used)
I_STAYONTOP                          256  0x00000100 (const dword)  (usage 3)
I_TOPMOST                            512  0x00000200 (const dword)  (not used)
I_TOUCH_DISABLE                       32  0x00000020 (const dword)  (usage 6)
I_TOUCHED                           4096  0x00001000 (const dword)  (not used)
I_X_LOCK                            1024  0x00000400 (const dword)  (not used)
I_Y_LOCK                            2048  0x00000800 (const dword)  (not used)
iDigits                                2  0x00000002 (const dword)  (usage 9)
iiLeddigits0                          34  0x00000022 (const ??? 0)  (not used)
iiLeddigits1                          36  0x00000024 (const ??? 0)  (not used)
iiLeddigits10                         66  0x00000042 (const ??? 0)  (not used)
iiLeddigits11                         72  0x00000048 (const ??? 0)  (not used)
iiLeddigits12                         74  0x0000004a (const ??? 0)  (not used)
iiLeddigits13                         84  0x00000054 (const ??? 0)  (not used)
iiLeddigits14                         87  0x00000057 (const ??? 0)  (not used)
iiLeddigits15                         90  0x0000005a (const ??? 0)  (not used)
iiLeddigits16                         93  0x0000005d (const ??? 0)  (not used)
iiLeddigits17                         95  0x0000005f (const ??? 0)  (not used)
iiLeddigits18                        105  0x00000069 (const ??? 0)  (not used)
iiLeddigits19                        117  0x00000075 (const ??? 0)  (not used)
iiLeddigits2                          38  0x00000026 (const ??? 0)  (not used)
iiLeddigits20                        125  0x0000007d (const ??? 0)  (not used)
iiLeddigits21                        131  0x00000083 (const ??? 0)  (not used)
iiLeddigits3                          56  0x00000038 (const ??? 0)  (not used)
iiLeddigits4                          47  0x0000002f (const ??? 0)  (not used)
iiLeddigits5                          49  0x00000031 (const ??? 0)  (not used)
iiLeddigits6                          58  0x0000003a (const ??? 0)  (not used)
iiLeddigits7                          60  0x0000003c (const ??? 0)  (not used)
iiLeddigits8                          62  0x0000003e (const ??? 0)  (not used)
iiLeddigits9                          64  0x00000040 (const ??? 0)  (not used)
iImage0                                0  0x00000000 (const ??? 0)  (usage 3)
iImage1                               16  0x00000010 (const ??? 0)  (usage 3)
iLeadingBlanks                         8  0x00000008 (const dword)  (usage 3)
iLeddigits0                           33  0x00000021 (const ??? 0)  (usage 3)
iLeddigits1                           35  0x00000023 (const ??? 0)  (usage 3)
iLeddigits10                          65  0x00000041 (const ??? 0)  (usage 3)
iLeddigits11                          71  0x00000047 (const ??? 0)  (usage 3)
iLeddigits12                          73  0x00000049 (const ??? 0)  (usage 3)
iLeddigits13                          83  0x00000053 (const ??? 0)  (usage 3)
iLeddigits14                          86  0x00000056 (const ??? 0)  (usage 3)
iLeddigits15                          89  0x00000059 (const ??? 0)  (usage 3)
iLeddigits16                          92  0x0000005c (const ??? 0)  (usage 3)
iLeddigits17                          94  0x0000005e (const ??? 0)  (usage 3)
iLeddigits18                         104  0x00000068 (const ??? 0)  (usage 3)
iLeddigits19                         116  0x00000074 (const ??? 0)  (usage 3)
iLeddigits2                           37  0x00000025 (const ??? 0)  (usage 3)
iLeddigits20                         124  0x0000007c (const ??? 0)  (usage 3)
iLeddigits21                         130  0x00000082 (const ??? 0)  (usage 3)
iLeddigits3                           55  0x00000037 (const ??? 0)  (usage 3)
iLeddigits4                           46  0x0000002e (const ??? 0)  (usage 3)
iLeddigits5                           48  0x00000030 (const ??? 0)  (usage 3)
iLeddigits6                           57  0x00000039 (const ??? 0)  (usage 3)
iLeddigits7                           59  0x0000003b (const ??? 0)  (usage 3)
iLeddigits8                           61  0x0000003d (const ??? 0)  (usage 3)
iLeddigits9                           63  0x0000003f (const ??? 0)  (usage 3)
ileft                                  0  0x00000000 (const dword)  (usage 3)
IMAGE_CLUSTER                         10  0x0000000a (const dword)  (not used)
IMAGE_DELAY                            7  0x00000007 (const dword)  (not used)
IMAGE_FLAGS                            6  0x00000006 (const dword)  (usage 3)
IMAGE_FRAMES                           8  0x00000008 (const dword)  (not used)
IMAGE_HEIGHT                           5  0x00000005 (const dword)  (not used)
IMAGE_HIWORD                           1  0x00000001 (const dword)  (not used)
IMAGE_INDEX                            9  0x00000009 (const dword)  (usage 48)
IMAGE_LOWORD                           0  0x00000000 (const dword)  (not used)
IMAGE_SECTOR                          11  0x0000000b (const dword)  (not used)
IMAGE_TAG                             12  0x0000000c (const dword)  (usage 9)
IMAGE_TAG2                            13  0x0000000d (const dword)  (usage 9)
IMAGE_WIDTH                            4  0x00000004 (const dword)  (not used)
IMAGE_XPOS                             2  0x00000002 (const dword)  (usage 3)
IMAGE_YPOS                             3  0x00000003 (const dword)  (not used)
img_ClearAttributes                 -187  0xffffff45 (PmmC func) args[3] r=1  (usage 3)
IMG_COUNT                              0  0x00000000 (const dword)  (not used)
IMG_CURRENT_FRAME                     89  0x00000059 (const dword)  (not used)
img_Darken                          -181  0xffffff4b (PmmC func) args[2] r=1  (not used)
IMG_DAT_FILENAME                       4  0x00000004 (const dword)  (not used)
img_Disable                         -180  0xffffff4c (PmmC func) args[2] r=1  (usage 6)
img_Enable                          -179  0xffffff4d (PmmC func) args[2] r=1  (not used)
IMG_ENTRYLEN                           1  0x00000001 (const dword)  (not used)
IMG_FLAGS                             85  0x00000055 (const dword)  (not used)
IMG_FRAME_COUNT                       86  0x00000056 (const dword)  (not used)
IMG_FRAME_DELAY                       84  0x00000054 (const dword)  (not used)
IMG_GCI_FILENAME                       3  0x00000003 (const dword)  (not used)
IMG_GCIFILE_HANDLE                     5  0x00000005 (const dword)  (not used)
img_GetWord                         -184  0xffffff48 (PmmC func) args[3] r=1  (usage 48)
IMG_HEIGHT                            83  0x00000053 (const dword)  (not used)
img_Lighten                         -182  0xffffff4a (PmmC func) args[2] r=1  (not used)
IMG_MODE                               2  0x00000002 (const dword)  (not used)
IMG_PIXEL_COUNT_HI                    88  0x00000058 (const dword)  (not used)
IMG_PIXEL_COUNT_LO                    87  0x00000057 (const dword)  (not used)
img_SetAttributes                   -186  0xffffff46 (PmmC func) args[3] r=1  (usage 6)
img_SetPosition                     -178  0xffffff4e (PmmC func) args[4] r=1  (not used)
img_SetWord                         -183  0xffffff49 (PmmC func) args[4] r=1  (usage 24)
img_Show                            -185  0xffffff47 (PmmC func) args[2] r=1  (usage 21)
img_Touched                         -188  0xffffff44 (PmmC func) args[2] r=1  (usage 3)
IMG_WIDTH                             82  0x00000052 (const dword)  (not used)
iMinDigits                             4  0x00000004 (const dword)  (usage 3)
INDIANRED                          51947  0x0000caeb (const dword)  (not used)
INDIGO                             18448  0x00004810 (const dword)  (not used)
input                                196  0x000000c4 (mem) word (global)  (usage 27)
INPUT                                  1  0x00000001 (const dword)  (not used)
inputtype                            192  0x000000c0 (mem) word (global)  (usage 24)
INVERSE                               64  0x00000040 (const dword)  (not used)
IO1_PIN                                1  0x00000001 (const dword)  (not used)
IO2_PIN                                2  0x00000002 (const dword)  (not used)
IO3_PIN                                3  0x00000003 (const dword)  (not used)
IO4_PIN                                4  0x00000004 (const dword)  (not used)
IO5_PIN                                5  0x00000005 (const dword)  (not used)
IPControls                            99  0x00000063IPControls                            99  0x00000063 (mem) word[145] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 9)
IPD_DOWN                              16  0x00000010 (const dword)  (usage 6)
IPD_OBJVidx                           20  0x00000014 (const dword)  (usage 15)
IPD_P1                                 2  0x00000002 (const dword)  (usage 15)
IPD_P2                                 4  0x00000004 (const dword)  (usage 48)
IPD_P3                                 6  0x00000006 (const dword)  (usage 9)
IPD_P4                                 8  0x00000008 (const dword)  (usage 3)
IPD_P5                                10  0x0000000a (const dword)  (usage 6)
IPD_P6                                12  0x0000000c (const dword)  (usage 18)
IPD_P7                                14  0x0000000e (const dword)  (not used)
IPD_RELEASE                           18  0x00000012 (const dword)  (usage 9)
IPData                               389  0x00000185IPData                               389  0x00000185 (mem) word[1639] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 30)
IPDatasize                            22  0x00000016 (const dword)  (usage 3)
isalnum                             -207  0xffffff31 (PmmC func) args[1] r=1  (not used)
isalpha                             -206  0xffffff32 (PmmC func) args[1] r=1  (not used)
isdigit                             -202  0xffffff36 (PmmC func) args[1] r=1  (not used)
islower                             -205  0xffffff33 (PmmC func) args[1] r=1  (not used)
isprint                             -208  0xffffff30 (PmmC func) args[1] r=1  (not used)
isspace                             -209  0xffffff2f (PmmC func) args[1] r=1  (not used)
iStatictext1                          39  0x00000027 (const ??? 0)  (usage 3)
iStatictext10                         67  0x00000043 (const ??? 0)  (usage 3)
iStatictext11                         68  0x00000044 (const ??? 0)  (usage 3)
iStatictext12                         69  0x00000045 (const ??? 0)  (usage 3)
iStatictext13                         70  0x00000046 (const ??? 0)  (usage 3)
iStatictext14                         75  0x0000004b (const ??? 0)  (usage 3)
iStatictext15                         82  0x00000052 (const ??? 0)  (usage 3)
iStatictext16                         85  0x00000055 (const ??? 0)  (usage 3)
iStatictext17                         88  0x00000058 (const ??? 0)  (usage 3)
iStatictext18                         91  0x0000005b (const ??? 0)  (usage 3)
iStatictext19                         96  0x00000060 (const ??? 0)  (usage 3)
iStatictext2                          40  0x00000028 (const ??? 0)  (usage 3)
iStatictext20                        109  0x0000006d (const ??? 0)  (usage 3)
iStatictext21                        118  0x00000076 (const ??? 0)  (usage 3)
iStatictext22                        126  0x0000007e (const ??? 0)  (usage 3)
iStatictext23                        135  0x00000087 (const ??? 0)  (usage 3)
iStatictext3                           1  0x00000001 (const ??? 0)  (usage 3)
iStatictext4                          41  0x00000029 (const ??? 0)  (usage 3)
iStatictext5                          52  0x00000034 (const ??? 0)  (usage 3)
iStatictext6                          45  0x0000002d (const ??? 0)  (usage 3)
iStatictext7                          50  0x00000032 (const ??? 0)  (usage 3)
iStatictext8                          53  0x00000035 (const ??? 0)  (usage 3)
iStatictext9                          54  0x00000036 (const ??? 0)  (usage 3)
iStrings0                           3667  0x00000e53iStrings0                           3667  0x00000e53 (mem) word[13] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
iStrings1                           3693  0x00000e6diStrings1                           3693  0x00000e6d (mem) word[13] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
iStrings10                          3927  0x00000f57iStrings10                          3927  0x00000f57 (mem) word[13] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
iStrings11                          3953  0x00000f71iStrings11                          3953  0x00000f71 (mem) word[13] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
iStrings12                          3979  0x00000f8biStrings12                          3979  0x00000f8b (mem) word[13] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
iStrings13                          4005  0x00000fa5iStrings13                          4005  0x00000fa5 (mem) word[13] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
iStrings14                          4031  0x00000fbfiStrings14                          4031  0x00000fbf (mem) word[13] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
iStrings15                          4057  0x00000fd9iStrings15                          4057  0x00000fd9 (mem) word[13] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
iStrings16                          4083  0x00000ff3iStrings16                          4083  0x00000ff3 (mem) word[13] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
iStrings17                          4109  0x0000100diStrings17                          4109  0x0000100d (mem) word[13] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
iStrings18                          4135  0x00001027iStrings18                          4135  0x00001027 (mem) word[13] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
iStrings19                          4161  0x00001041iStrings19                          4161  0x00001041 (mem) word[13] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
iStrings2                           3719  0x00000e87iStrings2                           3719  0x00000e87 (mem) word[13] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
iStrings20                          4187  0x0000105biStrings20                          4187  0x0000105b (mem) word[13] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
iStrings21                          4213  0x00001075iStrings21                          4213  0x00001075 (mem) word[13] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
iStrings22                          4239  0x0000108fiStrings22                          4239  0x0000108f (mem) word[13] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
iStrings23                          4265  0x000010a9iStrings23                          4265  0x000010a9 (mem) word[13] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
iStrings24                          4291  0x000010c3iStrings24                          4291  0x000010c3 (mem) word[13] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
iStrings25                          4317  0x000010ddiStrings25                          4317  0x000010dd (mem) word[13] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
iStrings26                          4343  0x000010f7iStrings26                          4343  0x000010f7 (mem) word[13] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
iStrings27                          4369  0x00001111iStrings27                          4369  0x00001111 (mem) word[13] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
iStrings3                           3745  0x00000ea1iStrings3                           3745  0x00000ea1 (mem) word[13] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
iStrings4                           3771  0x00000ebbiStrings4                           3771  0x00000ebb (mem) word[13] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
iStrings5                           3797  0x00000ed5iStrings5                           3797  0x00000ed5 (mem) word[13] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
iStrings6                           3823  0x00000eefiStrings6                           3823  0x00000eef (mem) word[13] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
iStrings7                           3849  0x00000f09iStrings7                           3849  0x00000f09 (mem) word[13] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
iStrings8                           3875  0x00000f23iStrings8                           3875  0x00000f23 (mem) word[13] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
iStrings9                           3901  0x00000f3diStrings9                           3901  0x00000f3d (mem) word[13] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
isupper                             -204  0xffffff34 (PmmC func) args[1] r=1  (not used)
iswhite                             -210  0xffffff2e (PmmC func) args[1] r=1  (not used)
isxdigit                            -203  0xffffff35 (PmmC func) args[1] r=1  (not used)
ITALIC                                32  0x00000020 (const dword)  (not used)
iterator                            -198  0xffffff3a (PmmC func) args[1] r=0  (not used)
iUserbutton0                          19  0x00000013 (const ??? 0)  (usage 3)
iUserbutton1                           2  0x00000002 (const ??? 0)  (usage 3)
iUserbutton10                         14  0x0000000e (const ??? 0)  (usage 3)
iUserbutton11                         15  0x0000000f (const ??? 0)  (usage 3)
iUserbutton12                         17  0x00000011 (const ??? 0)  (usage 3)
iUserbutton13                         18  0x00000012 (const ??? 0)  (usage 3)
iUserbutton14                          6  0x00000006 (const ??? 0)  (usage 3)
iUserbutton15                          8  0x00000008 (const ??? 0)  (usage 3)
iUserbutton16                         51  0x00000033 (const ??? 0)  (usage 3)
iUserbutton17                         24  0x00000018 (const ??? 0)  (usage 3)
iUserbutton18                         43  0x0000002b (const ??? 0)  (usage 3)
iUserbutton19                         44  0x0000002c (const ??? 0)  (usage 3)
iUserbutton2                          20  0x00000014 (const ??? 0)  (usage 3)
iUserbutton20                         79  0x0000004f (const ??? 0)  (usage 3)
iUserbutton21                         80  0x00000050 (const ??? 0)  (usage 3)
iUserbutton22                         81  0x00000051 (const ??? 0)  (usage 3)
iUserbutton23                         76  0x0000004c (const ??? 0)  (usage 3)
iUserbutton24                         77  0x0000004d (const ??? 0)  (usage 3)
iUserbutton25                         78  0x0000004e (const ??? 0)  (usage 3)
iUserbutton26                         98  0x00000062 (const ??? 0)  (usage 3)
iUserbutton27                         99  0x00000063 (const ??? 0)  (usage 3)
iUserbutton28                        100  0x00000064 (const ??? 0)  (usage 3)
iUserbutton29                        101  0x00000065 (const ??? 0)  (usage 3)
iUserbutton3                          32  0x00000020 (const ??? 0)  (usage 3)
iUserbutton30                        102  0x00000066 (const ??? 0)  (usage 3)
iUserbutton31                        103  0x00000067 (const ??? 0)  (usage 3)
iUserbutton32                        106  0x0000006a (const ??? 0)  (usage 3)
iUserbutton33                        107  0x0000006b (const ??? 0)  (usage 3)
iUserbutton34                        108  0x0000006c (const ??? 0)  (usage 3)
iUserbutton35                        110  0x0000006e (const ??? 0)  (usage 3)
iUserbutton36                        111  0x0000006f (const ??? 0)  (usage 3)
iUserbutton37                        112  0x00000070 (const ??? 0)  (usage 3)
iUserbutton38                        115  0x00000073 (const ??? 0)  (usage 3)
iUserbutton39                        113  0x00000071 (const ??? 0)  (usage 3)
iUserbutton4                           4  0x00000004 (const ??? 0)  (usage 3)
iUserbutton40                        114  0x00000072 (const ??? 0)  (usage 3)
iUserbutton41                        119  0x00000077 (const ??? 0)  (usage 3)
iUserbutton42                        120  0x00000078 (const ??? 0)  (usage 3)
iUserbutton43                        121  0x00000079 (const ??? 0)  (usage 3)
iUserbutton44                        127  0x0000007f (const ??? 0)  (usage 3)
iUserbutton45                        132  0x00000084 (const ??? 0)  (usage 3)
iUserbutton46                        122  0x0000007a (const ??? 0)  (usage 3)
iUserbutton47                        128  0x00000080 (const ??? 0)  (usage 3)
iUserbutton48                        123  0x0000007b (const ??? 0)  (usage 3)
iUserbutton49                        129  0x00000081 (const ??? 0)  (usage 3)
iUserbutton5                           5  0x00000005 (const ??? 0)  (usage 3)
iUserbutton50                         21  0x00000015 (const ??? 0)  (usage 3)
iUserbutton51                        136  0x00000088 (const ??? 0)  (usage 3)
iUserbutton52                        134  0x00000086 (const ??? 0)  (usage 3)
iUserbutton53                        137  0x00000089 (const ??? 0)  (usage 3)
iUserbutton54                         22  0x00000016 (const ??? 0)  (usage 3)
iUserbutton55                        139  0x0000008b (const ??? 0)  (usage 3)
iUserbutton56                        140  0x0000008c (const ??? 0)  (usage 3)
iUserbutton57                        141  0x0000008d (const ??? 0)  (usage 3)
iUserbutton58                        142  0x0000008e (const ??? 0)  (usage 3)
iUserbutton59                        143  0x0000008f (const ??? 0)  (usage 3)
iUserbutton6                          10  0x0000000a (const ??? 0)  (usage 3)
iUserbutton60                        144  0x00000090 (const ??? 0)  (usage 3)
iUserbutton61                          3  0x00000003 (const ??? 0)  (usage 3)
iUserbutton62                         23  0x00000017 (const ??? 0)  (usage 3)
iUserbutton63                         42  0x0000002a (const ??? 0)  (usage 3)
iUserbutton7                          11  0x0000000b (const ??? 0)  (usage 3)
iUserbutton8                          12  0x0000000c (const ??? 0)  (usage 3)
iUserbutton9                          13  0x0000000d (const ??? 0)  (usage 3)
iUserimages0                           7  0x00000007 (const ??? 0)  (usage 3)
iUserimages1                         133  0x00000085 (const ??? 0)  (usage 3)
iUserimages2                         138  0x0000008a (const ??? 0)  (usage 3)
iVideo0                                9  0x00000009 (const ??? 0)  (usage 3)
iVideo1                               97  0x00000061 (const ??? 0)  (usage 3)
IVORY                              65534  0x0000fffe (const dword)  (not used)
iWidthDigit                            6  0x00000006 (const dword)  (usage 3)
iWinbutton0                           25  0x00000019 (const ??? 0)  (usage 3)
iWinbutton1                           26  0x0000001a (const ??? 0)  (usage 3)
iWinbutton2                           27  0x0000001b (const ??? 0)  (usage 3)
iWinbutton3                           28  0x0000001c (const ??? 0)  (usage 3)
iWinbutton4                           29  0x0000001d (const ??? 0)  (usage 3)
iWinbutton7                           30  0x0000001e (const ??? 0)  (usage 3)
iWinbutton8                           31  0x0000001f (const ??? 0)  (usage 3)
KHAKI                              63281  0x0000f731 (const dword)  (not used)
kKeyboardKeystrokes                 4863  0x000012ffkKeyboardKeystrokes                 4863  0x000012ff (mem) word[1] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (not used)
LANDSCAPE                              0  0x00000000 (const dword)  (not used)
LANDSCAPE_R                            1  0x00000001 (const dword)  (usage 3)
LAVENDER                           59199  0x0000e73f (const dword)  (not used)
LAVENDERBLUSH                      65438  0x0000ff9e (const dword)  (not used)
LAWNGREEN                          32736  0x00007fe0 (const dword)  (not used)
ledDigitsDisplay                    8143  0x00001fcf (User func) args[3] r=0  (usage 6)
LEFT_POS                               2  0x00000002 (const dword)  (not used)
LEMONCHIFFON                       65497  0x0000ffd9 (const dword)  (not used)
LIGHTBLUE                          44764  0x0000aedc (const dword)  (not used)
LIGHTCORAL                         62480  0x0000f410 (const dword)  (not used)
LIGHTCYAN                          59391  0x0000e7ff (const dword)  (not used)
LIGHTGOLD                          65498  0x0000ffda (const dword)  (not used)
LIGHTGREEN                         38770  0x00009772 (const dword)  (not used)
LIGHTGREY                          54938  0x0000d69a (const dword)  (not used)
LIGHTPINK                          64952  0x0000fdb8 (const dword)  (not used)
LIGHTSALMON                        64783  0x0000fd0f (const dword)  (not used)
LIGHTSEAGREEN                       9621  0x00002595 (const dword)  (not used)
LIGHTSKYBLUE                       34431  0x0000867f (const dword)  (not used)
LIGHTSLATEGRAY                     29779  0x00007453 (const dword)  (not used)
LIGHTSTEELBLUE                     46651  0x0000b63b (const dword)  (not used)
LIGHTYELLOW                        65532  0x0000fffc (const dword)  (not used)
LIME                                2016  0x000007e0 (const dword)  (not used)
LIMEGREEN                          13926  0x00003666 (const dword)  (not used)
LINE_PATTERN                          26  0x0000001a (const dword)  (not used)
LINEN                              65436  0x0000ff9c (const dword)  (not used)
LO                                     0  0x00000000 (const dword)  (not used)
LObyte                              -213  0xffffff2b (PmmC func) args[1] r=1  (not used)
LPCOARSE                           61680  0x0000f0f0 (const dword)  (not used)
LPDASHDOT                            975  0x000003cf (const dword)  (not used)
LPDASHDOTDOT                         819  0x00000333 (const dword)  (not used)
LPFINE                             43690  0x0000aaaa (const dword)  (not used)
LPMEDIUM                           13107  0x00003333 (const dword)  (not used)
LPSOLID                                0  0x00000000 (const dword)  (not used)
MAGENTA                            63519  0x0000f81f (const dword)  (not used)
main                                5283  0x000014a3 (User func) args[0] r=0  (not used)
MAROON                             32768  0x00008000 (const dword)  (not used)
MAX                                  -15  0xfffffff1 (PmmC func) args[2] r=1  (not used)
MaxTotObjects                         33  0x00000021 (const dword)  (usage 6)
MDA                                63552  0x0000f840 (const dword)  (not used)
MEDIA_ADDRESS_HI                      91  0x0000005b (const dword)  (not used)
MEDIA_ADDRESS_LO                      90  0x0000005a (const dword)  (not used)
MEDIA_ADDRESS_MW                      92  0x0000005c (const dword)  (not used)
MEDIA_ADDRESS_UW                      93  0x0000005d (const dword)  (not used)
media_Flush                         -118  0xffffff8a (PmmC func) args[0] r=1  (not used)
media_Image                         -117  0xffffff8b (PmmC func) args[2] r=0  (not used)
media_Init                          -119  0xffffff89 (PmmC func) args[0] r=1  (not used)
media_RdSector                      -111  0xffffff91 (PmmC func) args[1] r=1  (not used)
media_ReadByte                      -113  0xffffff8f (PmmC func) args[0] r=1  (not used)
media_ReadWord                      -114  0xffffff8e (PmmC func) args[0] r=1  (not used)
MEDIA_SECTOR_COUNT                    94  0x0000005e (const dword)  (not used)
MEDIA_SECTOR_HI                      124  0x0000007c (const dword)  (not used)
MEDIA_SECTOR_LO                      123  0x0000007b (const dword)  (not used)
media_SetAdd                        -109  0xffffff93 (PmmC func) args[2] r=0  (not used)
media_SetSector                     -110  0xffffff92 (PmmC func) args[2] r=0  (not used)
media_Video                         -107  0xffffff95 (PmmC func) args[2] r=0  (not used)
media_VideoFrame                    -108  0xffffff94 (PmmC func) args[3] r=0  (not used)
media_WriteByte                     -115  0xffffff8d (PmmC func) args[1] r=1  (not used)
media_WriteWord                     -116  0xffffff8c (PmmC func) args[1] r=1  (not used)
media_WrSector                      -112  0xffffff90 (PmmC func) args[1] r=1  (not used)
MEDIUMAQUAMARINE                   26229  0x00006675 (const dword)  (not used)
MEDIUMBLUE                            25  0x00000019 (const dword)  (not used)
MEDIUMORCHID                       47802  0x0000baba (const dword)  (not used)
MEDIUMPURPLE                       37787  0x0000939b (const dword)  (not used)
MEDIUMSEAGREEN                     15758  0x00003d8e (const dword)  (not used)
MEDIUMSLATEBLUE                    31581  0x00007b5d (const dword)  (not used)
MEDIUMSPRINGGREEN                   2003  0x000007d3 (const dword)  (not used)
MEDIUMTURQUOISE                    20121  0x00004e99 (const dword)  (not used)
MEDIUMVIOLETRED                    49328  0x0000c0b0 (const dword)  (not used)
mem_Alloc                           -216  0xffffff28 (PmmC func) args[1] r=1  (not used)
mem_AllocV                          -217  0xffffff27 (PmmC func) args[1] r=1  (not used)
mem_AllocZ                          -218  0xffffff26 (PmmC func) args[1] r=1  (not used)
mem_Compare                         -224  0xffffff20 (PmmC func) args[3] r=1  (not used)
mem_Copy                            -223  0xffffff21 (PmmC func) args[3] r=1  (not used)
mem_Free                            -220  0xffffff24 (PmmC func) args[1] r=1  (not used)
mem_Heap                            -221  0xffffff23 (PmmC func) args[0] r=1  (not used)
mem_Realloc                         -219  0xffffff25 (PmmC func) args[2] r=1  (not used)
mem_Set                             -222  0xffffff22 (PmmC func) args[3] r=1  (not used)
MEMORY_ACCESS_CONTROL                 22  0x00000016 (const dword)  (not used)
MIDI                                   9  0x00000009 (const dword)  (not used)
MIDNIGHTBLUE                        6350  0x000018ce (const dword)  (not used)
MIN                                  -14  0xfffffff2 (PmmC func) args[2] r=1  (not used)
MINTCREAM                          63487  0x0000f7ff (const dword)  (not used)
MISTYROSE                          65340  0x0000ff3c (const dword)  (not used)
MOCCASIN                           65334  0x0000ff36 (const dword)  (not used)
NAK                                   21  0x00000015 (const dword)  (usage 24)
NAVAJOWHITE                        65269  0x0000fef5 (const dword)  (not used)
NAVY                                  16  0x00000010 (const dword)  (not used)
nInputs                              149  0x00000095 (const dword)  (usage 3)
nObjects                             145  0x00000091 (const dword)  (not used)
NOTOUCH                                0  0x00000000 (const dword)  (not used)
o4Dbuttons                          4675  0x00001243o4Dbuttons                          4675  0x00001243 (mem) word[1] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
oAngularmeters                      4427  0x0000114boAngularmeters                      4427  0x0000114b (mem) word[1] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
oAniButtons                         4677  0x00001245oAniButtons                         4677  0x00001245 (mem) word[1] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
object                               198  0x000000c6 (mem) word (global)  (usage 18)
OBJECT_COLOUR                         18  0x00000012 (const dword)  (not used)
oColorPickers                       4679  0x00001247oColorPickers                       4679  0x00001247 (mem) word[1] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
oCoolgauges                         4429  0x0000114doCoolgauges                         4429  0x0000114d (mem) word[1] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
Ocs                                  442  0x000001ba (mem) word (global)  (usage 9)
oCustomdigitss                      4431  0x0000114foCustomdigitss                      4431  0x0000114f (mem) word[1] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
oDipSwitchs                         4395  0x0000112boDipSwitchs                         4395  0x0000112b (mem) word[1] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
OFF                                    0  0x00000000 (const dword)  (usage 3)
oForms                              4433  0x00001151oForms                              4433  0x00001151 (mem) word[24] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
oGauges                             4481  0x00001181oGauges                             4481  0x00001181 (mem) word[1] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
oGSliders                           4403  0x00001133oGSliders                           4403  0x00001133 (mem) word[1] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
oImages                             4483  0x00001183oImages                             4483  0x00001183 (mem) word[3] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
oKeyboards                          4489  0x00001189oKeyboards                          4489  0x00001189 (mem) word[1] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
oKnobs                              4397  0x0000112doKnobs                              4397  0x0000112d (mem) word[1] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
OLDLACE                            65468  0x0000ffbc (const dword)  (not used)
oLeddigitss                         4493  0x0000118doLeddigitss                         4493  0x0000118d (mem) word[23] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 9)
oLeds                               4491  0x0000118boLeds                               4491  0x0000118b (mem) word[1] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
OLIVE                              33792  0x00008400 (const dword)  (not used)
OLIVEDRAB                          27748  0x00006c64 (const dword)  (not used)
oMeters                             4539  0x000011bboMeters                             4539  0x000011bb (mem) word[1] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
ON                                     1  0x00000001 (const dword)  (usage 3)
oObjects                             118  0x00000076 (mem) word[34] (global)  (usage 108)
OPAQUE                                 1  0x00000001 (const dword)  (not used)
OPDataL                             4865  0x00001301OPDataL                             4865  0x00001301 (mem) word[110] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 6)
oPinInputs                          4673  0x00001241oPinInputs                          4673  0x00001241 (mem) word[1] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
oPinOutputs                         4815  0x000012cfoPinOutputs                         4815  0x000012cf (mem) word[1] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
ORANGE                             64800  0x0000fd20 (const dword)  (not used)
ORANGERED                          64032  0x0000fa20 (const dword)  (not used)
ORCHID                             56218  0x0000db9a (const dword)  (not used)
oRockerSwitchs                      4399  0x0000112foRockerSwitchs                      4399  0x0000112f (mem) word[1] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
oRotarySwitchs                      4401  0x00001131oRotarySwitchs                      4401  0x00001131 (mem) word[1] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
OSC_CONTROL_1                         25  0x00000019 (const dword)  (not used)
OSC_CONTROL_3                        147  0x00000093 (const dword)  (not used)
oScopes                             4661  0x00001235oScopes                             4661  0x00001235 (mem) word[1] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (not used)
oSoundss                            4813  0x000012cdoSoundss                            4813  0x000012cd (mem) word[1] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
oSpectrums                          4659  0x00001233oSpectrums                          4659  0x00001233 (mem) word[1] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
oStaticTexts                        4609  0x00001201oStaticTexts                        4609  0x00001201 (mem) word[25] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
oStringss                           4541  0x000011bdoStringss                           4541  0x000011bd (mem) word[29] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 7)
oStringss                         UNRESOLVED  (usage 2)
OT_ACTIVATE                          103  0x00000067 (const dword)  (usage 96)
OT_NEXTFRAME                         104  0x00000068 (const dword)  (usage 3)
OT_NEXTSTRING                        106  0x0000006a (const dword)  (usage 3)
OT_PREVFRAME                         105  0x00000069 (const dword)  (usage 3)
OT_PREVSTRING                        107  0x0000006b (const dword)  (usage 3)
OT_REPORT                            100  0x00000064 (const dword)  (usage 144)
OT_SETANOTHER                        102  0x00000066 (const dword)  (usage 3)
OT_SETCONST                          101  0x00000065 (const dword)  (usage 3)
oTanks                              4663  0x00001237oTanks                              4663  0x00001237 (mem) word[1] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
oThermometers                       4599  0x000011f7oThermometers                       4599  0x000011f7 (mem) word[1] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
oTimers                             4811  0x000012cboTimers                             4811  0x000012cb (mem) word[1] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
oTrackbars                          4405  0x00001135oTrackbars                          4405  0x00001135 (mem) word[1] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
oUserButtons                        4681  0x00001249oUserButtons                        4681  0x00001249 (mem) word[65] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 12)
oUserImagess                        4665  0x00001239oUserImagess                        4665  0x00001239 (mem) word[4] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
oUserleds                           4601  0x000011f9oUserleds                           4601  0x000011f9 (mem) word[1] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
OUTLINE                                1  0x00000001 (const dword)  (not used)
OUTLINE_COLOUR                        24  0x00000018 (const dword)  (not used)
OUTPUT                                 0  0x00000000 (const dword)  (not used)
OVF                                  -21  0xffffffeb (PmmC func) args[0] r=1  (usage 3)
oVideos                             4603  0x000011fboVideos                             4603  0x000011fb (mem) word[3] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 3)
oWinButtons                         4407  0x00001137oWinButtons                         4407  0x00001137 (mem) word[10] (member of C:\Users\jcalduch\Desktop\RepRapBCN_TouchScreen_update1\RepRap_Touchv1.4DWork\RepRap_Touchv1.4DGenieS)  (usage 12)
PALEGOLDENROD                      61269  0x0000ef55 (const dword)  (not used)
PALEGREEN                          40915  0x00009fd3 (const dword)  (not used)
PALETURQUOISE                      44925  0x0000af7d (const dword)  (not used)
PALEVIOLETRED                      56210  0x0000db92 (const dword)  (not used)
PANEL_HIDE                             2  0x00000002 (const dword)  (not used)
PANEL_RAISED                           1  0x00000001 (const dword)  (usage 3)
PANEL_SUNKEN                           0  0x00000000 (const dword)  (not used)
PAPAYAWHIP                         65402  0x0000ff7a (const dword)  (not used)
pause                                 -6  0xfffffffa (PmmC func) args[1] r=0  (usage 6)
PEACHPUFF                          65239  0x0000fed7 (const dword)  (not used)
peekW                                -11  0xfffffff5 (PmmC func) args[1] r=1  (not used)
PEN_SIZE                              16  0x00000010 (const dword)  (not used)
PERU                               52263  0x0000cc27 (const dword)  (not used)
PICASO                                 1  0x00000001 (const dword)  (usage 3)
PICASO_FUNCTIONS                       0  0x00000000 (const ??? 0)  (not used)
pin_HI                               -42  0xffffffd6 (PmmC func) args[1] r=1  (not used)
pin_LO                               -43  0xffffffd5 (PmmC func) args[1] r=1  (not used)
pin_Read                             -44  0xffffffd4 (PmmC func) args[1] r=1  (not used)
pin_Set                              -41  0xffffffd7 (PmmC func) args[2] r=1  (not used)
PINK                               65049  0x0000fe19 (const dword)  (not used)
PLUM                               56603  0x0000dd1b (const dword)  (not used)
pokeW                                -12  0xfffffff4 (PmmC func) args[2] r=0  (not used)
PORTRAIT                               2  0x00000002 (const dword)  (not used)
PORTRAIT_R                             3  0x00000003 (const dword)  (not used)
POWDERBLUE                         46876  0x0000b71c (const dword)  (not used)
POWER_CONTROL_1                       27  0x0000001b (const dword)  (not used)
POWER_CONTROL_2                       28  0x0000001c (const dword)  (not used)
POWER_CONTROL_3                       29  0x0000001d (const dword)  (not used)
POWER_CONTROL_4                       30  0x0000001e (const dword)  (not used)
POWER_CONTROL_5                       31  0x0000001f (const dword)  (not used)
POWER_CONTROL_6                       32  0x00000020 (const dword)  (not used)
PrintStrings                        9265  0x00002431 (User func) args[3] r=0  (usage 9)
PROGRESSBAR_HIDE                       2  0x00000002 (const dword)  (not used)
PROGRESSBAR_RAISED                 65535  0x0000ffff (const dword)  (not used)
PROGRESSBAR_SUNKEN                 65534  0x0000fffe (const dword)  (not used)
PURPLE                             32784  0x00008010 (const dword)  (not used)
putch                                 -2  0xfffffffe (PmmC func) args[1] r=0  (usage 6)
putnum                                -7  0xfffffff9 (PmmC func) args[2] r=1  (not used)
putstr                                -9  0xfffffff7 (PmmC func) args[1] r=1  (usage 6)
RAND                                 -19  0xffffffed (PmmC func) args[0] r=1  (not used)
RANDOM_HI                             33  0x00000021 (const dword)  (not used)
RANDOM_LO                             32  0x00000020 (const dword)  (not used)
READ_OBJ                               0  0x00000000 (const dword)  (usage 3)
READ_WRITE_DATA                       34  0x00000022 (const dword)  (not used)
ReadCmd                              128  0x00000080 (const dword)  (not used)
ReadObject                          9011  0x00002333 (User func) args[2] r=0  (usage 3)
RED                                63488  0x0000f800 (const dword)  (not used)
REPORT_EVENT                           7  0x00000007 (const dword)  (usage 3)
REPORT_OBJ                             5  0x00000005 (const dword)  (usage 3)
reserved                            -294  0xfffffeda (PmmC func) args[0] r=0  (not used)
RGBINT_CONTROL_1                      56  0x00000038 (const dword)  (not used)
RIGHT_POS                              4  0x00000004 (const dword)  (not used)
ROSYBROWN                          48241  0x0000bc71 (const dword)  (not used)
ROW_ADDRESS_END1                       9  0x00000009 (const dword)  (not used)
ROW_ADDRESS_END2                       8  0x00000008 (const dword)  (not used)
ROW_ADDRESS_START1                     7  0x00000007 (const dword)  (not used)
ROW_ADDRESS_START2                     6  0x00000006 (const dword)  (not used)
ROYALBLUE                          17244  0x0000435c (const dword)  (not used)
RUNFLASH                             128  0x00000080 (const dword)  (usage 3)
RXMODE_0                               0  0x00000000 (const dword)  (not used)
RXMODE_1                               1  0x00000001 (const dword)  (not used)
SADDLEBROWN                        35362  0x00008a22 (const dword)  (not used)
SALMON                             64526  0x0000fc0e (const dword)  (not used)
SANDYBROWN                         62764  0x0000f52c (const dword)  (not used)
SCREEN_MODE                           23  0x00000017 (const dword)  (not used)
SEAGREEN                           11338  0x00002c4a (const dword)  (not used)
SEASHELL                           65469  0x0000ffbd (const dword)  (not used)
SEED                                 -20  0xffffffec (PmmC func) args[1] r=0  (not used)
SELECT                                 3  0x00000003 (const dword)  (not used)
SELECT_MULTIPLE                        4  0x00000004 (const dword)  (not used)
serin                                 -1  0xffffffff (PmmC func) args[0] r=1  (usage 3)
serin1                              -140  0xffffff74 (PmmC func) args[0] r=1  (not used)
serout                                -3  0xfffffffd (PmmC func) args[1] r=0  (usage 42)
serout1                             -141  0xffffff73 (PmmC func) args[1] r=0  (not used)
seroutCS                            9247  0x0000241f (User func) args[1] r=0  (usage 30)
seroutOcs                           9232  0x00002410 (User func) args[0] r=0  (usage 6)
setbaud                               -4  0xfffffffc (PmmC func) args[1] r=0  (not used)
SIENNA                             41605  0x0000a285 (const dword)  (not used)
SILVER                             50712  0x0000c618 (const dword)  (not used)
SIN                                  -17  0xffffffef (PmmC func) args[1] r=1  (not used)
SKYBLUE                            34429  0x0000867d (const dword)  (not used)
SLATEBLUE                          27353  0x00006ad9 (const dword)  (not used)
SLATEGRAY                          29714  0x00007412 (const dword)  (not used)
SLIDER_HIDE                            2  0x00000002 (const dword)  (not used)
SLIDER_RAISED                          1  0x00000001 (const dword)  (not used)
SLIDER_SUNKEN                          0  0x00000000 (const dword)  (not used)
snd_BufSize                         -258  0xfffffefe (PmmC func) args[1] r=0  (usage 3)
snd_Continue                        -261  0xfffffefb (PmmC func) args[0] r=0  (not used)
snd_Pause                           -260  0xfffffefc (PmmC func) args[0] r=0  (not used)
snd_Pitch                           -257  0xfffffeff (PmmC func) args[1] r=1  (not used)
snd_Playing                         -262  0xfffffefa (PmmC func) args[0] r=1  (not used)
snd_Stop                            -259  0xfffffefd (PmmC func) args[0] r=0  (not used)
snd_Volume                          -256  0xffffff00 (PmmC func) args[1] r=0  (not used)
SNOW                               65503  0x0000ffdf (const dword)  (not used)
SOLID                                  0  0x00000000 (const dword)  (not used)
spi_Disable                         -153  0xffffff67 (PmmC func) args[0] r=0  (not used)
SPI_FAST                               0  0x00000000 (const dword)  (not used)
spi_Init                            -150  0xffffff6a (PmmC func) args[3] r=0  (not used)
SPI_MED                                1  0x00000001 (const dword)  (not used)
spi_Read                            -151  0xffffff69 (PmmC func) args[0] r=1  (not used)
SPI_SLOW                               2  0x00000002 (const dword)  (not used)
spi_Write                           -152  0xffffff68 (PmmC func) args[1] r=0  (not used)
SPRINGGREEN                         2031  0x000007ef (const dword)  (not used)
SQRT                                 -22  0xffffffea (PmmC func) args[1] r=1  (not used)
STAnsi                                22  0x00000016 (const dword)  (usage 3)
STBGColor                             16  0x00000010 (const dword)  (usage 6)
STEELBLUE                          17430  0x00004416 (const dword)  (not used)
STFGColor                             14  0x0000000e (const dword)  (usage 3)
STFontAttribs                         18  0x00000012 (const dword)  (usage 3)
STForm                                24  0x00000018 (const dword)  (usage 3)
STR                                  128  0x00000080 (const dword)  (not used)
str_ByteMove                        -286  0xfffffee2 (PmmC func) args[3] r=1  (not used)
str_Cat                             -278  0xfffffeea (PmmC func) args[2] r=1  (not used)
str_CatN                            -279  0xfffffee9 (PmmC func) args[3] r=1  (not used)
str_Copy                            -287  0xfffffee1 (PmmC func) args[2] r=1  (not used)
str_CopyN                           -288  0xfffffee0 (PmmC func) args[3] r=1  (not used)
str_Find                            -274  0xfffffeee (PmmC func) args[2] r=1  (not used)
str_FindI                           -275  0xfffffeed (PmmC func) args[2] r=1  (not used)
str_GetByte                         -268  0xfffffef4 (PmmC func) args[1] r=1  (not used)
str_GetC                            -267  0xfffffef5 (PmmC func) args[2] r=1  (not used)
str_GetD                            -264  0xfffffef8 (PmmC func) args[2] r=1  (not used)
str_GetHexW                         -266  0xfffffef6 (PmmC func) args[2] r=1  (not used)
str_GetW                            -265  0xfffffef7 (PmmC func) args[2] r=1  (not used)
str_GetWord                         -269  0xfffffef3 (PmmC func) args[1] r=1  (not used)
str_Length                          -276  0xfffffeec (PmmC func) args[1] r=1  (not used)
str_Match                           -272  0xfffffef0 (PmmC func) args[2] r=1  (not used)
str_MatchI                          -273  0xfffffeef (PmmC func) args[2] r=1  (not used)
str_Printf                          -277  0xfffffeeb (PmmC func) args[2] r=1  (not used)
str_Ptr                             -263  0xfffffef9 (PmmC func) args[1] r=1  (not used)
str_PutByte                         -270  0xfffffef2 (PmmC func) args[2] r=0  (not used)
str_PutWord                         -271  0xfffffef1 (PmmC func) args[2] r=0  (not used)
strheight                           -161  0xffffff5f (PmmC func) args[0] r=1  (not used)
Strings0Count                          1  0x00000001 (const dword)  (not used)
Strings0Size                          28  0x0000001c (const dword)  (usage 3)
Strings0StartH                         0  0x00000000 (const dword)  (usage 3)
Strings0StartL                         0  0x00000000 (const dword)  (usage 3)
Strings10Count                         0  0x00000000 (const dword)  (not used)
Strings10Size                          1  0x00000001 (const dword)  (usage 3)
Strings10StartH                        0  0x00000000 (const dword)  (usage 3)
Strings10StartL                     6144  0x00001800 (const dword)  (usage 3)
Strings11Count                         1  0x00000001 (const dword)  (not used)
Strings11Size                         25  0x00000019 (const dword)  (usage 3)
Strings11StartH                        0  0x00000000 (const dword)  (usage 3)
Strings11StartL                     6656  0x00001a00 (const dword)  (usage 3)
Strings12Count                         1  0x00000001 (const dword)  (not used)
Strings12Size                         19  0x00000013 (const dword)  (usage 3)
Strings12StartH                        0  0x00000000 (const dword)  (usage 3)
Strings12StartL                     7168  0x00001c00 (const dword)  (usage 3)
Strings13Count                         1  0x00000001 (const dword)  (not used)
Strings13Size                         25  0x00000019 (const dword)  (usage 3)
Strings13StartH                        0  0x00000000 (const dword)  (usage 3)
Strings13StartL                     1536  0x00000600 (const dword)  (usage 3)
Strings14Count                         1  0x00000001 (const dword)  (not used)
Strings14Size                         23  0x00000017 (const dword)  (usage 3)
Strings14StartH                        0  0x00000000 (const dword)  (usage 3)
Strings14StartL                     7680  0x00001e00 (const dword)  (usage 3)
Strings15Count                         1  0x00000001 (const dword)  (not used)
Strings15Size                         24  0x00000018 (const dword)  (usage 3)
Strings15StartH                        0  0x00000000 (const dword)  (usage 3)
Strings15StartL                     8704  0x00002200 (const dword)  (usage 3)
Strings16Count                         1  0x00000001 (const dword)  (not used)
Strings16Size                         31  0x0000001f (const dword)  (usage 3)
Strings16StartH                        0  0x00000000 (const dword)  (usage 3)
Strings16StartL                     8192  0x00002000 (const dword)  (usage 3)
Strings17Count                         1  0x00000001 (const dword)  (not used)
Strings17Size                         33  0x00000021 (const dword)  (usage 3)
Strings17StartH                        0  0x00000000 (const dword)  (usage 3)
Strings17StartL                     9216  0x00002400 (const dword)  (usage 3)
Strings18Count                         1  0x00000001 (const dword)  (not used)
Strings18Size                         32  0x00000020 (const dword)  (usage 3)
Strings18StartH                        0  0x00000000 (const dword)  (usage 3)
Strings18StartL                     9728  0x00002600 (const dword)  (usage 3)
Strings19Count                         1  0x00000001 (const dword)  (not used)
Strings19Size                         29  0x0000001d (const dword)  (usage 3)
Strings19StartH                        0  0x00000000 (const dword)  (usage 3)
Strings19StartL                    10240  0x00002800 (const dword)  (usage 3)
Strings1Count                          0  0x00000000 (const dword)  (not used)
Strings1Size                           1  0x00000001 (const dword)  (usage 3)
Strings1StartH                         0  0x00000000 (const dword)  (usage 3)
Strings1StartL                       512  0x00000200 (const dword)  (usage 3)
Strings20Count                         1  0x00000001 (const dword)  (not used)
Strings20Size                         25  0x00000019 (const dword)  (usage 3)
Strings20StartH                        0  0x00000000 (const dword)  (usage 3)
Strings20StartL                     2560  0x00000a00 (const dword)  (usage 3)
Strings21Count                         1  0x00000001 (const dword)  (not used)
Strings21Size                         30  0x0000001e (const dword)  (usage 3)
Strings21StartH                        0  0x00000000 (const dword)  (usage 3)
Strings21StartL                    10752  0x00002a00 (const dword)  (usage 3)
Strings22Count                         1  0x00000001 (const dword)  (not used)
Strings22Size                         20  0x00000014 (const dword)  (usage 3)
Strings22StartH                        0  0x00000000 (const dword)  (usage 3)
Strings22StartL                    11264  0x00002c00 (const dword)  (usage 3)
Strings23Count                         1  0x00000001 (const dword)  (not used)
Strings23Size                         15  0x0000000f (const dword)  (usage 3)
Strings23StartH                        0  0x00000000 (const dword)  (usage 3)
Strings23StartL                    11776  0x00002e00 (const dword)  (usage 3)
Strings24Count                         1  0x00000001 (const dword)  (not used)
Strings24Size                         26  0x0000001a (const dword)  (usage 3)
Strings24StartH                        0  0x00000000 (const dword)  (usage 3)
Strings24StartL                    12288  0x00003000 (const dword)  (usage 3)
Strings25Count                         1  0x00000001 (const dword)  (not used)
Strings25Size                         10  0x0000000a (const dword)  (usage 3)
Strings25StartH                        0  0x00000000 (const dword)  (usage 3)
Strings25StartL                    12800  0x00003200 (const dword)  (usage 3)
Strings26Count                         1  0x00000001 (const dword)  (not used)
Strings26Size                         10  0x0000000a (const dword)  (usage 3)
Strings26StartH                        0  0x00000000 (const dword)  (usage 3)
Strings26StartL                    13312  0x00003400 (const dword)  (usage 3)
Strings27Count                         1  0x00000001 (const dword)  (not used)
Strings27Size                         11  0x0000000b (const dword)  (usage 3)
Strings27StartH                        0  0x00000000 (const dword)  (usage 3)
Strings27StartL                    13824  0x00003600 (const dword)  (usage 3)
Strings2Count                          0  0x00000000 (const dword)  (not used)
Strings2Size                           1  0x00000001 (const dword)  (usage 3)
Strings2StartH                         0  0x00000000 (const dword)  (usage 3)
Strings2StartL                      4608  0x00001200 (const dword)  (usage 3)
Strings3Count                          1  0x00000001 (const dword)  (not used)
Strings3Size                          18  0x00000012 (const dword)  (usage 3)
Strings3StartH                         0  0x00000000 (const dword)  (usage 3)
Strings3StartL                      1024  0x00000400 (const dword)  (usage 3)
Strings4Count                          1  0x00000001 (const dword)  (not used)
Strings4Size                          25  0x00000019 (const dword)  (usage 3)
Strings4StartH                         0  0x00000000 (const dword)  (usage 3)
Strings4StartL                      3584  0x00000e00 (const dword)  (usage 3)
Strings5Count                          1  0x00000001 (const dword)  (not used)
Strings5Size                          13  0x0000000d (const dword)  (usage 3)
Strings5StartH                         0  0x00000000 (const dword)  (usage 3)
Strings5StartL                      3072  0x00000c00 (const dword)  (usage 3)
Strings6Count                          1  0x00000001 (const dword)  (not used)
Strings6Size                          26  0x0000001a (const dword)  (usage 3)
Strings6StartH                         0  0x00000000 (const dword)  (usage 3)
Strings6StartL                      4096  0x00001000 (const dword)  (usage 3)
Strings7Count                          0  0x00000000 (const dword)  (not used)
Strings7Size                           1  0x00000001 (const dword)  (usage 3)
Strings7StartH                         0  0x00000000 (const dword)  (usage 3)
Strings7StartL                      5120  0x00001400 (const dword)  (usage 3)
Strings8Count                          1  0x00000001 (const dword)  (not used)
Strings8Size                          25  0x00000019 (const dword)  (usage 3)
Strings8StartH                         0  0x00000000 (const dword)  (usage 3)
Strings8StartL                      5632  0x00001600 (const dword)  (usage 3)
Strings9Count                          1  0x00000001 (const dword)  (not used)
Strings9Size                          25  0x00000019 (const dword)  (usage 3)
Strings9StartH                         0  0x00000000 (const dword)  (usage 3)
Strings9StartL                      2048  0x00000800 (const dword)  (usage 3)
stringsCV                             60  0x0000003c (mem) word[28] (global)  (usage 27)
strlen                               -10  0xfffffff6 (PmmC func) args[1] r=1  (not used)
strwidth                            -160  0xffffff60 (PmmC func) args[1] r=1  (not used)
STSize                                 4  0x00000004 (const dword)  (usage 3)
STStartH                               0  0x00000000 (const dword)  (usage 3)
STStartL                               2  0x00000002 (const dword)  (usage 3)
STTransparent                         20  0x00000014 (const dword)  (usage 3)
STx1                                   6  0x00000006 (const dword)  (usage 12)
STx2                                  10  0x0000000a (const dword)  (usage 9)
STy1                                   8  0x00000008 (const dword)  (usage 12)
STy2                                  12  0x0000000c (const dword)  (usage 9)
STYLE1                                 2  0x00000002 (const dword)  (not used)
STYLE2                                 3  0x00000003 (const dword)  (not used)
SWAP                                 -16  0xfffffff0 (PmmC func) args[2] r=0  (not used)
sys_DeepSleep                       -295  0xfffffed9 (PmmC func) args[1] r=1  (not used)
sys_EventQueue                      -194  0xffffff3e (PmmC func) args[0] r=1  (not used)
sys_EventsPostpone                  -195  0xffffff3d (PmmC func) args[0] r=0  (not used)
sys_EventsResume                    -196  0xffffff3c (PmmC func) args[0] r=0  (usage 3)
sys_GetTimer                        -192  0xffffff40 (PmmC func) args[1] r=1  (not used)
sys_SetTimer                        -191  0xffffff41 (PmmC func) args[2] r=0  (not used)
sys_SetTimerEvent                   -193  0xffffff3f (PmmC func) args[2] r=1  (not used)
sys_Sleep                           -197  0xffffff3b (PmmC func) args[1] r=1  (not used)
sys_StoreTouchCalibration           -280  0xfffffee8 (PmmC func) args[0] r=1  (not used)
sys_T                               -189  0xffffff43 (PmmC func) args[0] r=1  (not used)
sys_T_HI                            -190  0xffffff42 (PmmC func) args[0] r=1  (not used)
SYS_X_MAX                             44  0x0000002c (const dword)  (not used)
SYS_Y_MAX                             45  0x0000002d (const dword)  (not used)
SYSTEM_TIMER_HI                       35  0x00000023 (const dword)  (not used)
SYSTEM_TIMER_LO                       34  0x00000022 (const dword)  (not used)
t4Dbutton                             30  0x0000001e (const dword)  (usage 15)
TAN                                54705  0x0000d5b1 (const dword)  (not used)
tAngularmeter                          7  0x00000007 (const dword)  (usage 3)
tAniButton                            31  0x0000001f (const dword)  (usage 6)
tColorPicker                          32  0x00000020 (const dword)  (usage 3)
tCoolgauge                             8  0x00000008 (const dword)  (usage 3)
tCustomdigits                          9  0x00000009 (const dword)  (usage 6)
tDipSwitch                             0  0x00000000 (const dword)  (usage 3)
TEAL                                1040  0x00000410 (const dword)  (not used)
TEXT                               63489  0x0000f801 (const dword)  (not used)
TEXT_ATTRIBUTES                       13  0x0000000d (const dword)  (not used)
TEXT_BACKGROUND                        1  0x00000001 (const dword)  (not used)
TEXT_BOLD                              9  0x00000009 (const dword)  (not used)
TEXT_COLOUR                            0  0x00000000 (const dword)  (not used)
TEXT_HEIGHT                            4  0x00000004 (const dword)  (not used)
TEXT_HIGHLIGHT                         1  0x00000001 (const dword)  (not used)
TEXT_INVERSE                          11  0x0000000b (const dword)  (not used)
TEXT_ITALIC                           10  0x0000000a (const dword)  (not used)
TEXT_MARGIN                           97  0x00000061 (const dword)  (not used)
TEXT_OPACITY                           8  0x00000008 (const dword)  (not used)
TEXT_PRINTDELAY                        7  0x00000007 (const dword)  (not used)
TEXT_UNDERLINED                       12  0x0000000c (const dword)  (not used)
TEXT_WIDTH                             3  0x00000003 (const dword)  (not used)
TEXT_WRAP                             14  0x0000000e (const dword)  (not used)
TEXT_XGAP                              5  0x00000005 (const dword)  (not used)
TEXT_XPOS                             95  0x0000005f (const dword)  (not used)
TEXT_YGAP                              6  0x00000006 (const dword)  (not used)
TEXT_YPOS                             96  0x00000060 (const dword)  (not used)
tForm                                 10  0x0000000a (const dword)  (usage 15)
tGauge                                11  0x0000000b (const dword)  (usage 3)
tGSlider                               4  0x00000004 (const dword)  (usage 3)
THISTLE                            56827  0x0000ddfb (const dword)  (not used)
tImage                                12  0x0000000c (const dword)  (usage 3)
TIMER0                                 0  0x00000000 (const dword)  (not used)
TIMER1                                 1  0x00000001 (const dword)  (not used)
TIMER2                                 2  0x00000002 (const dword)  (not used)
TIMER3                                 3  0x00000003 (const dword)  (not used)
TIMER4                                 4  0x00000004 (const dword)  (not used)
TIMER5                                 5  0x00000005 (const dword)  (not used)
TIMER6                                 6  0x00000006 (const dword)  (not used)
TIMER7                                 7  0x00000007 (const dword)  (not used)
tKeyboard                             13  0x0000000d (const dword)  (usage 3)
tKnob                                  1  0x00000001 (const dword)  (usage 3)
tLed                                  14  0x0000000e (const dword)  (usage 3)
tLeddigits                            15  0x0000000f (const dword)  (usage 12)
tMeter                                16  0x00000010 (const dword)  (usage 3)
TMR0                                  36  0x00000024 (const dword)  (not used)
TMR1                                  37  0x00000025 (const dword)  (not used)
TMR2                                  38  0x00000026 (const dword)  (not used)
TMR3                                  39  0x00000027 (const dword)  (not used)
TMR4                                  40  0x00000028 (const dword)  (not used)
TMR5                                  41  0x00000029 (const dword)  (not used)
TMR6                                  42  0x0000002a (const dword)  (not used)
TMR7                                  43  0x0000002b (const dword)  (not used)
to                                    -5  0xfffffffb (PmmC func) args[1] r=1  (not used)
tolower                             -212  0xffffff2c (PmmC func) args[1] r=1  (not used)
TOMATO                             64264  0x0000fb08 (const dword)  (not used)
TOP_POS                                3  0x00000003 (const dword)  (not used)
touch_DetectRegion                  -199  0xffffff39 (PmmC func) args[4] r=0  (not used)
TOUCH_DISABLE                          1  0x00000001 (const dword)  (not used)
TOUCH_ENABLE                           0  0x00000000 (const dword)  (usage 3)
touch_Get                           -201  0xffffff37 (PmmC func) args[1] r=1  (usage 9)
TOUCH_GETX                             1  0x00000001 (const dword)  (usage 3)
TOUCH_GETY                             2  0x00000002 (const dword)  (usage 3)
TOUCH_MOVING                           3  0x00000003 (const dword)  (usage 3)
TOUCH_PRESSED                          1  0x00000001 (const dword)  (usage 9)
TOUCH_RAW_X                          117  0x00000075 (const dword)  (not used)
TOUCH_RAW_Y                          118  0x00000076 (const dword)  (not used)
TOUCH_REGIONDEFAULT                    2  0x00000002 (const dword)  (not used)
TOUCH_RELEASED                         2  0x00000002 (const dword)  (usage 18)
touch_Set                           -200  0xffffff38 (PmmC func) args[1] r=0  (usage 3)
TOUCH_STATUS                           0  0x00000000 (const dword)  (usage 3)
TOUCH_XMAXCAL                         80  0x00000050 (const dword)  (not used)
TOUCH_XMINCAL                         78  0x0000004e (const dword)  (not used)
TOUCH_YMAXCAL                         81  0x00000051 (const dword)  (not used)
TOUCH_YMINCAL                         79  0x0000004f (const dword)  (not used)
toupper                             -211  0xffffff2d (PmmC func) args[1] r=1  (not used)
tPinInput                             29  0x0000001d (const dword)  (usage 6)
tPinOutput                            28  0x0000001c (const dword)  (usage 6)
translate                             -8  0xfffffff8 (PmmC func) args[4] r=1  (not used)
TRANSPARENCY                          21  0x00000015 (const dword)  (not used)
TRANSPARENT                            0  0x00000000 (const dword)  (usage 3)
TRANSPARENT_COLOUR                    20  0x00000014 (const dword)  (not used)
tRockerSwitch                          2  0x00000002 (const dword)  (usage 3)
tRotarySwitch                          3  0x00000003 (const dword)  (usage 3)
tScope                                25  0x00000019 (const dword)  (not used)
tSounds                               22  0x00000016 (const dword)  (usage 6)
tSpectrum                             24  0x00000018 (const dword)  (usage 3)
TState                               194  0x000000c2 (mem) word (global)  (usage 24)
tStaticText                           21  0x00000015 (const dword)  (usage 3)
tStrings                              17  0x00000011 (const dword)  (usage 18)
tTank                                 26  0x0000001a (const dword)  (usage 3)
tThermometer                          18  0x00000012 (const dword)  (usage 3)
tTimer                                23  0x00000017 (const dword)  (usage 6)
tTrackbar                              5  0x00000005 (const dword)  (usage 3)
TurnOffButtons                      8457  0x00002109 (User func) args[1] r=0  (usage 6)
TURQUOISE                          18202  0x0000471a (const dword)  (not used)
tUserButton                           33  0x00000021 (const dword)  (usage 207)
tUserImages                           27  0x0000001b (const dword)  (usage 3)
tUserled                              19  0x00000013 (const dword)  (usage 3)
tVideo                                20  0x00000014 (const dword)  (usage 3)
tWinButton                             6  0x00000006 (const dword)  (usage 39)
txt_Attributes                       -38  0xffffffda (PmmC func) args[1] r=1  (usage 3)
txt_BGcolour                         -26  0xffffffe6 (PmmC func) args[1] r=1  (usage 3)
txt_Bold                             -34  0xffffffde (PmmC func) args[1] r=1  (not used)
txt_Delay                            -32  0xffffffe0 (PmmC func) args[1] r=1  (not used)
txt_FGcolour                         -25  0xffffffe7 (PmmC func) args[1] r=1  (usage 3)
TXT_FONT_HEIGHT                      102  0x00000066 (const dword)  (not used)
TXT_FONT_ID                           98  0x00000062 (const dword)  (not used)
TXT_FONT_MAX                          99  0x00000063 (const dword)  (not used)
TXT_FONT_OFFSET                      100  0x00000064 (const dword)  (not used)
TXT_FONT_WIDTH                       101  0x00000065 (const dword)  (not used)
txt_FontID                           -27  0xffffffe5 (PmmC func) args[1] r=1  (usage 3)
txt_Height                           -29  0xffffffe3 (PmmC func) args[1] r=1  (not used)
txt_Inverse                          -36  0xffffffdc (PmmC func) args[1] r=1  (not used)
txt_Italic                           -35  0xffffffdd (PmmC func) args[1] r=1  (not used)
txt_MoveCursor                       -23  0xffffffe9 (PmmC func) args[2] r=0  (not used)
txt_Opacity                          -33  0xffffffdf (PmmC func) args[1] r=1  (usage 3)
txt_Set                              -24  0xffffffe8 (PmmC func) args[2] r=0  (not used)
txt_Underline                        -37  0xffffffdb (PmmC func) args[1] r=1  (not used)
txt_Width                            -28  0xffffffe4 (PmmC func) args[1] r=1  (not used)
txt_Wrap                             -39  0xffffffd9 (PmmC func) args[1] r=1  (not used)
txt_Xgap                             -30  0xffffffe2 (PmmC func) args[1] r=1  (not used)
txt_Ygap                             -31  0xffffffe1 (PmmC func) args[1] r=1  (not used)
uadd_3232                           -290  0xfffffede (PmmC func) args[3] r=1  (usage 3)
ucmp_3232                           -292  0xfffffedc (PmmC func) args[2] r=1  (not used)
UDEC                               17674  0x0000450a (const dword)  (not used)
UDEC1                              16650  0x0000410a (const dword)  (not used)
UDEC1Z                             20746  0x0000510a (const dword)  (not used)
UDEC1ZB                            24842  0x0000610a (const dword)  (not used)
UDEC2                              16906  0x0000420a (const dword)  (not used)
UDEC2Z                             21002  0x0000520a (const dword)  (not used)
UDEC2ZB                            25098  0x0000620a (const dword)  (not used)
UDEC3                              17162  0x0000430a (const dword)  (not used)
UDEC3Z                             21258  0x0000530a (const dword)  (not used)
UDEC3ZB                            25354  0x0000630a (const dword)  (not used)
UDEC4                              17418  0x0000440a (const dword)  (not used)
UDEC4Z                             21514  0x0000540a (const dword)  (not used)
UDEC4ZB                            25610  0x0000640a (const dword)  (not used)
UDEC5                              17674  0x0000450a (const dword)  (not used)
UDEC5Z                             21770  0x0000550a (const dword)  (not used)
UDEC5ZB                            25866  0x0000650a (const dword)  (not used)
UDECZ                              21770  0x0000550a (const dword)  (not used)
UDECZB                             25866  0x0000650a (const dword)  (not used)
ULCD_32PT_GFX                          0  0x00000000 (const ??? 0)  (not used)
umul_1616                           -289  0xfffffedf (PmmC func) args[3] r=1  (usage 3)
UNDERLINED                           128  0x00000080 (const dword)  (not used)
unicode_page                        -281  0xfffffee7 (PmmC func) args[3] r=1  (not used)
UP                                     1  0x00000001 (const dword)  (not used)
UpdateObjects                       7154  0x00001bf2 (User func) args[1] r=0  (usage 3)
USER_INITIALIZED_DISPLAY              32  0x00000020 (const dword)  (not used)
usub_3232                           -291  0xfffffedd (PmmC func) args[3] r=1  (not used)
VCOM_CONTROL_1                        67  0x00000043 (const dword)  (not used)
VCOM_CONTROL_2                        68  0x00000044 (const dword)  (not used)
VCOM_CONTROL_3                        69  0x00000045 (const dword)  (not used)
VIOLET                             60445  0x0000ec1d (const dword)  (not used)
WHEAT                              63222  0x0000f6f6 (const dword)  (usage 3)
WHITE                              65535  0x0000ffff (const dword)  (usage 78)
WHITESMOKE                         63422  0x0000f7be (const dword)  (not used)
WRITE_CONTRAST                         4  0x00000004 (const dword)  (usage 3)
WRITE_OBJ                              1  0x00000001 (const dword)  (usage 3)
WRITE_STR                              2  0x00000002 (const dword)  (usage 3)
WRITE_STRU                             3  0x00000003 (const dword)  (usage 3)
WriteCmd                               0  0x00000000 (const dword)  (not used)
WriteObject                         8656  0x000021d0 (User func) args[3] r=0  (usage 24)
x                                    188  0x000000bc (mem) word (global)  (usage 12)
X_MAX                                  0  0x00000000 (const dword)  (not used)
X_ORG                                  6  0x00000006 (const dword)  (not used)
X_ORIGIN                              30  0x0000001e (const dword)  (not used)
y                                    190  0x000000be (mem) word (global)  (usage 9)
Y_MAX                                  1  0x00000001 (const dword)  (not used)
Y_ORG                                  7  0x00000007 (const dword)  (not used)
Y_ORIGIN                              31  0x0000001f (const dword)  (not used)
YELLOW                             65504  0x0000ffe0 (const dword)  (not used)
YELLOWGREEN                        40550  0x00009e66 (const dword)  (not used)
